
#if 0
namespace internal {

/* ... See Eigen/src/Core/DenseStorage.h. */
class DenseStorage {
 public:
  DenseStorage() = default;
  explicit DenseStorage(Eigen::internal::constructor_without_unaligned_array_assert) {}
  DenseStorage(Eigen::Index size, Eigen::Index rows, Eigen::Index cols) {
    resize(size, rows, cols);
  }

  DenseStorage(const DenseStorage& other);
  DenseStorage& operator=(const DenseStorage& other);
  DenseStorage(DenseStorage&& other) noexcept;
  DenseStorage& operator=(DenseStorage&& other);

  ~DenseStorage() = default;

  Eigen::Index rows() const { return rows_; }
  Eigen::Index cols() const { return cols_; }
  const AutoDiffScalar* data() const { return data_.data(); }
  AutoDiffScalar* data() { return data_.data(); }

  void conservativeResize(Eigen::Index size, Eigen::Index rows, Eigen::Index cols) {
    DRAKE_ASSERT(size == rows * cols);
    data_.resize(size);
    rows_ = rows;
    cols_ = cols;
  }
  void resize(Eigen::Index size, Eigen::Index rows, Eigen::Index cols) {
    conservativeResize(size, rows, cols);
  }
  void swap(DenseStorage& other);

 private:
  std::vector<AutoDiffScalar> data_;
  Eigen::Index rows_{0};
  Eigen::Index cols_{0};
};
}  // namespace internal
#endif

#if 0
namespace Eigen {

/** A specialization of DenseStorage for use by Drake's AutoDiffScalar. 
This is for fully-dynamic matrices. */
template <>
class DenseStorage<
  /* T = */ drake::autodiff::AutoDiffScalar,
  /* Size = */ Dynamic,
  /* _Rows = */ Dynamic,
  /* _Cols = */ Dynamic,
  /* _Options = */ 0>
  : public drake::autodiff::internal::DenseStorage {};

}  // namespace Eigen
#endif



#if 0
/// Overloads copysign from <cmath>.
template <typename DerType, typename T>
Eigen::AutoDiffScalar<DerType> copysign(const Eigen::AutoDiffScalar<DerType>& x,
                                        const T& y) {
  using std::isnan;
  if (isnan(x)) return (y >= 0) ? NAN : -NAN;
  if ((x < 0 && y >= 0) || (x >= 0 && y < 0))
    return -x;
  else
    return x;
}

/// Overloads copysign from <cmath>.
template <typename DerType>
double copysign(double x, const Eigen::AutoDiffScalar<DerType>& y) {
  using std::isnan;
  if (isnan(x)) return (y >= 0) ? NAN : -NAN;
  if ((x < 0 && y >= 0) || (x >= 0 && y < 0))
    return -x;
  else
    return x;
}

/// Overloads pow for an AutoDiffScalar base and exponent, implementing the
/// chain rule.
template <typename DerTypeA, typename DerTypeB>
Eigen::AutoDiffScalar<
    typename internal::remove_all<DerTypeA>::type::PlainObject>
pow(const Eigen::AutoDiffScalar<DerTypeA>& base,
    const Eigen::AutoDiffScalar<DerTypeB>& exponent) {
  // The two AutoDiffScalars being exponentiated must have the same matrix
  // type. This includes, but is not limited to, the same scalar type and
  // the same dimension.
  static_assert(
      std::is_same_v<
          typename internal::remove_all<DerTypeA>::type::PlainObject,
          typename internal::remove_all<DerTypeB>::type::PlainObject>,
      "The derivative types must match.");

  internal::make_coherent(base.derivatives(), exponent.derivatives());

  const auto& x = base.value();
  const auto& xgrad = base.derivatives();
  const auto& y = exponent.value();
  const auto& ygrad = exponent.derivatives();

  using std::pow;
  using std::log;
  const auto x_to_the_y = pow(x, y);
  if (ygrad.isZero(std::numeric_limits<double>::epsilon()) ||
      ygrad.size() == 0) {
    // The derivative only depends on ∂(x^y)/∂x -- this prevents undefined
    // behavior in the corner case where ∂(x^y)/∂y is infinite when x = 0,
    // despite ∂y/∂v being 0.
    return Eigen::MakeAutoDiffScalar(x_to_the_y, y * pow(x, y - 1) * xgrad);
  }
  return Eigen::MakeAutoDiffScalar(
      // The value is x ^ y.
      x_to_the_y,
      // The multivariable chain rule states:
      // df/dv_i = (∂f/∂x * dx/dv_i) + (∂f/∂y * dy/dv_i)
      // ∂f/∂x is y*x^(y-1)
      y * pow(x, y - 1) * xgrad +
      // ∂f/∂y is (x^y)*ln(x)
      x_to_the_y * log(x) * ygrad);
}

#endif
