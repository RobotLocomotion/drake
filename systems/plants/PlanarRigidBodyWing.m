classdef PlanarRigidBodyWing < RigidBodyWing

  methods
    function obj = PlanarRigidBodyWing(profile, aero_origin, chord, span, stallAngle, velocity, parent_body)
%{
      %TODO:
      % Implement some values for post-stall CMs
      %     i.e. at 90 degrees aoa, the center of pressure should be
      %     at the half chord.
      % There is no pitch support in the planar case--the wing must be
      % aligned with its parent body
      %
      %calls AVL and XFOIL over different angles of attack at the
      %given velocity, generates first order polynomials of the CL,
      %CD, and pitch moments of the wing.  The axes for use in DRAKE are:
      %   X = forward, in the usual direction of travel
      %   Y = out the left side of the wing
      %   Z = up
      % % @param profile = Profile can either be a:
      %         -NACA airfoil designation starting with 'NACA'
      %         -File location of a .dat file generated by xfoil
      %         -File location of a .mat file which contains the
      %         variables 'CLSpline', 'CDSpline', 'CMSpline'
      %         -the words 'flat plate'
      % @param aero_origin = [x z] Quarter-chord of 
      %         the airfoil with respect to the body it is mounted on.
      %         NOTE: the wing axes are bound to the axis of the
      %         parent body in the convention above.  I.e. the x-axis
      %         of the parent body should be forward, in the typical
      %         direction of travel.  The Y-axis is tangent to the
      %         leading edge. This is done to avoid any complexity or confusion on
      %         angle conventions. If you want to rotate the wing,
      %         just define the rotation of its parent body in the
      %         URDF. 
      %         The XYZ point should be the
      %         quarter-chord point for flat plates, symmetric
      %         airfoils, and when you're not exactly sure of what it
      %         should be. The post-stall CM's are assuming that the
      %         aero_origin is at the quarter chord(Note, not implemented
      %         yet)
      % @param chord = the chord of the wing (meters)
      % @param span = the wing span (width) of the wing (meters)
      % @param stallAngle = user-defined angle at which the wing
      %          stalls (degrees).  The negative of the stall angle
      %          is used for AoA<0, even though airfoils do not stall
      %          at exactly the same abs(AoA).
      % @param velocity = the approximate operating velocity of the wing.
      %        Needed to pass in the correct Reynolds and Mach numbers to the
      %        to the numerical solvers to generate appropriate CL and CD
      %        splines.
%}   
      obj = obj@RigidBodyWing(profile, aero_origin, chord, span, stallAngle, velocity, parent_body, false);
    end %constructor

    function f_ext = computeSpatialForce(obj,manip,q,qd)
      kinsol = doKinematics(manip,q, false, false);
      %origin = [x z theta] of the reference point
      [x,J] = forwardKin(manip,kinsol,obj.bodyind,obj.origin(1:2), 1);
      %Gradients look good
      %[xnum, Jnum] = geval(@forwardKin, manip,kinsol,obj.body,obj.origin(1:2), true);
      v = J*qd;
      %velocity of the wing (flight path) in world coordinates
      windvel = -v(1:2);  % assume still air
      airspeed = norm(windvel);
      %To add pitch support, use the following commented line:(check the sign of aero_origin(3) though)
      %aoa = 180*(-aero_origin(3)+x(3) - atan2(v(2),v(1)))/pi;
      aoa = 180*(x(3) - atan2(v(2),v(1)))/pi;
      % mod 360 so -180<AoA<180
      if aoa>180
          aoa = aoa-360*fix((aoa+180)/360);
      elseif aoa<-180
          aoa = aoa-360*fix((aoa-180)/360);
      end
      f_ext = sparse(3,length(manip.body));
      %lift and drag are the forces on the body in the world frame.
      lift_world = ppvalSafe(obj.fCl,aoa, false, false)*airspeed*[windvel(2);-windvel(1)];
      drag_world = ppvalSafe(obj.fCd,aoa, false, false)*airspeed*windvel;
      torque = -ppvalSafe(obj.fCm,aoa, false, false)*airspeed*airspeed*manip.body(obj.bodyind).jsign;
      %inputs of point (body coordinates), and force (world coordinates)
      %returns [torque; xforce; yforce] in the body coordinates
      f_ext(:,obj.bodyind) = [torque;0;0] + ...
        cartesianForceToSpatialForce(manip, kinsol, obj.bodyind, obj.origin,lift_world+drag_world);
      f_ext;
    end
   
  end
  
end
