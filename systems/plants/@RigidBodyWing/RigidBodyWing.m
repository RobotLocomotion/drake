classdef RigidBodyWing < RigidBodyForceElement

  properties
    bodyind    % RigidBody index
    origin=zeros(3,1);  %xyz of the reference point for the wing
    fCl  % splines representing the *dimensional* coefficients
    fCd  %  with fCl = 1/2 rho*S*Cl, etc.
    fCm
    area
  end
  
  methods
    function obj = RigidBodyWing(profile, aero_origin, chord, span, stallAngle, velocity, parent_body)
      %TODO:
      % Implement some values for post-stall CMs
      %     i.e. at 90 degrees aoa, the center of pressure should be
      %     at the half chord.
      % use variables for path to xfoil and AVL
      %
      % Add support for Mac OS?  unless system calls are the same as
      % linux
      %
      %calls AVL and XFOIL over different angles of attack at the
      %given velocity, generates first order polynomials of the CL,
      %CD, and 3 roll moments of the wing.  The axes are:
      %   X = forward, in the usual direction of travel
      %   Y = out the left side of the wing
      %   Z = up
      % @param profile = Profile can either be a:
      %         -NACA airfoil designation starting with 'NACA'
      %         -File location of a .dat file generated by xfoil
      %         -File location of a .mat file which contains the
      %         variables 'CLSpline', 'CDSpline', 'CMSpline'
      %         -the words 'flat plate'
      % @param aero_origin = [x y z] Aerodynamic center of the
      %         airfoil with respect to the body it is mounted on.
      %         NOTE: the wing axes are bound to the axis of the
      %         parent body in the convention above.  I.e. the x-axis
      %         of the parent body should be forward, in the typical
      %         direction of travel.  The Y-axis is tangent to the
      %         leading edge. This is done to avoid any complexity or confusion on
      %         angle conventions. If you want to rotate the wing,
      %         just define the rotation of its parent body in the
      %         URDF. (Note, this is unlike the planar case)
      %         The XYZ point should be the
      %         quarter-chord point for flat plates, symmetric
      %         airfoils, and when you're not exactly sure of what it
      %         should be.
      % @param chord = the chord of the wing (meters)
      % @param span = the wing span (width) of the wing (meters)
      % @param stallAngle = user-defined angle at which the wing
      %          stalls (degrees).  The negative of the stall angle
      %          is used for AoA<0, even though airfoils do not stall
      %          at exactly the same abs(AoA).
      % @param velocity = the approximate operating velocity of the wing.
      %        Needed to pass in the correct Reynolds and Mach numbers to the
      %        to the numerical solvers to generate appropriate CL and CD
      %        splines.
      
      %Check that parent_body is a RigidBody object.
      if ~isa(parent_body, 'numeric');
        error('Drake:PRigidBodyWing:InvalidParent','Force Type Wing does not have a proper RigidBody parent');
      end
      obj.origin = reshape(aero_origin, 3, 1);
      obj.bodyind = parent_body;
      linux = isunix();
      obj.area = chord*span;
      mach = velocity/341;
      %Reynolds number calculation for 10 deg C and sea level
      Re = velocity*chord/.0000144;
      profile = deblank(profile);
      disp('Constructing a new airfoil');
      if strcmpi(profile(end-3:end), '.mat')
        load(profile, 'CLSpline', 'CDSpline', 'CMSpline')
        obj.fCl = CLSpline;
        obj.fCd = CDSpline;
        obj.fCm = CMSpline;
      elseif strcmpi(profile, 'flat plate')
        flatplate()
      else % not flat plate
        checkDependency('avl');
        checkDependency('xfoil');
        load drake_config;
        avlpath = conf.avl;
        xfoilpath = conf.xfoil;
        
        if strcmp(profile(1:4),'NACA')
          profile = strtrim(profile(5:end));
          avlprofile = strcat('NACA', '\n', profile);
          xfoilprofile = strcat('NACA ', profile);
        elseif strcmpi(profile(end-3:end), '.dat')
          avlprofile = strcat('AFILE', '\n', profile);
          xfoilprofile = strcat('LOAD', '\n', profile);
        else
          err = MException('InputType:NotSupported', 'Input profile not supported. (.dat, .m, NACA, flat plate)');
          throw(err);
        end
        %{
                Reads in template avl files defining the geometry of the wing and the run
                profile (airspeed, AoA).  Then replaces the appropriate fields in the
                Template files with the correct numbers.
                The .0001 additions are to avoid repeated angles.
        %}
        angles = -stallAngle:stallAngle/12:(stallAngle-.0001);
        avlfile = fileread(which('avlblank.avl'));
        runfiletemplate = fileread(which('avlblank.run'));
        
        avlfile = regexprep(avlfile, '\$airfoil', avlprofile);
        avlfile = regexprep(avlfile, '\$span', sprintf('%.1f',span));
        avlfile = regexprep(avlfile, '\$chord', sprintf('%.1f',chord));
        avlfile = regexprep(avlfile, '\$area', sprintf('%.1f',obj.area));
        avlfile = regexprep(avlfile, '\$mach', sprintf('%.4f',mach));
        avlfile = regexprep(avlfile, '\$yle', sprintf('%.2f',span/2));
        avlfile = regexprep(avlfile, '\$Xorig', sprintf('%.2f',aero_origin(1)));
        avlfile = regexprep(avlfile, '\$Yorig', sprintf('%.2f',aero_origin(2)));
        avlfile = regexprep(avlfile, '\$Zorig', sprintf('%.2f',aero_origin(3)));
        avlid = fopen(fullfile(tempdir,'URDF.avl'), 'w');
        fprintf(avlid, avlfile);
        %writes the case-specific files avl requires to run
        runid = fopen(fullfile(tempdir,'URDF.run'), 'w');
        avlcommandfile = fopen(fullfile(tempdir,'myavlcommands.txt'), 'w');
        avlcommandstring = sprintf('OPER\nX\nW\navlresults.txt\n');
        for x = 1:length(angles)
          runfile = regexprep(runfiletemplate, '\$casenum', sprintf('%d',x));
          runfile = regexprep(runfile, '\$alpha', sprintf('%.2f',angles(x)));
          runfile = regexprep(runfile, '\$mach', sprintf('%.1f',mach));
          runfile = regexprep(runfile, '\$vel', sprintf('%.1f',velocity));
          runfile = regexprep(runfile, '\$span', sprintf('%.1f',span));
          fprintf(runid, runfile);
          if x ~=1 % case 1 is already taken care of above.  Need to do this way to get the output filename correct
            avlcommandstring = [avlcommandstring, sprintf('%d\nX\nW\n\n', x)];
          end
        end
        avlcommandstring = [avlcommandstring, sprintf('\nquit')];
        fprintf(avlcommandfile, avlcommandstring);
        fclose(avlcommandfile);
        fclose(runid);
        disp('AVL Config file written--running AVL...');
        % runs AVL.  This generates results.txt, which CL, Cm, and part of CD is
        % extracted from.
        try
          if(linux)
            commandfilepath = fullfile(tempdir,'myavlcommands.txt');
            avlfilepath = fullfile(tempdir, 'URDF.avl');
            runfilepath = fullfile(tempdir, 'URDF.run');
            %result = system('./avlscript')
            result = system(sprintf('avl %s %s < %s &', avlfilepath, runfilepath, commandfilepath));
            %system(sprintf('LD_LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4 %s URDF.avl URDF.run < myavlcommands.txt > /dev/null', avlpath));
            
          else
            result = system(sprintf('%s URDF.avl URDF.run < myavlcommands.txt > trash.txt', avlpath));
            %output piped to a file to avoid cluttering
            %Matlab's screen output
            delete('trash.txt');
          end
          %disp('end of try')
        catch E
          disp('Error running AVL.  Switching to Flat Plate.  Results likely inaccurate')
          flatplate()
          return
        end
        if result ~= 0%if AVL didn't execute properly
          disp('Error running AVL.  Switching to Flat Plate.  Results likely inaccurate')
          flatplate()
          return
        end
        disp('Processing AVL output...')
        avlresult = fileread(fullfile(tempdir,'avlresults.txt'));
        AoAindices = strfind(avlresult, 'Alpha =');
        AoAindices = AoAindices + 8;
        AoAs = [];
        for x = 1:length(AoAindices)
          AoAs = [AoAs str2double(avlresult(AoAindices(x):AoAindices(x)+6))];
        end
        CLindices = strfind(avlresult, 'CLtot =');
        CLindices = CLindices + 8;
        CLs = [];
        for x = 1:length(CLindices)
          CLs = [CLs str2double(avlresult(CLindices(x):CLindices(x)+6))];
        end
        CDindices = strfind(avlresult, 'CDtot =');
        CDindices = CDindices + 8;
        CDs = [];
        for x = 1:length(CDindices)
          CDs = [CDs str2double(avlresult(CDindices(x):CDindices(x)+6))];
        end
        Cmindices = strfind(avlresult, 'Cmtot =');
        Cmindices = Cmindices + 8;
        CMs = [];
        for x = 1:length(Cmindices)
          CMs = [CMs str2double(avlresult(Cmindices(x):Cmindices(x)+6))];
        end
        
        % Reads template Xfoil commands file and fills in appropriate values
        xfoilfile = fileread('xfoilblank.txt');
        xfoilfile = regexprep(xfoilfile, '\$airfoil', xfoilprofile);
        xfoilfile = regexprep(xfoilfile, '\$re', sprintf('%.2f',Re));
        xfoilfile = regexprep(xfoilfile, '\$mach', sprintf('%.4f',mach));
        xfoilfile = regexprep(xfoilfile, '\$negStallAngle', sprintf('%.1f',-stallAngle));
        xfoilfile = regexprep(xfoilfile, '\$stallAngle', sprintf('%.1f',stallAngle));
        xfoilid = fopen('xfoilcommands.txt', 'w');
        fprintf(xfoilid, xfoilfile);
        fclose(xfoilid);
        %runs Xfoil.
        disp('Xfoil Commands written. Running XFOIL...')
        try
          if exist('xfoilPolar.txt', 'file');
            delete('xfoilPolar.txt');
          end
          if (linux)
            %system(sprintf('LD_LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.6 %s < xfoilcommands.txt > xfoilCMDoutput.txt', xfoilpath));
            result = system(sprintf('%s < xfoilcommands.txt > xfoilCMDoutput.txt &', xfoilpath));
          else
            result = system(sprintf('%s < xfoilcommands.txt > xfoilCMDoutput.txt', xfoilpath));
          end
          disp('Processing Xfoil output')
          xfoilresult = fopen('xfoilPolar.txt');
          xfoillines = textscan(xfoilresult, '%[^\r\n]');
          fclose(xfoilresult);
          %Strips down the output so its just a list of the alpha,
          %CL, CD, CDp, CM numbers from xfoil.  The while loop should run
          %~6 times
          xfoillines = xfoillines{1}(1:end);
          while ~strcmp(xfoillines{1}(1:7), '-------')
            xfoillines = xfoillines(2:end);
          end
          xfoillines = xfoillines(2:end);
        catch E
          disp('Warning: Error in running XFOIL. Drag forces pre-stall are likely underestimated')
          addPostStallPoints()
          makeSplines()
          return
        end
        if result ~= 0 %if XFOIL didn't execute properly
          disp('Warning: Error in running XFOIL. Drag forces pre-stall are likely underestimated')
          addPostStallPoints()
          makeSplines()
          return
        end
        
        Cds = [];
        Cls = [];
        alphas = [];
        for x = 1:length(xfoillines)
          currline = textscan(xfoillines{x}, '%f');
          currline = currline{1};
          alphas = [alphas currline(1)];
          Cls = [Cls currline(2)];
          Cds = [Cds currline(3)];
        end
        %{
                xfoil runs from 0 to negstallangle, then resets and runs
                from 0 to stallangle to promote convergence of solutions.
                (If it started at negstallangle, it may not converge if
                the wing is stalled, so it starts from 0 and works its way
                outwards.)  This creates improper ordering of the output
                file, which these next four lines take care of.
                reorders the matricies from -stallangle to stallangle
        %}
        zeros = find(alphas==0);
        alphas = [fliplr(alphas(zeros(1):zeros(2)-1)) alphas(zeros(2)+1:end)];
        Cls = [fliplr(Cls(zeros(1):zeros(2)-1)) Cls(zeros(2)+1:end)];
        Cds = [fliplr(Cds(zeros(1):zeros(2)-1)) Cds(zeros(2)+1:end)];
        [~, maxloc] = max(Cls);
        if alphas(maxloc)+1 < stallAngle
          disp('Warning: Wing stall detected earlier than the user-specified stall')
        end
        xfoilspline = spline(alphas, Cds);
        %Add the xfoil Cd to the AVL Cd
        try
          for x = 1:length(AoAs)
            CDs(x) = CDs(x) + ppval(xfoilspline, AoAs(x));
          end
        catch E
          disp('Warning: Error in matching up XFOIL Cds. Drag forces are likely underestimated')
        end
        %output piped to a file to avoid cluttering
        %Matlab's screen output
        delete('xfoilCMDoutput.txt');
        %at this point the laminar regime is done.  Now a flat
        %plate approximation is added on from -90 degrees to
        %-stall, and then from stall to +90 degrees
        disp('Laminar regime complete.  Adding post-stall points')
        addPostStallPoints()
        makeSplines()
      end % if not a flat plate
      function addPostStallPoints()
        postStallAngles = stallAngle+2:2:180;
        postStallCLs = 2*sind(postStallAngles).*cosd(postStallAngles);
        postStallCDs = 2*sind(postStallAngles).^2;
        postStallCMs = postStallCDs * 0;
        AoAs = [-fliplr(postStallAngles) AoAs postStallAngles];
        CLs = [-fliplr(postStallCLs) CLs postStallCLs];
        CDs = [fliplr(postStallCDs) CDs postStallCDs];
        CMs = [fliplr(postStallCMs) CMs postStallCMs];
      end
      function flatplate()
        disp('Using a flat plate airfoil.')
        angles = [-180:2:-(stallAngle+.0001) -stallAngle:stallAngle/12:(stallAngle-.0001) stallAngle:2:180];
        obj.fCl = spline(angles, .5*(2*sind(angles).*cosd(angles))*1.245*obj.area);
        obj.fCd = spline(angles, .5*(2*sind(angles).^2)*1.245*obj.area);
        obj.fCm = spline(angles, 0*angles);
      end
      function makeSplines()
        %Dimensionalized splines, such that you only need to
        %multiply by vel^2.  Lift = .5*Cl*rho*area*vel^2
        obj.fCl = spline(AoAs, .5*CLs*1.245*obj.area);
        obj.fCd = spline(AoAs, .5*CDs*1.245*obj.area);
        obj.fCm = spline(AoAs, .5*CMs*1.245*obj.area*chord);
        disp('Aerodynamic Splines Finished')
      end
    end %constructor
    
    function force = computeSpatialForce(obj,manip,q,qd)
      kinsol = doKinematics(manip,q, false, false);
      %origin = [x z theta] of the reference point
      [x,J] = forwardKin(manip,kinsol,obj.bodyind,obj.origin(1:3), 1);
      %Gradients look good
      %[xnum, Jnum] = geval(@forwardKin, manip,kinsol,obj.body,obj.origin(1:2), true);
      v = J*qd;
      %velocity of the wing (flight path) in world coordinates
      wingvel = v(1:3);  % assume still air. Air flow over the wing
      %project this onto the XZ plane of the wing (ignores sideslip)
      kinsolT = kinsol.T{obj.bodyind};
      wingXunit = kinsolT(1:3,1:3)*[1 0 0]';
      wingYunit = kinsolT(1:3,1:3)*[0 1 0]';
      sideslip = dot(wingvel,wingYunit);
      wingXZvelocity = wingvel-(sideslip*wingYunit);
      airspeed = norm(wingXZvelocity);
      %need the angle of attack from the wing's XZ velocity.  This is done
      %by computing the angle between the velocity and the wing's X unit
      %(forward facing) vector, then using a the cross product of these two
      %to determine which direction this angle should be in.
      angVelandZ = acosd(dot(wingXunit,wingXZvelocity)/(norm(wingXunit)*norm(wingXZvelocity)));
      aoa = angVelandZ * sign(dot(cross(wingXunit, wingXZvelocity),wingYunit));
      % mod 360 so -180<AoA<180 Shouldn't be necessary because of acosd
      if aoa>180
        aoa = aoa-360*fix((aoa+180)/360);
      elseif aoa<-180
        aoa = aoa-360*fix((aoa-180)/360);
      end
      force = sparse(6,getNumBodies(manip));
      %lift and drag are the forces on the body in the world frame.
      %cross(wingXZvelocity, wingYunit) rotates it by 90 degrees
      lift_world = ppvalSafe(obj.fCl,aoa, false, false)*airspeed*cross(wingXZvelocity, wingYunit);
      drag_world = ppvalSafe(obj.fCd,aoa, false, false)*airspeed*-wingXZvelocity;
      torque = ppvalSafe(obj.fCm,aoa, false, false)*airspeed*airspeed*wingYunit;
      %inputs of point (body coordinates), and force (world coordinates)
      %returns [torque; xforce; yforce] in the body coordinates
      %obj.body.dofnum should have 6 elements for
      %linkID = manip.findLinkInd(obj.body.linkname, 0);
      force(:,obj.bodyind) = [torque;0;0;0] + ...
        cartesianForceToSpatialForce(manip, kinsol, obj.bodyind, obj.origin(1:3),lift_world+drag_world);
      force;
    end
    function [CL CD CM] = coeffs(AoA)
      %returns dimensionalized coefficient of lift, drag, and pitch moment for a
      %given angle of attack
      CL = ppval(obj.fCl, AoA);
      CD = ppval(obj.fCd, AoA);
      CM = ppval(obj.fCm, AoA);
    end
    function obj = updateBodyIndices(obj,map_from_old_to_new)
      obj.bodyind = map_from_old_to_new(obj.bodyind);
    end
    
  end
  
end
