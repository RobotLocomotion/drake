#pragma once

#include <memory>
#include <set>
#include <string>
#include <utility>
#include <vector>

#include "drake/common/drake_throw.h"
#include "drake/common/unused.h"
#include "drake/systems/framework/cache_entry.h"
#include "drake/systems/framework/framework_common.h"
#include "drake/systems/framework/input_port_base.h"
#include "drake/systems/framework/output_port_base.h"

namespace drake {
namespace systems {

/** Provides non-templatized functionality shared by the templatized System
classes.

Terminology: in general a Drake System is a tree structure composed of
"subsystems", which are themselves System objects. The corresponding Context is
a parallel tree structure composed of "subcontexts", which are themselves
Context objects. There is a one-to-one correspondence between subsystems and
subcontexts. Within a given System (Context), its child subsystems (subcontexts)
are indexed using a SubsystemIndex; there is no separate SubcontextIndex since
the numbering must be identical. */
class SystemBase : public internal::SystemMessageInterface {
 public:
  DRAKE_NO_COPY_NO_MOVE_NO_ASSIGN(SystemBase)

  ~SystemBase() override;

  /** Sets the name of the system. Do not use the path delimiter character ':'
  in the name. When creating a Diagram, names of sibling subsystems should be
  unique. DiagramBuilder uses this method to assign a unique default name if
  none is provided. */
  // TODO(sherm1) Enforce reasonable naming policies.
  void set_name(const std::string& name) { name_ = name; }

  /** Returns the name last supplied to set_name(), if any. Diagrams built with
  DiagramBuilder will always have a default name for every contained subsystem
  for which no user-provided name is available. Systems created by copying with
  a scalar type change have the same name as the source system. An empty string
  is returned if no name has been set. */
  // TODO(sherm1) This needs to be better distinguished from the human-readable
  // name. Consider an api change like get_label() for this one, with the
  // intent that the label could be used programmatically.
  const std::string& get_name() const { return name_; }

  /** Returns a human-readable name for this system, for use in messages and
  logging. This will be the same as returned by get_name(), unless that would
  be an empty string. In that case we return a non-unique placeholder name,
  currently just "_" (a lone underscore). */
  const std::string& GetSystemName() const final {
    return name_.empty() ? internal::SystemMessageInterface::no_name() : name_;
  }

  /** Generates and returns a human-readable full path name of this subsystem,
  for use in messages and logging. The name starts from the root System, with
  "::" delimiters between parent and child subsystems, with the individual
  subsystems represented by their names as returned by GetSystemName(). */
  std::string GetSystemPathname() const final;

  /** Returns the most-derived type of this concrete System object as a
  human-readable string suitable for use in error messages. The format is as
  generated by NiceTypeName and will include namespace qualification if
  present.
  @see NiceTypeName for more specifics. */
  std::string GetSystemType() const final { return NiceTypeName::Get(*this); }

  /** Throws an exception with an appropriate message if the given `context` is
  not compatible with this System. Restrictions may vary for different systems;
  the error message should explain. This can be an expensive check so you may
  want to limit it to Debug builds. */
  void ThrowIfContextNotCompatible(const ContextBase& context) const final {
    CheckValidContext(context);
  }

  /** Returns a Context suitable for use with this System. Context resources
  are allocated based on resource requests that were made during System
  construction. */
  std::unique_ptr<ContextBase> AllocateContext() const {
    // Get a concrete Context of the right type, allocate internal resources
    // like parameters, state, and cache entries, and set up intra- and
    // inter-subcontext dependencies.
    std::unique_ptr<ContextBase> context = DoAllocateContext();

    // We depend on derived classes to call our InitializeContextBase() method
    // after allocating the appropriate concrete Context.
    DRAKE_DEMAND(
        detail::SystemBaseContextBaseAttorney::is_context_base_initialized(
            *context));

    return context;
  }

  //----------------------------------------------------------------------------
  /** @name                  Input port evaluation
  These methods provide scalar type-independent evaluation of a System input
  port in a particular Context. If necessary, they first cause the port's value
  to become up to date, then they return a reference to the now-up-to-date value
  in the given Context.

  Specified preconditions for these methods operate as follows: The
  preconditions will be checked in Debug builds but some or all might not be
  checked in Release builds for performance reasons. If we do check, and a
  precondition is violated, an std::logic_error will be thrown with a helpful
  message.

  @see System::EvalVectorInput(), System::EvalEigenVectorInput() for
  scalar type-specific input port access. */
  //@{

  /** Returns the value of the input port with the given `port_index` as an
  AbstractValue, which is permitted for ports of any type. Causes the value to
  become up to date first if necessary, delegating to our parent Diagram.
  Returns a pointer to the port's value, or nullptr if the port is not
  connected. If you know the actual type, use one of the more-specific
  signatures.

  @pre `port_index` selects an existing input port of this System.

  @see EvalInputValue(), System::EvalVectorInput(),
       System::EvalEigenVectorInput() */
  const AbstractValue* EvalAbstractInput(const ContextBase& context,
                                         int port_index) const {
    if (port_index < 0)
      ThrowNegativePortIndex(__func__, port_index);
    const InputPortIndex port(port_index);
    return EvalAbstractInputImpl(__func__, context, port);
  }

  /** Returns the value of an abstract-valued input port with the given
  `port_index` as a value of known type `V`. Causes the value to become
  up to date first if necessary. See EvalAbstractInput() for
  more information.

  The result is returned as a pointer to the input port's value of type `V`,
  or nullptr if the port is not connected.

  @pre `port_index` selects an existing input port of this System.
  @pre the port's value must be retrievable from the stored abstract value
       using `AbstractValue::GetValue<V>`.

  @tparam V The type of data expected. */
  template <typename V>
  const V* EvalInputValue(const ContextBase& context, int port_index) const {
    if (port_index < 0)
      ThrowNegativePortIndex(__func__, port_index);
    const InputPortIndex port(port_index);

    const AbstractValue* const abstract_value =
        EvalAbstractInputImpl(__func__, context, port);
    if (abstract_value == nullptr)
      return nullptr;  // An unconnected port.

    // We have a value, is it a V?
    const V* const value = abstract_value->MaybeGetValue<V>();
    if (value == nullptr) {
      ThrowInputPortHasWrongType(__func__, port, NiceTypeName::Get<V>(),
                                 abstract_value->GetNiceTypeName());
    }

    return value;
  }
  //@}

  /** Returns the number of input ports currently allocated in this System.
  These are indexed from 0 to %get_num_input_ports()-1. */
  int get_num_input_ports() const {
    return static_cast<int>(input_ports_.size());
  }

  /** Returns the number of output ports currently allocated in this System.
  These are indexed from 0 to %get_num_output_ports()-1. */
  int get_num_output_ports() const {
    return static_cast<int>(output_ports_.size());
  }

  /** Returns a reference to an InputPort given its `port_index`.
  @pre `port_index` selects an existing input port of this System. */
  const InputPortBase& get_input_port_base(InputPortIndex port_index) const {
    return GetInputPortBaseOrThrow(__func__, port_index);
  }

  /** Returns a reference to an OutputPort given its `port_index`.
  @pre `port_index` selects an existing output port of this System. */
  const OutputPortBase& get_output_port_base(OutputPortIndex port_index) const {
    return GetOutputPortBaseOrThrow(__func__, port_index);
  }

  /** Returns the total dimension of all of the vector-valued input ports (as if
  they were muxed). */
  int get_num_total_inputs() const {
    int count = 0;
    for (const auto& in : input_ports_) count += in->size();
    return count;
  }

  /** Returns the total dimension of all of the vector-valued output ports (as
  if they were muxed). */
  int get_num_total_outputs() const {
    int count = 0;
    for (const auto& out : output_ports_) count += out->size();
    return count;
  }

  /** Returns the number nc of cache entries currently allocated in this System.
  These are indexed from 0 to nc-1. */
  int num_cache_entries() const {
    return static_cast<int>(cache_entries_.size());
  }

  /** Return a reference to a CacheEntry given its `index`. */
  const CacheEntry& get_cache_entry(CacheIndex index) const {
    DRAKE_ASSERT(0 <= index && index < num_cache_entries());
    return *cache_entries_[index];
  }

  // TODO(sherm1) Consider whether to make DeclareCacheEntry methods protected.
  //============================================================================
  /** @name                    Declare cache entries
  @anchor DeclareCacheEntry_documentation

  Methods in this section are used by derived classes to declare cache entries
  for their own internal computations. (Other cache entries are provided
  automatically for well-known computations such as output ports and time
  derivatives.) Cache entries may contain values of any type, however the type
  for any particular cache entry is fixed after first allocation. Every cache
  entry must have an _allocator_ function `Alloc()` and a _calculator_ function
  `Calc()`. `Alloc()` returns an object suitable for holding a value of the
  cache entry. `Calc()` uses the contents of a given Context to produce the
  cache entry's value, which is placed in an object of the type returned by
  `Alloc()`.

  <h4>Prerequisites</h4>

  Correct runtime caching behavior depends critically on understanding the
  dependencies of the cache entry's `Calc()` function (we call those
  "prerequisites"). If none of the prerequisites has changed since the last
  time `Calc()` was invoked to set the cache entry's value, then we don't need
  to perform a potentially expensive recalculation. On the other hand, if any
  of the prerequisites has changed then the current value is invalid and must
  not be used without first recomputing.

  Currently it is not possible for Drake to infer prerequisites accurately and
  automatically from inspection of the `Calc()` implementation. Therefore,
  if you don't say otherwise, Drake will assume `Calc()` is dependent
  on all value sources in the Context, including time, state, input ports,
  parameters, and accuracy. That means the cache entry's value will be
  considered invalid if _any_ of those sources has changed since the last time
  the value was calculated. That is safe, but can result in more computation
  than necessary. If you know that your `Calc()` method has fewer prerequisites,
  you may say so by providing an explicit list in the `prerequisites_of_calc`
  parameter. Every possible prerequisite has a DependencyTicket ("ticket"), and
  the list should consist of tickets. For example, if your calculator depends
  only on time (e.g. `Calc(context)` is `sin(context.get_time())`) then you
  would specify `prerequisites_of_calc={time_ticket()}` here. See
  @ref DependencyTicket_documentation "Dependency tickets" for a list of the
  possible tickets and what they mean.

  @warning It is critical that the prerequisite list you supply be accurate, or
  at least conservative, for correct functioning of the caching system. Drake
  cannot currently detect that a `Calc()` function accesses an undeclared
  prerequisite. Even assuming you have correctly listed the prerequisites, you
  should include a prominent comment in every `Calc()` implementation noting
  that if the implementation is changed then the prerequisite list must be
  updated correspondingly.

  A technique you can use to ensure that prerequisites have been properly
  specified is to make use of the Context's
  @ref drake::systems::ContextBase::DisableCaching "DisableCaching()"
  method, which causes cache values to be recalculated unconditionally. You
  should get identical results with caching enabled or disabled, with speed
  being the only difference.
  @see drake::systems::ContextBase::DisableCaching()

  <h4>Which signature to use?</h4>

  Although the allocator and calculator functions ultimately satisfy generic
  function signatures defined in CacheEntry, we provide a variety
  of `DeclareCacheEntry()` signatures here for convenient specification,
  with mapping to the generic form handled invisibly. In particular,
  allocators are most easily defined by providing a model value that can be
  used to construct an allocator that copies the model when a new value
  object is needed. Alternatively a method can be provided that constructs
  a value object when invoked (those methods are conventionally, but not
  necessarily, named `MakeSomething()` where `Something` is replaced by the
  cache entry value type).

  Because cache entry values are ultimately stored in AbstractValue objects,
  the underlying types must be suitable. That means the type must be copy
  constructible or cloneable. For methods below that are not given an explicit
  model value or construction ("make") method, the underlying type must also be
  default constructible.
  @see drake::systems::Value for more about abstract values. */
  //@{

  /** Declares a new %CacheEntry in this System using the least-restrictive
  definitions for the associated functions. Prefer one of the more-convenient
  signatures below if you can. The new cache entry is assigned a unique
  CacheIndex and DependencyTicket, which can be obtained from the returned
  %CacheEntry. The function signatures here are:
  @code
    std::unique_ptr<AbstractValue> Alloc();
    void Calc(const ContextBase&, AbstractValue*);
  @endcode
  where the AbstractValue objects must resolve to the same concrete type.

  @param[in] description
    A human-readable description of this cache entry, most useful for debugging
    and documentation. Not interpreted in any way by Drake; it is retained
    by the cache entry and used to generate the description for the
    corresponding CacheEntryValue in the Context.
  @param[in] alloc_function
    Given a Context, returns a heap-allocated AbstractValue object suitable for
    holding a value for this cache entry.
  @param[in] calc_function
    Provides the computation that maps from a given Context to the current
    value that this cache entry should have, and writes that value to a given
    object of the type returned by `alloc_function`.
  @param[in] prerequisites_of_calc
    Provides the DependencyTicket list containing a ticket for _every_ Context
    value on which `calc_function` may depend when it computes its result.
    Defaults to `{all_sources_ticket()}` if unspecified. If the cache value
    is truly independent of the Context (rare!) say so explicitly by providing
    the list `{nothing_ticket()}`; an explicitly empty list `{}` is forbidden.
  @returns a const reference to the newly-created %CacheEntry.
  @throws std::logic_error if given an explicitly empty prerequisite list. */
  // Arguments to these methods are moved from internally. Taking them by value
  // rather than reference avoids a copy when the original argument is
  // an rvalue.
  const CacheEntry& DeclareCacheEntry(
      std::string description, CacheEntry::AllocCallback alloc_function,
      CacheEntry::CalcCallback calc_function,
      std::set<DependencyTicket> prerequisites_of_calc = {
          all_sources_ticket()});

  /** Declares a cache entry by specifying member functions to use both for the
  allocator and calculator. The signatures are: @code
    ValueType MySystem::MakeValueType() const;
    void MySystem::CalcCacheValue(const MyContext&, ValueType*) const;
  @endcode
  where `MySystem` is a class derived from `SystemBase`, `MyContext` is a class
  derived from `ContextBase`, and `ValueType` is any concrete type such that
  `Value<ValueType>` is permitted. (The method names are arbitrary.) Template
  arguments will be deduced and do not need to be specified. See the first
  DeclareCacheEntry() signature above for more information about the parameters
  and behavior.
  @see drake::systems::Value */
  template <class MySystem, class MyContext, typename ValueType>
  const CacheEntry& DeclareCacheEntry(
      std::string description,
      ValueType (MySystem::*make)() const,
      void (MySystem::*calc)(const MyContext&, ValueType*) const,
      std::set<DependencyTicket> prerequisites_of_calc = {
          all_sources_ticket()});

  /** Declares a cache entry by specifying a model value of concrete type
  `ValueType` and a calculator function that is a class member function (method)
  with signature: @code
    void MySystem::CalcCacheValue(const MyContext&, ValueType*) const;
  @endcode
  where `MySystem` is a class derived from `SystemBase`, `MyContext` is a class
  derived from `ContextBase`, and `ValueType` is any concrete type such that
  `Value<ValueType>` is permitted. (The method names are arbitrary.) Template
  arguments will be deduced and do not need to be specified.
  See the first DeclareCacheEntry() signature above for more information about
  the parameters and behavior.
  @see drake::systems::Value */
  template <class MySystem, class MyContext, typename ValueType>
  const CacheEntry& DeclareCacheEntry(
      std::string description, const ValueType& model_value,
      void (MySystem::*calc)(const MyContext&, ValueType*) const,
      std::set<DependencyTicket> prerequisites_of_calc = {
          all_sources_ticket()});

  /** Declares a cache entry by specifying only a calculator function that is a
  class member function (method) with signature:
  @code
    void MySystem::CalcCacheValue(const MyContext&, ValueType*) const;
  @endcode
  where `MySystem` is a class derived from `SystemBase` and `MyContext` is a
  class derived from `ContextBase`. `ValueType` is a concrete type such that
  (a) `Value<ValueType>` is permitted, and (b) `ValueType` is default
  constructible. That allows us to create a model value using
  `Value<ValueType>{}` (value initialized so numerical types will be zeroed in
  the model). (The method name is arbitrary.) Template arguments will be
  deduced and do not need to be specified. See the first DeclareCacheEntry()
  signature above for more information about the parameters and behavior.

  @note The default constructor will be called once immediately to create a
  model value, and subsequent allocations will just copy the model value without
  invoking the constructor again. If you want the constructor invoked again at
  each allocation (not common), use one of the other signatures to explicitly
  provide a method for the allocator to call; that method can then invoke
  the `ValueType` default constructor each time it is called.
  @see drake::systems::Value */
  template <class MySystem, class MyContext, typename ValueType>
  const CacheEntry& DeclareCacheEntry(
      std::string description,
      void (MySystem::*calc)(const MyContext&, ValueType*) const,
      std::set<DependencyTicket> prerequisites_of_calc = {
          all_sources_ticket()});
  //@}

  /** Checks whether the given context is valid for this System and throws
  an exception with a helpful message if not. This is *very* expensive and
  should generally be done only in Debug builds, like this:
  @code
     DRAKE_ASSERT_VOID(CheckValidContext(context));
  @endcode */
  void CheckValidContext(const ContextBase& context) const {
    // TODO(sherm1) Add base class checks.

    // Let derived classes have their say.
    DoCheckValidContext(context);
  }

  //============================================================================
  /** @name                     Dependency tickets
  @anchor DependencyTicket_documentation

  Use these tickets to declare well-known sources as prerequisites of a
  downstream computation such as an output port, derivative, update, or cache
  entry. The ticket numbers for these sources are the same for all systems.
  For time and accuracy they refer to the same global resource; otherwise they
  refer to the specified sources within the referencing system.

  A dependency ticket for a more specific resource (a particular input or
  output port, a discrete variable group, abstract state variable, a parameter,
  or a cache entry) is allocated and stored with the resource when it is
  declared. Usually the tickets are obtained directly from the resource but
  you can recover them with methods here knowing only the resource index. */
  //@{

  // The DependencyTrackers associated with these tickets are allocated
  // in ContextBase::CreateBuiltInTrackers() and the implementation there must
  // be kept up to date with the API contracts here.

  /** Returns a ticket indicating dependence on every possible independent
  source value, including time, state, input ports, parameters, and the accuracy
  setting (but not cache entries). This is the default dependency for
  computations that have not specified anything more refined. */
  static DependencyTicket all_sources_ticket() {
    return DependencyTicket(internal::kAllSourcesTicket);
  }

  /** Returns a ticket indicating that a computation does not depend on *any*
  source value; that is, it is a constant. If this appears in a prerequisite
  list, it must be the only entry. */
  static DependencyTicket nothing_ticket() {
    return DependencyTicket(internal::kNothingTicket);
  }

  /** Returns a ticket indicating dependence on time. This is the same ticket
  for all systems and refers to the same time value. */
  static DependencyTicket time_ticket() {
    return DependencyTicket(internal::kTimeTicket);
  }

  /** Returns a ticket indicating dependence on the accuracy setting in the
  Context. This is the same ticket for all systems and refers to the same
  accuracy value. */
  static DependencyTicket accuracy_ticket() {
    return DependencyTicket(internal::kAccuracyTicket);
  }

  /** Returns a ticket indicating that a computation depends on configuration
  state variables q. */
  static DependencyTicket q_ticket() {
    return DependencyTicket(internal::kQTicket);
  }

  /** Returns a ticket indicating dependence on velocity state variables v. This
  does _not_ also indicate a dependence on configuration variables q -- you must
  list that explicitly or use kinematics_ticket() instead. */
  static DependencyTicket v_ticket() {
    return DependencyTicket(internal::kVTicket);
  }

  /** Returns a ticket indicating dependence on all of the miscellaneous
  continuous state variables z. */
  static DependencyTicket z_ticket() {
    return DependencyTicket(internal::kZTicket);
  }

  /** Returns a ticket indicating dependence on all of the continuous
  state variables q, v, or z. */
  static DependencyTicket xc_ticket() {
    return DependencyTicket(internal::kXcTicket);
  }

  /** Returns a ticket indicating dependence on all of the numerical
  discrete state variables, in any discrete variable group. */
  static DependencyTicket xd_ticket() {
    return DependencyTicket(internal::kXdTicket);
  }

  /** Returns a ticket indicating dependence on all of the abstract
  state variables in the current Context. */
  static DependencyTicket xa_ticket() {
    return DependencyTicket(internal::kXaTicket);
  }

  /** Returns a ticket indicating dependence on _all_ state variables x in this
  system, including continuous variables xc, discrete (numeric) variables xd,
  and abstract state variables xa. This does not imply dependence on time,
  parameters, or inputs; those must be specified separately. If you mean to
  express dependence on all possible value sources, use all_sources_ticket()
  instead. */
  static DependencyTicket all_state_ticket() {
    return DependencyTicket(internal::kXTicket);
  }

  /** Returns a ticket for the cache entry that holds time derivatives of
  the continuous variables. */
  static DependencyTicket xcdot_ticket() {
    return DependencyTicket(internal::kXcdotTicket);
  }

  /** Returns a ticket for the cache entry that holds the discrete state
  update for the numerical discrete variables in the state. */
  static DependencyTicket xdhat_ticket() {
    return DependencyTicket(internal::kXdhatTicket);
  }

  /** Returns a ticket indicating dependence on all the configuration
  variables for this System. By default this is set to the continuous
  second-order state variables q, but configuration may be represented
  differently in some systems (discrete ones, for example), in which case this
  ticket should have been set to depend on that representation. This ticket
  also assumes that configuration computations may depend on any parameter and
  on the accuracy setting (which don't change often), but not on time.
  Examples: a parameter that affects length may change the computation of an
  end-effector location. A change in accuracy requirement may require
  recomputation of an iterative approximation of contact forces. */
  // The configuration_tracker implementation in ContextBase must be kept
  // up to date with the above API contract.
  static DependencyTicket configuration_ticket() {
    return DependencyTicket(internal::kConfigurationTicket);
  }

  /** (Advanced) Returns a ticket indicating dependence on all of the velocity
  variables, but _not_ the configuration variables for this System. By default
  this is set to the continuous state variables v, but velocity may be
  represented differently in some systems (discrete ones, for example), in which
  case this ticket should have been set to depend on that representation. This
  ticket also assumes that velocity calculations may depend on any parameter and
  on the accuracy setting (which don't change often), but not on time.
  Examples: a parameter that affects length may change the computation of an
  end-effector velocity. A change in accuracy requirement may require
  recomputation of an iterative approximation of friction forces.

  @warning This _does not_ include dependence on configuration, although
  most velocity calculations do depend on configuration. If you want to
  register dependence on both (more common), use kinematics_ticket(). */
  // The velocity_tracker implementation in ContextBase must be kept
  // up to date with the above API contract.
  static DependencyTicket velocity_ticket() {
    return DependencyTicket(internal::kVelocityTicket);
  }

  /** Returns a ticket indicating dependence on all of the configuration
  and velocity state variables of this System. This ticket depends on the
  configuration_ticket and the velocity_ticket. Note that this includes
  dependence on all parameters and the accuracy setting, but not on time.
  @see configuration_ticket(), velocity_ticket() */
  static DependencyTicket kinematics_ticket() {
    return DependencyTicket(internal::kKinematicsTicket);
  }

  /** Returns a ticket indicating dependence on _all_ parameters p in this
  system, including numeric parameters pn, and abstract parameters pa. */
  static DependencyTicket all_parameters_ticket() {
    return DependencyTicket(internal::kAllParametersTicket);
  }

  /** Returns a ticket indicating dependence on _all_ input ports u of this
  system. */
  static DependencyTicket all_input_ports_ticket() {
    return DependencyTicket(internal::kAllInputPortsTicket);
  }

  /** Returns a ticket indicating dependence on the input port indicated
  by `index`.
  @pre `index` selects an existing input port of this System. */
  DependencyTicket input_port_ticket(InputPortIndex index) {
    DRAKE_DEMAND(0 <= index && index < get_num_input_ports());
    return input_ports_[index]->ticket();
  }

  /** Returns a ticket indicating dependence on the output port indicated
  by `index`.
  @pre `index` selects an existing output port of this System. */
  DependencyTicket output_port_ticket(OutputPortIndex index) {
    DRAKE_DEMAND(0 <= index && index < get_num_output_ports());
    return output_ports_[index]->ticket();
  }

  /** Returns a ticket indicating dependence on the cache entry indicated
  by `index`.
  @pre `index` selects an existing cache entry in this System. */
  DependencyTicket cache_entry_ticket(CacheIndex index) {
    DRAKE_DEMAND(0 <= index && index < num_cache_entries());
    return cache_entries_[index]->ticket();
  }

  /** Returns the number of declared discrete state groups (each group is
  a vector-valued discrete state variable). */
  int num_discrete_state_groups() const {
    return static_cast<int>(discrete_state_tickets_.size());
  }

  /** Returns the number of declared abstract state variables. */
  int num_abstract_states() const {
    return static_cast<int>(abstract_state_tickets_.size());
  }

  /** Returns the number of declared numeric parameters (each of these is
  a vector-valued parameter). */
  int num_numeric_parameters() const {
    return static_cast<int>(numeric_parameter_tickets_.size());
  }

  /** Returns the number of declared abstract parameters. */
  int num_abstract_parameters() const {
    return static_cast<int>(abstract_parameter_tickets_.size());
  }

  /** Returns a ticket indicating dependence on a particular discrete state
  variable (may be a vector). (We sometimes refer to this as a "discrete
  variable group".) */
  DependencyTicket discrete_state_ticket(DiscreteStateIndex index) const {
    return discrete_state_tracker_info(index).ticket;
  }

  /** Returns a ticket indicating dependence on a particular abstract state
  variable. */
  DependencyTicket abstract_state_ticket(AbstractStateIndex index) const {
    return abstract_state_tracker_info(index).ticket;
  }

  /** Returns a ticket indicating dependence on a particular numeric parameter
  (may be a vector). */
  DependencyTicket numeric_parameter_ticket(NumericParameterIndex index) const {
    return numeric_parameter_tracker_info(index).ticket;
  }

  /** Returns a ticket indicating dependence on a particular abstract
  parameter. */
  DependencyTicket abstract_parameter_ticket(
      AbstractParameterIndex index) const {
    return abstract_parameter_tracker_info(index).ticket;
  }
  //@}

 protected:
  /** (Internal use only) Default constructor. */
  SystemBase() = default;

  /** (Internal use only) Adds an already-constructed input port to this System.
  Insists that the port already contains a reference to this System, and that
  the port's index is already set to the next available input port index for
  this System. */
  // TODO(sherm1) Add check on suitability of `size` parameter for the port's
  // data type.
  void AddInputPort(std::unique_ptr<InputPortBase> port) {
    DRAKE_DEMAND(port != nullptr);
    DRAKE_DEMAND(&port->get_system_base() == this);
    DRAKE_DEMAND(port->get_index() == this->get_num_input_ports());
    input_ports_.push_back(std::move(port));
  }

  /** (Internal use only) Adds an already-constructed output port to this
  System. Insists that the port already contains a reference to this System, and
  that the port's index is already set to the next available output port index
  for this System. */
  // TODO(sherm1) Add check on suitability of `size` parameter for the port's
  // data type.
  void AddOutputPort(std::unique_ptr<OutputPortBase> port) {
    DRAKE_DEMAND(port != nullptr);
    DRAKE_DEMAND(&port->get_system_base() == this);
    DRAKE_DEMAND(port->get_index() == this->get_num_output_ports());
    output_ports_.push_back(std::move(port));
  }

  /** (Internal use only) Assigns a ticket to a new discrete variable group
  with the given `index`.
  @pre The supplied index must be the next available one; that is, indexes
       must be assigned sequentially. */
  void AddDiscreteStateGroup(DiscreteStateIndex index) {
    DRAKE_DEMAND(index == num_discrete_state_groups());
    const DependencyTicket ticket(assign_next_dependency_ticket());
    discrete_state_tickets_.push_back(
        {ticket, "discrete state group " + std::to_string(index)});
  }

  /** (Internal use only) Assigns a ticket to a new abstract state variable with
  the given `index`.
  @pre The supplied index must be the next available one; that is, indexes
       must be assigned sequentially. */
  void AddAbstractState(AbstractStateIndex index) {
    const DependencyTicket ticket(assign_next_dependency_ticket());
    DRAKE_DEMAND(index == num_abstract_states());
    abstract_state_tickets_.push_back(
        {ticket, "abstract state " + std::to_string(index)});
  }

  /** (Internal use only) Assigns a ticket to a new numeric parameter with
  the given `index`.
  @pre The supplied index must be the next available one; that is, indexes
       must be assigned sequentially. */
  void AddNumericParameter(NumericParameterIndex index) {
    DRAKE_DEMAND(index == num_numeric_parameters());
    const DependencyTicket ticket(assign_next_dependency_ticket());
    numeric_parameter_tickets_.push_back(
        {ticket, "numeric parameter " + std::to_string(index)});
  }

  /** (Internal use only) Assigns a ticket to a new abstract parameter with
  the given `index`.
  @pre The supplied index must be the next available one; that is, indexes
       must be assigned sequentially. */
  void AddAbstractParameter(AbstractParameterIndex index) {
    const DependencyTicket ticket(assign_next_dependency_ticket());
    DRAKE_DEMAND(index == num_abstract_parameters());
    abstract_parameter_tickets_.push_back(
        {ticket, "abstract parameter " + std::to_string(index)});
  }

  /** (Internal use only) This is for cache entries associated with pre-defined
  tickets, for example the cache entry for time derivatives. See the public API
  for the most-general DeclareCacheEntry() signature for the meanings of the
  other parameters here. */
  const CacheEntry& DeclareCacheEntryWithKnownTicket(
      DependencyTicket known_ticket,
      std::string description, CacheEntry::AllocCallback alloc_function,
      CacheEntry::CalcCallback calc_function,
      std::set<DependencyTicket> prerequisites_of_calc = {
          all_sources_ticket()});

  /** Returns a pointer to the service interface of the immediately enclosing
  Diagram if one has been set, otherwise nullptr. */
  const internal::SystemParentServiceInterface* get_parent_service() const {
    return parent_service_;
  }

  /** (Internal use only) Assigns the next unused dependency ticket number,
  unique only within a particular system. Each call to this method increments
  the ticket number. */
  DependencyTicket assign_next_dependency_ticket() {
    return next_available_ticket_++;
  }

  /** (Internal use only) Declares that `parent_service` is the service
  interface of the Diagram that owns this subsystem. Aborts if the parent
  service has already been set to something else. */
  // Use static method so Diagram can invoke this on behalf of a child.
  // Output argument is listed first because it is serving as the 'this'
  // pointer here.
  static void set_parent_service(
      SystemBase* child,
      const internal::SystemParentServiceInterface* parent_service) {
    DRAKE_DEMAND(child != nullptr && parent_service != nullptr);
    DRAKE_DEMAND(child->parent_service_ == nullptr ||
                 child->parent_service_ == parent_service);
    child->parent_service_ = parent_service;
  }

  /** (Internal use only) Shared code for updating an input port and returning a
  pointer to its abstract value, or nullptr if the port is not connected. `func`
  should be the user-visible API function name obtained with __func__. */
  const AbstractValue* EvalAbstractInputImpl(const char* func,
                                             const ContextBase& context,
                                             InputPortIndex port_index) const;

  /** Throws std::out_of_range to report a negative `port_index` that was
  passed to API method `func`. Caller must ensure that the function name
  makes it clear what kind of port we're complaining about. */
  // We're taking an int here for the index; InputPortIndex and OutputPortIndex
  // can't be negative.
  [[noreturn]] void ThrowNegativePortIndex(const char* func,
                                           int port_index) const;

  /** Throws std::out_of_range to report bad input `port_index` that was passed
  to API method `func`. */
  [[noreturn]] void ThrowInputPortIndexOutOfRange(
      const char* func, InputPortIndex port_index) const;

  /** Throws std::out_of_range to report bad output `port_index` that was passed
  to API method `func`. */
  [[noreturn]] void ThrowOutputPortIndexOutOfRange(
      const char* func, OutputPortIndex port_index) const;

  /** Throws std::logic_error because someone misused API method `func`, that is
  only allowed for declared-vector input ports, on an abstract port whose
  index is given here. */
  [[noreturn]] void ThrowNotAVectorInputPort(const char* func,
                                             InputPortIndex port_index) const;

  /** Throws std::logic_error because someone called API method `func` claiming
  the input port had some value type that was wrong. */
  [[noreturn]] void ThrowInputPortHasWrongType(
      const char* func, InputPortIndex port_index,
      const std::string& expected_type, const std::string& actual_type) const;

  /** Throws std::logic_error because someone called API method `func`, that
  requires this input port to be evaluatable, but the port was neither
  fixed nor connected. */
  [[noreturn]] void ThrowCantEvaluateInputPort(const char* func,
                                               InputPortIndex port_index) const;

  /** (Internal use only) Returns the InputPortBase at index `port_index`,
  throwing std::out_of_range we don't like the port index. The name of the
  public API method that received the bad index is provided in `func` and is
  included in the error message. */
  const InputPortBase& GetInputPortBaseOrThrow(const char* func,
                                               int port_index) const {
    if (port_index < 0)
      ThrowNegativePortIndex(func, port_index);
    const InputPortIndex port(port_index);
    if (port_index >= get_num_input_ports())
      ThrowInputPortIndexOutOfRange(func, port);
    return *input_ports_[port];
  }

  /** (Internal use only) Returns the OutputPortBase at index `port_index`,
  throwing std::out_of_range we don't like the port index. The name of the
  public API method that received the bad index is provided in `func` and is
  included in the error message. */
  const OutputPortBase& GetOutputPortBaseOrThrow(const char* func,
                                                 int port_index) const {
    if (port_index < 0)
      ThrowNegativePortIndex(func, port_index);
    const OutputPortIndex port(port_index);
    if (port_index >= get_num_output_ports())
      ThrowOutputPortIndexOutOfRange(func, port);
    return *output_ports_[port_index];
  }

  /** This method must be invoked from within derived class DoAllocateContext()
  implementations right after the concrete Context object has been allocated.
  It allocates cache entries, sets up all intra-Context dependencies, and marks
  the ContextBase as initialized so that we can verify proper derived-class
  behavior.
  @pre The supplied context must not be null and must not already have been
       initialized. */
  void InitializeContextBase(ContextBase* context) const;

  /** Derived class implementations should allocate a suitable concrete Context
  type, then invoke the above InitializeContextBase() method. A Diagram must
  then invoke AllocateContext() to obtain each of the subcontexts for its
  DiagramContext, and must set up inter-subcontext dependencies among its
  children and between itself and its children. Then context resources such as
  parameters and state should be allocated. */
  virtual std::unique_ptr<ContextBase> DoAllocateContext() const = 0;

  /** Derived classes must implement this to verify that the supplied
  Context is suitable, and throw an exception if not. This is a runtime check
  but may be expensive so is not guaranteed to be invoked except in Debug
  builds. */
  virtual void DoCheckValidContext(const ContextBase&) const = 0;

 private:
  void CreateSourceTrackers(ContextBase*) const;

  // Used to create trackers for variable-number System-allocated objects.
  struct TrackerInfo {
    DependencyTicket ticket;
    std::string description;
  };

  const TrackerInfo& discrete_state_tracker_info(
      DiscreteStateIndex index) const {
    DRAKE_DEMAND(0 <= index && index < num_discrete_state_groups());
    return discrete_state_tickets_[index];
  }

  const TrackerInfo& abstract_state_tracker_info(
      AbstractStateIndex index) const {
    DRAKE_DEMAND(0 <= index && index < num_abstract_states());
    return abstract_state_tickets_[index];
  }

  const TrackerInfo& numeric_parameter_tracker_info(
      NumericParameterIndex index) const {
    DRAKE_DEMAND(0 <= index && index < num_numeric_parameters());
    return numeric_parameter_tickets_[index];
  }

  const TrackerInfo& abstract_parameter_tracker_info(
      AbstractParameterIndex index) const {
    DRAKE_DEMAND(0 <= index && index < num_abstract_parameters());
    return abstract_parameter_tickets_[index];
  }

  // Ports and cache entries hold their own DependencyTickets. Note that the
  // addresses of the elements are stable even if the std::vectors are resized.

  // Indexed by InputPortIndex.
  std::vector<std::unique_ptr<InputPortBase>> input_ports_;
  // Indexed by OutputPortIndex.
  std::vector<std::unique_ptr<OutputPortBase>> output_ports_;
  // Indexed by CacheIndex.
  std::vector<std::unique_ptr<CacheEntry>> cache_entries_;

  // States and parameters don't hold their own tickets so we track them here.

  // Indexed by DiscreteStateIndex.
  std::vector<TrackerInfo> discrete_state_tickets_;
  // Indexed by AbstractStateIndex.
  std::vector<TrackerInfo> abstract_state_tickets_;
  // Indexed by NumericParameterIndex.
  std::vector<TrackerInfo> numeric_parameter_tickets_;
  // Indexed by AbstractParameterIndex.
  std::vector<TrackerInfo> abstract_parameter_tickets_;

  // Initialize to the first ticket number available after all the well-known
  // ones. This gets incremented as tickets are handed out for the optional
  // entities above.
  DependencyTicket next_available_ticket_{internal::kNextAvailableTicket};

  // The enclosing Diagram. Null/invalid when this is the root system.
  const internal::SystemParentServiceInterface* parent_service_{nullptr};

  // Name of this system.
  std::string name_;
};

// Implementations of templatized DeclareCacheEntry() methods.

// Takes make() and calc() member functions.
template <class MySystem, class MyContext, typename ValueType>
const CacheEntry& SystemBase::DeclareCacheEntry(
    std::string description,
    ValueType (MySystem::*make)() const,
    void (MySystem::*calc)(const MyContext&, ValueType*) const,
    std::set<DependencyTicket> prerequisites_of_calc) {
  static_assert(std::is_base_of<SystemBase, MySystem>::value,
                "Expected to be invoked from a SystemBase-derived System.");
  static_assert(std::is_base_of<ContextBase, MyContext>::value,
                "Expected to be invoked with a ContextBase-derived Context.");
  auto this_ptr = dynamic_cast<const MySystem*>(this);
  DRAKE_DEMAND(this_ptr != nullptr);
  auto alloc_callback = [this_ptr, make]() {
    return AbstractValue::Make((this_ptr->*make)());
  };
  auto calc_callback = [this_ptr, calc](const ContextBase& context,
                                        AbstractValue* result) {
    const auto& typed_context = dynamic_cast<const MyContext&>(context);
    ValueType& typed_result = result->GetMutableValue<ValueType>();
    (this_ptr->*calc)(typed_context, &typed_result);
  };
  // Invoke the general signature above.
  auto& entry = DeclareCacheEntry(
      std::move(description), std::move(alloc_callback),
      std::move(calc_callback), std::move(prerequisites_of_calc));
  return entry;
}

// Takes an initial value and calc() member function.
template <class MySystem, class MyContext, typename ValueType>
const CacheEntry& SystemBase::DeclareCacheEntry(
    std::string description, const ValueType& model_value,
    void (MySystem::*calc)(const MyContext&, ValueType*) const,
    std::set<DependencyTicket> prerequisites_of_calc) {
  static_assert(std::is_base_of<SystemBase, MySystem>::value,
                "Expected to be invoked from a SystemBase-derived System.");
  static_assert(std::is_base_of<ContextBase, MyContext>::value,
                "Expected to be invoked with a ContextBase-derived Context.");
  auto this_ptr = dynamic_cast<const MySystem*>(this);
  DRAKE_DEMAND(this_ptr != nullptr);
  // The given model value may have *either* a copy constructor or a Clone()
  // method, since it just has to be suitable for containing in an
  // AbstractValue. We need to create a functor that is copy constructible,
  // so need to wrap the model value to give it a copy constructor. Drake's
  // copyable_unique_ptr does just that, so is suitable for capture by the
  // allocator functor here.
  copyable_unique_ptr<AbstractValue> owned_model(
      std::make_unique<Value<ValueType>>(model_value));
  auto alloc_callback = [model = std::move(owned_model)]() {
    return model->Clone();
  };
  auto calc_callback = [this_ptr, calc](const ContextBase& context,
                                        AbstractValue* result) {
    const auto& typed_context = dynamic_cast<const MyContext&>(context);
    ValueType& typed_result = result->GetMutableValue<ValueType>();
    (this_ptr->*calc)(typed_context, &typed_result);
  };
  auto& entry = DeclareCacheEntry(
      std::move(description), std::move(alloc_callback),
      std::move(calc_callback), std::move(prerequisites_of_calc));
  return entry;
}

// Takes just a calc() member function, value-initializes entry.
template <class MySystem, class MyContext, typename ValueType>
const CacheEntry& SystemBase::DeclareCacheEntry(
    std::string description,
    void (MySystem::*calc)(const MyContext&, ValueType*) const,
    std::set<DependencyTicket> prerequisites_of_calc) {
  static_assert(std::is_base_of<SystemBase, MySystem>::value,
                "Expected to be invoked from a SystemBase-derived System.");
  static_assert(std::is_base_of<ContextBase, MyContext>::value,
                "Expected to be invoked with a ContextBase-derived Context.");
  static_assert(
      std::is_default_constructible<ValueType>::value,
      "SystemBase::DeclareCacheEntry(calc): the calc-only overload of "
      "this method requires that the output type has a default constructor");
  // Invokes the above model-value method. Note that value initialization {}
  // is required here.
  return DeclareCacheEntry(std::move(description), ValueType{}, calc,
                           std::move(prerequisites_of_calc));
}

}  // namespace systems
}  // namespace drake
