#!/bin/bash

# Generated by CMake @CMAKE_VERSION@ for @PROJECT_NAME@. Any changes to this
# file will be overwritten by the next CMake run. The input file was
# tools/cc_toolchain/wrapper.sh.in.

set -euo pipefail

# Real compiler path. Configured by CMake
_COMPILER=@COMPILER@
# If bazel is configuring the project and trying to get the list of system
# include directories, we also compute the real path (canonical path) of the
# include directories that are symlinks. We keep both original and canonical
# paths just in case. The flags used in this step are visible in bazel source
# code [1].
# [1] https://github.com/bazelbuild/bazel/blob/ceaed51/tools/cpp/unix_cc_configure.bzl#L149-L168
if [[ "$*" ==  *"-E"* ]] &&
    [[ "$*" == *"-xc++"* ]] &&
    [[ "$*" == *"-"* ]] &&
    [[ "$*" == *"-v"* ]]
then
    $_COMPILER "$@" 2>&1 >/dev/null | while IFS= read line ; do
    # Prints include directory in stderr, and if it is a symlink, gets the link
    # path and print it to stderr too. Since this is only run on Linux, we can
    # use `readlink -f`.
    line_escape=$(echo "$line" |sed "s/'/\\\\'/g")
    echo "$line" >&2
    line_trim=$(echo $line | sed -e 's/^[[:space:]]*//')
    # Only run `readlink` on include directories.
    if [[  "$line_trim" == /usr/* ]] ; then
       line_link=$(readlink -f "$line_trim")
       # If it is actually a link, then print the real path.
       if [[ $line_trim != $line_link ]]; then
         # Escape slashes to be able to use the string in `sed`
         line_link=$(echo $line_link | sed -e 's/\//\\\//g')
         # Adds the same number of space at the beginning of the line
         # as there was in the original string.
         echo "$line" | sed -e "s/\/usr.*/$line_link/" >&2
       fi
     fi
   done
else
# Otherwise, just run the compiler normally.
  $_COMPILER "$@"
fi
