Fix UBSan complaints in HTTP header parsing

Remove the 8-byte stride optimizations, instead relying on the
underlying 1-byte loops to get the job done.

See https://github.com/uNetworking/uWebSockets/issues/1512.

--- src/HttpParser.h.orig
+++ src/HttpParser.h
@@ -234,15 +234,15 @@
     }
     
     static inline void *consumeFieldName(char *p) {
-        for (; true; p += 8) {
-            if (notFieldNameWord(*(uint64_t *)p)) {
+
+
                 while (isFieldNameByte(*(unsigned char *)p)) {
                     *(p++) |= 0x20;
                 }
                 return (void *)p;
-            }
-            (*(uint64_t *)p) |= 0x2020202020202020ull;
-        }
+
+
+
     }
 
     /* Puts method as key, target as value and returns non-null (or nullptr on error). */
@@ -256,8 +256,8 @@
             data++;
             /* Scan for less than 33 (catches post padded CR and fails) */
             start = data;
-            for (; true; data += 8) {
-                if (hasLess(*(uint64_t *)data, 33)) {
+
+
                     while (*(unsigned char *)data > 32) data++;
                     /* Now we stand on space */
                     header.value = {start, (size_t) (data - start)};
@@ -266,8 +264,8 @@
                         return data + 11;
                     }
                     return nullptr;
-                }
-            }
+
+
         }
         return nullptr;
     }
@@ -277,12 +277,12 @@
      * Field values containing CR, LF, or NUL characters are invalid and dangerous [...]
      * Field values containing other CTL characters are also invalid. */
     static inline void *tryConsumeFieldValue(char *p) {
-        for (; true; p += 8) {
-            if (hasLess(*(uint64_t *)p, 32)) {
+
+
                 while (*(unsigned char *)p > 31) p++;
                 return (void *)p;
-            }
-        }
+
+
     }
 
     /* End is only used for the proxy parser. The HTTP parser recognizes "\ra" as invalid "\r\n" scan and breaks. */
