Reinstantiates Drake-specific cpplint function regarding transitive includes.

Drake permits transitive includes for stl headers, meaning that so long as
header <bar> is included in foo.h, and foo.cc includes foo.h, foo.cc need not
include <bar> directly. This convention is explicitly prohibited by the
upstream target of cpplint, so for now we will reapply logic from the legacy
target which enabled this behavior.

This will, in some cases, prevent .cc files from being linted as thoroughly
as .h files. As it turns out, the legacy logic simply returned prematurely in
the case that a header file could not be found for a given source file. While
this logic is certainly questionable, this was indeed the behavior for all
Drake cpplint tests prior to targeting the upstream. Thus, reinstating this
behavior allows us to move away from Drake's legacy target without any loss in
existing functionality.

TODO: implement a more comprehensive linting strategy for transitive
includes.

Reason for not upstreaming this patch: compliance with Drake-specific
convention which technically goes against upstream cpplint.

--- cpplint.py
+++ cpplint.py
@@ -6870,6 +6872,33 @@ def FilesBelongToSameModule(filename_cc, filename_h):
     return files_belong_to_same_module, common_path


+def UpdateIncludeState(filename, include_dict, io=codecs):
+  """Fill up the include_dict with new includes found from the file.
+
+  Args:
+    filename: the name of the header to read.
+    include_dict: a dictionary in which the headers are inserted.
+    io: The io factory to use to read the file. Provided for testability.
+
+  Returns:
+    True if a header was successfully added. False otherwise.
+  """
+  headerfile = None
+  try:
+    headerfile = io.open(filename, 'r', 'utf8', 'replace')
+  except IOError:
+    return False
+  linenum = 0
+  for line in headerfile:
+    linenum += 1
+    clean_line = CleanseComments(line)
+    match = _RE_PATTERN_INCLUDE.search(clean_line)
+    if match:
+      include = match.group(2)
+      include_dict.setdefault(include, linenum)
+  return True
+
+
 def CheckForIncludeWhatYouUse(filename, clean_lines, include_state, error, io=codecs):
     """Reports for missing stl includes.

@@ -6927,6 +6956,38 @@ def CheckForIncludeWhatYouUse(filename, clean_lines, include_state, error, io=co
     # Let's flatten the include_state include_list and copy it into a dictionary.
     include_dict = dict([item for sublist in include_state.include_list for item in sublist])

+    # Did we find the header for this file (if any) and successfully load it?
+    header_found = False
+
+    # Use the absolute path so that matching works properly.
+    abs_filename = FileInfo(filename).FullName()
+
+    # For Emacs's flymake.
+    # If cpplint is invoked from Emacs's flymake, a temporary file is generated
+    # by flymake and that file name might end with '_flymake.cc'. In that case,
+    # restore original file name here so that the corresponding header file can be
+    # found.
+    # e.g. If the file name is 'foo_flymake.cc', we should search for 'foo.h'
+    # instead of 'foo_flymake.h'
+    abs_filename = re.sub(r'_flymake\.cc$', '.cc', abs_filename)
+
+    # include_dict is modified during iteration, so we iterate over a copy of
+    # the keys.
+    header_keys = list(include_dict.keys())
+    for header in header_keys:
+        (same_module, common_path) = FilesBelongToSameModule(abs_filename, header)
+        fullpath = common_path + header
+        if same_module and UpdateIncludeState(fullpath, include_dict, io):
+            header_found = True
+
+    # If we can't find the header file for a .cc, assume it's because we don't
+    # know where to look. In that case we'll give up as we're not sure they
+    # didn't include it in the .h file.
+    # TODO(unknown): Do a better job of finding .h files so we are confident that
+    # not having the .h file means there isn't one.
+    if filename.endswith('.cc') and not header_found:
+        return
+
     # All the lines have been processed, report the errors found.
     for header in sorted(required, key=required.__getitem__):
         template = required[header][1]
