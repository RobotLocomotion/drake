"""
Upgrades the lockfile for OpenUSD.
"""

import argparse
import collections
from pathlib import Path
import subprocess
import tempfile

from python import runfiles

# This is the full list of OpenUSD libraries that Drake cares about.
SUBDIRS = [
    "pxr/base/arch",
    "pxr/base/gf",
    "pxr/base/js",
    "pxr/base/pegtl",
    "pxr/base/plug",
    "pxr/base/tf",
    "pxr/base/trace",
    "pxr/base/vt",
    "pxr/base/work",
    "pxr/usd/ar",
    "pxr/usd/kind",
    "pxr/usd/ndr",
    "pxr/usd/pcp",
    "pxr/usd/sdf",
    "pxr/usd/sdr",
    "pxr/usd/usd",
    "pxr/usd/usdGeom",
    "pxr/usd/usdPhysics",
    "pxr/usd/usdShade",
    "pxr/usd/usdUtils",
]

# This code block is adapted from OpenUSD/cmake/macros/Public.cmake. The
# argument parsing for pxr_library() must match that file. The remaining
# functions are just no-op stubs as required by the CMakeLists.txt files found
# in the subdirs listed above.
CMAKE_CODE_STUB = """
function(pxr_library NAME)
    set(options
        DISABLE_PRECOMPILED_HEADERS
    )
    set(oneValueArgs
        TYPE
        PRECOMPILED_HEADER_NAME
    )
    set(multiValueArgs
        PUBLIC_CLASSES
        PUBLIC_HEADERS
        PRIVATE_CLASSES
        PRIVATE_HEADERS
        CPPFILES
        LIBRARIES
        INCLUDE_DIRS
        DOXYGEN_FILES
        RESOURCE_FILES
        PYTHON_PUBLIC_CLASSES
        PYTHON_PRIVATE_CLASSES
        PYTHON_PUBLIC_HEADERS
        PYTHON_PRIVATE_HEADERS
        PYTHON_CPPFILES
        PYMODULE_CPPFILES
        PYMODULE_FILES
        PYSIDE_UI_FILES
    )

    cmake_parse_arguments(args
        "${options}"
        "${oneValueArgs}"
        "${multiValueArgs}"
        ${ARGN}
      )

      # This order of keys matches the traditional order of the Drake
      # lock file.
      message("NAME = ${NAME}")
      message("LIBRARIES = ${args_LIBRARIES}")
      message("PUBLIC_CLASSES = ${args_PUBLIC_CLASSES}")
      message("PUBLIC_HEADERS = ${args_PUBLIC_HEADERS}")
      message("PRIVATE_CLASSES = ${args_PRIVATE_CLASSES}")
      message("PRIVATE_HEADERS = ${args_PRIVATE_HEADERS}")
      message("CPPFILES = ${args_CPPFILES}")
endfunction()

function(pxr_build_test)
endfunction()

function(pxr_test_scripts)
endfunction()

function(pxr_install_test_dir)
endfunction()

function(pxr_register_test)
endfunction()

function(pxr_build_test_shared_lib)
endfunction()

function(pxr_create_test_module)
endfunction()

"""


def _interpret(cmake: str):
    """Use the cmake interpreter to extract the arguments of the
    pxr_library() call in the given cmake source code string."""
    script = CMAKE_CODE_STUB + cmake
    with tempfile.NamedTemporaryFile() as tmpf:
        tmpf.write(script.encode("utf8"))
        tmpf.flush()
        cmd = ["cmake", "-P", tmpf.name]
        output = subprocess.check_output(
            cmd, stderr=subprocess.STDOUT).decode("utf8")

    result = collections.OrderedDict()
    for line in output.splitlines():
        if " = " not in line:
            continue
        kv = line.split(" = ")
        if len(kv) == 1:
            k, v = kv, ''
        else:
            k, v = kv
        if k == "NAME":
            result[k] = v
        else:
            vlist = [e for e in v.split(";") if e]
            result[k] = vlist
    return result


def _extract(subdir: str) -> dict[str, str | list[str]]:
    """Extracts the pxr_library() call from the given subdir's CMakeLists.txt
    and returns its arguments as more Pythonic data structure. (Refer to the
    `result` dict sanity checking inline below, for details.)
    """
    # Slurp the file
    manifest = runfiles.Create()
    found = manifest.Rlocation(f"openusd_internal/{subdir}/CMakeLists.txt")
    cmake = Path(found).read_text(encoding="utf-8")
    result = _interpret(cmake)

    # Result dict must contain these keys.
    assert set(result.keys()) == {"NAME", "PUBLIC_CLASSES", "PUBLIC_HEADERS",
                                  "PRIVATE_CLASSES", "PRIVATE_HEADERS",
                                  "CPPFILES", "LIBRARIES"}
    # NAME has a string-type value, all the rest are lists.
    for key in result.keys():
        if key == "NAME":
            required_type = str
        else:
            required_type = list
        assert isinstance(result[key], required_type)
    return result


def _generate() -> str:
    """Returns the expected contents of the lockfile (lock/files.bzl)."""
    lines = [
        "# This file is automatically generated by upgrade.py.",
    ]
    lines.append("FILES = {")
    for subdir in SUBDIRS:
        lines.append(f'    "{subdir}": {{')
        extracted = _extract(subdir)
        for name, value in extracted.items():
            if isinstance(value, str):
                lines.append(f'        "{name}": "{value}",')
                continue
            assert isinstance(value, list)
            if len(value) == 0:
                lines.append(f'        "{name}": [],')
                continue
            lines.append(f'        "{name}": [')
            for item in value:
                lines.append(f'            "{item}",')
            lines.append(f'        ],')
        lines.append(f'    }},')
    lines.append("}")
    return "\n".join(lines) + "\n"


def main():
    parser = argparse.ArgumentParser(
        prog="upgrade", description=__doc__)
    parser.add_argument(
        "--relock", action="store_true",
        help="Overwrite the lockfile in the source tree.")
    parser.add_argument(
        "--output", type=Path,
        help="Write the lockfile to the given path.")
    args = parser.parse_args()
    assert args.relock ^ (args.output is not None)
    if args.relock:
        output = Path(__file__).resolve().parent / "lock/files.bzl"
    else:
        output = args.output
    content = _generate()
    output.write_text(content, encoding="utf-8")


assert __name__ == "__main__"
main()
