[openusd_internal] Switch TBB to oneAPI

This is copied from the upstream pull request:
 https://github.com/PixarAnimationStudios/OpenUSD/pull/2825

Many thanks to wangcan <wangcan.199@bytedance.com> for contributing it!


diff --git cmake/defaults/Packages.cmake cmake/defaults/Packages.cmake
index 7ae4b287f..d0d3a4546 100644
--- cmake/defaults/Packages.cmake
+++ cmake/defaults/Packages.cmake
@@ -152,8 +152,18 @@ endif()
 
 
 # --TBB
-find_package(TBB REQUIRED COMPONENTS tbb)
+option(OneTBB_CMAKE_ENABLE "Disable cmake build for oneTbb defaultly" OFF)
+if(WIN32)
+    find_package(TBB REQUIRED COMPONENTS tbb12)
+else()
+    find_package(TBB REQUIRED COMPONENTS tbb)
+endif()
+
 add_definitions(${TBB_DEFINITIONS})
+if(OneTBB_CMAKE_ENABLE)
+    add_definitions(-DPXR_ONETBB_SUPPORT_ENABLED)
+endif()
+message("OpenUSD find tbb libraries ${TBB_LIBRARIES}")
 
 # --math
 if(WIN32)
diff --git cmake/modules/FindTBB.cmake cmake/modules/FindTBB.cmake
index 9bf69a022..7b70cdc5a 100644
--- cmake/modules/FindTBB.cmake
+++ cmake/modules/FindTBB.cmake
@@ -72,7 +72,7 @@
 # * TBB_VERSION_MAJOR     - The major version
 # * TBB_VERSION_MINOR     - The minor version
 # * TBB_INTERFACE_VERSION - The interface version number defined in 
-#                           tbb/tbb_stddef.h.
+#                           tbb/tbb_stddef.h or oneapi/tbb/version.h when OneTBB_CMAKE_ENABLE enabled.
 # * TBB_<library>_LIBRARY_RELEASE - The path of the TBB release version of 
 #                           <library>, where <library> may be tbb, tbb_debug,
 #                           tbbmalloc, tbbmalloc_debug, tbb_preview, or 
@@ -197,7 +197,12 @@ if(NOT TBB_FOUND)
   ##################################
 
   if(TBB_INCLUDE_DIRS)
-    file(READ "${TBB_INCLUDE_DIRS}/tbb/tbb_stddef.h" _tbb_version_file)
+    if(OneTBB_CMAKE_ENABLE)
+        file(READ "${TBB_INCLUDE_DIRS}/oneapi/tbb/version.h" _tbb_version_file)
+    else()
+        file(READ "${TBB_INCLUDE_DIRS}/tbb/tbb_stddef.h" _tbb_version_file)
+    endif()
+    
     string(REGEX REPLACE ".*#define TBB_VERSION_MAJOR ([0-9]+).*" "\\1"
         TBB_VERSION_MAJOR "${_tbb_version_file}")
     string(REGEX REPLACE ".*#define TBB_VERSION_MINOR ([0-9]+).*" "\\1"
@@ -210,16 +215,20 @@ if(NOT TBB_FOUND)
   ##################################
   # Find TBB components
   ##################################
+  set(TBB_TARGET_COMPONENT tbb)
+  if(CMAKE_SYSTEM_NAME STREQUAL "Windows")
+    set(TBB_TARGET_COMPONENT tbb12)
+  endif()
 
   if(TBB_VERSION VERSION_LESS 4.3)
-    set(TBB_SEARCH_COMPOMPONENTS tbb_preview tbbmalloc tbb)
+    set(TBB_SEARCH_COMPOMPONENTS tbb_preview tbbmalloc ${TBB_TARGET_COMPONENT})
   else()
-    set(TBB_SEARCH_COMPOMPONENTS tbb_preview tbbmalloc_proxy tbbmalloc tbb)
+    set(TBB_SEARCH_COMPOMPONENTS tbb_preview tbbmalloc_proxy tbbmalloc ${TBB_TARGET_COMPONENT})
   endif()
 
   # Find each component
   foreach(_comp ${TBB_SEARCH_COMPOMPONENTS})
-    if(";${TBB_FIND_COMPONENTS};tbb;" MATCHES ";${_comp};")
+    if(";${TBB_FIND_COMPONENTS};${TBB_TARGET_COMPONENT};" MATCHES ";${_comp};")
 
       # Search for the libraries
       find_library(TBB_${_comp}_LIBRARY_RELEASE ${_comp}
@@ -234,12 +243,15 @@ if(NOT TBB_FOUND)
 
       if(TBB_${_comp}_LIBRARY_DEBUG)
         list(APPEND TBB_LIBRARIES_DEBUG "${TBB_${_comp}_LIBRARY_DEBUG}")
+        set(TBB_tbb_LIBRARY_DEBUG "${TBB_${_comp}_LIBRARY_DEBUG}")
       endif()
       if(TBB_${_comp}_LIBRARY_RELEASE)
         list(APPEND TBB_LIBRARIES_RELEASE "${TBB_${_comp}_LIBRARY_RELEASE}")
+        set(TBB_tbb_LIBRARY_RELEASE "${TBB_${_comp}_LIBRARY_RELEASE}")
       endif()
       if(TBB_${_comp}_LIBRARY_${TBB_BUILD_TYPE} AND NOT TBB_${_comp}_LIBRARY)
         set(TBB_${_comp}_LIBRARY "${TBB_${_comp}_LIBRARY_${TBB_BUILD_TYPE}}")
+        set(TBB_tbb_LIBRARY "${TBB_${_comp}_LIBRARY_${TBB_BUILD_TYPE}}")
       endif()
 
       if(TBB_${_comp}_LIBRARY AND EXISTS "${TBB_${_comp}_LIBRARY}")
@@ -252,6 +264,7 @@ if(NOT TBB_FOUND)
       mark_as_advanced(TBB_${_comp}_LIBRARY_RELEASE)
       mark_as_advanced(TBB_${_comp}_LIBRARY_DEBUG)
       mark_as_advanced(TBB_${_comp}_LIBRARY)
+      mark_as_advanced(TBB_tbb_LIBRARY)
 
     endif()
   endforeach()
@@ -284,12 +297,12 @@ if(NOT TBB_FOUND)
   ##################################
 
   if(NOT CMAKE_VERSION VERSION_LESS 3.0 AND TBB_FOUND)
-    add_library(TBB::tbb SHARED IMPORTED)
-    set_target_properties(TBB::tbb PROPERTIES
+    add_library(TBB::${TBB_TARGET_COMPONENT} SHARED IMPORTED)
+    set_target_properties(TBB::${TBB_TARGET_COMPONENT} PROPERTIES
           INTERFACE_INCLUDE_DIRECTORIES  ${TBB_INCLUDE_DIRS}
           IMPORTED_LOCATION              ${TBB_LIBRARIES})
     if(TBB_LIBRARIES_RELEASE AND TBB_LIBRARIES_DEBUG)
-      set_target_properties(TBB::tbb PROPERTIES
+      set_target_properties(TBB::${TBB_TARGET_COMPONENT} PROPERTIES
           INTERFACE_COMPILE_DEFINITIONS "$<$<OR:$<CONFIG:Debug>,$<CONFIG:RelWithDebInfo>>:TBB_USE_DEBUG=1>"
           IMPORTED_LOCATION_DEBUG          ${TBB_LIBRARIES_DEBUG}
           IMPORTED_LOCATION_RELWITHDEBINFO ${TBB_LIBRARIES_DEBUG}
@@ -297,9 +310,9 @@ if(NOT TBB_FOUND)
           IMPORTED_LOCATION_MINSIZEREL     ${TBB_LIBRARIES_RELEASE}
           )
     elseif(TBB_LIBRARIES_RELEASE)
-      set_target_properties(TBB::tbb PROPERTIES IMPORTED_LOCATION ${TBB_LIBRARIES_RELEASE})
+      set_target_properties(TBB::${TBB_TARGET_COMPONENT} PROPERTIES IMPORTED_LOCATION ${TBB_LIBRARIES_RELEASE})
     else()
-      set_target_properties(TBB::tbb PROPERTIES
+      set_target_properties(TBB::${TBB_TARGET_COMPONENT} PROPERTIES
           INTERFACE_COMPILE_DEFINITIONS "${TBB_DEFINITIONS_DEBUG}"
           IMPORTED_LOCATION              ${TBB_LIBRARIES_DEBUG}
           )
diff --git extras/usd/examples/usdObj/pch.h extras/usd/examples/usdObj/pch.h
index 6a8744cbc..aaed5d63e 100644
--- extras/usd/examples/usdObj/pch.h
+++ extras/usd/examples/usdObj/pch.h
@@ -166,7 +166,9 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git extras/usd/examples/usdSchemaExamples/pch.h extras/usd/examples/usdSchemaExamples/pch.h
index 47666439a..507bf5a06 100644
--- extras/usd/examples/usdSchemaExamples/pch.h
+++ extras/usd/examples/usdSchemaExamples/pch.h
@@ -168,7 +168,9 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git pxr/base/plug/pch.h pxr/base/plug/pch.h
index 98b6fc782..a4276a8dc 100644
--- pxr/base/plug/pch.h
+++ pxr/base/plug/pch.h
@@ -183,7 +183,9 @@
 #include <boost/type_traits/remove_reference.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_vector.h>
 #include <tbb/enumerable_thread_specific.h>
diff --git pxr/base/tf/pch.h pxr/base/tf/pch.h
index 64e232c84..b4257503c 100644
--- pxr/base/tf/pch.h
+++ pxr/base/tf/pch.h
@@ -242,7 +242,9 @@
 #include <boost/variant.hpp>
 #include <boost/variant/get.hpp>
 #include <boost/variant/variant.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/enumerable_thread_specific.h>
 #include <tbb/spin_mutex.h>
 #include <tbb/spin_rw_mutex.h>
diff --git pxr/base/tf/testenv/error.cpp pxr/base/tf/testenv/error.cpp
index e8eed44a4..7c895113b 100644
--- pxr/base/tf/testenv/error.cpp
+++ pxr/base/tf/testenv/error.cpp
@@ -29,7 +29,11 @@
 
 #include "pxr/base/arch/functionLite.h"
 
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+#include <thread>
+#else 
 #include <tbb/tbb_thread.h>
+#endif 
 
 #define FILENAME   "error.cpp"
 
@@ -195,7 +199,11 @@ Test_TfErrorThreadTransport()
     printf("Creating TfErrorMark\n");
     TfErrorMark m;
     printf("Launching thread\n");
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+    std::thread t([&transport]() { _ThreadTask(&transport); });
+#else 
     tbb::tbb_thread t([&transport]() { _ThreadTask(&transport); });
+#endif 
     TF_AXIOM(m.IsClean());
     t.join();
     printf("Thread completed, posting error.\n");
diff --git pxr/base/trace/pch.h pxr/base/trace/pch.h
index 25f4b5d6c..6b51e59de 100644
--- pxr/base/trace/pch.h
+++ pxr/base/trace/pch.h
@@ -178,7 +178,9 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_vector.h>
diff --git pxr/base/vt/pch.h pxr/base/vt/pch.h
index 75f03bee2..62c737d26 100644
--- pxr/base/vt/pch.h
+++ pxr/base/vt/pch.h
@@ -171,7 +171,9 @@
 #include <boost/type_traits/is_same.hpp>
 #include <boost/type_traits/remove_reference.hpp>
 #include <boost/utility/enable_if.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_unordered_map.h>
 #include <tbb/enumerable_thread_specific.h>
diff --git pxr/base/work/detachedTask.h pxr/base/work/detachedTask.h
index 876fee68c..5e0f9cc34 100644
--- pxr/base/work/detachedTask.h
+++ pxr/base/work/detachedTask.h
@@ -36,12 +36,18 @@
 
 PXR_NAMESPACE_OPEN_SCOPE
 
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+#define TBB_TASK_CONST const
+#else 
+#define TBB_TASK_CONST
+#endif 
+
 template <class Fn>
 struct Work_DetachedTask
 {
     explicit Work_DetachedTask(Fn &&fn) : _fn(std::move(fn)) {}
     explicit Work_DetachedTask(Fn const &fn) : _fn(fn) {}
-    void operator()() {
+    void operator()() TBB_TASK_CONST {
         TfErrorMark m;
         _fn();
         m.Clear();
diff --git pxr/base/work/dispatcher.cpp pxr/base/work/dispatcher.cpp
index adba7dff3..5af742983 100644
--- pxr/base/work/dispatcher.cpp
+++ pxr/base/work/dispatcher.cpp
@@ -35,24 +35,36 @@ WorkDispatcher::WorkDispatcher()
 {
     _waitCleanupFlag.clear();
     
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+    _taskGroup = new tbb::task_group(_context);
+#else 
     // The concurrent_wait flag used with the task_group_context ensures
     // the ref count will remain at 1 after all predecessor tasks are
     // completed, so we don't need to keep resetting it in Wait().
     _rootTask = new(tbb::task::allocate_root(_context)) tbb::empty_task;
     _rootTask->set_ref_count(1);
+#endif 
 }
 
 WorkDispatcher::~WorkDispatcher()
 {
     Wait();
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+    delete _taskGroup;
+#else 
     tbb::task::destroy(*_rootTask);
+#endif 
 }
 
 void
 WorkDispatcher::Wait()
 {
     // Wait for tasks to complete.
-    _rootTask->wait_for_all();
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+    _taskGroup->wait();
+#else 
+     _rootTask->wait_for_all();
+#endif 
 
     // If we take the flag from false -> true, we do the cleanup.
     if (_waitCleanupFlag.test_and_set() == false) {
diff --git pxr/base/work/dispatcher.h pxr/base/work/dispatcher.h
index 2c499d6ab..ee0341892 100644
--- pxr/base/work/dispatcher.h
+++ pxr/base/work/dispatcher.h
@@ -35,6 +35,9 @@
 
 #include <tbb/concurrent_vector.h>
 #include <tbb/task.h>
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+#include <tbb/task_group.h>
+#endif 
 
 #include <functional>
 #include <type_traits>
@@ -103,7 +106,11 @@ public:
 
     template <class Callable>
     inline void Run(Callable &&c) {
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+        _taskGroup->run(std::forward<Callable>(c));
+#else 
         _rootTask->spawn(_MakeInvokerTask(std::forward<Callable>(c)));
+#endif 
     }
 
     template <class Callable, class A0, class ... Args>
@@ -133,6 +140,7 @@ public:
 private:
     typedef tbb::concurrent_vector<TfErrorTransport> _ErrorTransports;
 
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
     // Function invoker helper that wraps the invocation with an ErrorMark so we
     // can transmit errors that occur back to the thread that Wait() s for tasks
     // to complete.
@@ -164,6 +172,7 @@ private:
             _InvokerTask<typename std::remove_reference<Fn>::type>(
                 std::forward<Fn>(fn), &_errors);
     }
+#endif 
 
     // Helper function that removes errors from \p m and stores them in a new
     // entry in \p errors.
@@ -172,8 +181,14 @@ private:
 
     // Task group context and associated root task that allows us to cancel
     // tasks invoked directly by this dispatcher.
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+    tbb::detail::d1::task_group_context _context;
+    tbb::detail::d1::task_group *_taskGroup;
+#else 
     tbb::task_group_context _context;
     tbb::empty_task* _rootTask;
+#endif 
+    
 
     // The error transports we use to transmit errors in other threads back to
     // this thread.
diff --git pxr/base/work/pch.h pxr/base/work/pch.h
index 228b18d0d..e3a3275c1 100644
--- pxr/base/work/pch.h
+++ pxr/base/work/pch.h
@@ -110,7 +110,9 @@
 #include <boost/type_traits/is_enum.hpp>
 #include <boost/type_traits/is_same.hpp>
 #include <boost/utility/enable_if.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_vector.h>
@@ -121,4 +123,8 @@
 #include <tbb/spin_rw_mutex.h>
 #include <tbb/task.h>
 #include <tbb/task_arena.h>
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+#include <tbb/global_control.h>
+#else 
 #include <tbb/task_scheduler_init.h>
+#endif 
diff --git pxr/base/work/threadLimits.cpp pxr/base/work/threadLimits.cpp
index bc629b812..9c85a5455 100644
--- pxr/base/work/threadLimits.cpp
+++ pxr/base/work/threadLimits.cpp
@@ -29,7 +29,11 @@
 
 #include "pxr/base/tf/envSetting.h"
 
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+#include <tbb/global_control.h>
+#else 
 #include <tbb/task_scheduler_init.h>
+#endif 
 #include <tbb/task_arena.h>
 
 #include <algorithm>
@@ -58,16 +62,25 @@ TF_DEFINE_ENV_SETTING(
 
 PXR_NAMESPACE_OPEN_SCOPE
 
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 // We create a task_scheduler_init instance at static initialization time if
 // PXR_WORK_THREAD_LIMIT is set to a nonzero value.  Otherwise this stays NULL.
 static tbb::task_scheduler_init *_tbbTaskSchedInit;
+#else 
+static unsigned kThreadLimit = 0;
+static tbb::global_control *_tbbGlobalControl;
+#endif 
 
 unsigned
 WorkGetPhysicalConcurrencyLimit()
 {
     // Use TBB here, since it pays attention to the affinity mask on Linux and
     // Windows.
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
     return tbb::task_scheduler_init::default_num_threads();
+#else 
+    return tbb::info::default_concurrency();
+#endif 
 }
 
 // This function always returns an actual thread count >= 1.
@@ -123,7 +136,12 @@ Work_InitializeThreading()
     // previously initialized by the hosting environment (e.g. if we are running
     // as a plugin to another application.)
     if (settingVal) {
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
         _tbbTaskSchedInit = new tbb::task_scheduler_init(threadLimit);
+#else 
+         _tbbGlobalControl = new tbb::global_control(tbb::global_control::max_allowed_parallelism, threadLimit);
+         kThreadLimit = threadLimit;
+#endif  
     }
 }
 static int _forceInitialization = (Work_InitializeThreading(), 0);
@@ -162,12 +180,20 @@ WorkSetConcurrencyLimit(unsigned n)
     // According to the documentation that should be the case, but we should
     // make sure.  If we do decide to delete it, we have to make sure to 
     // note that it has already been initialized.
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
     if (_tbbTaskSchedInit) {
-        _tbbTaskSchedInit->terminate();
         _tbbTaskSchedInit->initialize(threadLimit);
     } else {
         _tbbTaskSchedInit = new tbb::task_scheduler_init(threadLimit);
     }
+#else 
+    kThreadLimit = threadLimit;
+    if(_tbbGlobalControl)
+    {
+        delete _tbbGlobalControl;
+    }
+    _tbbGlobalControl = new tbb::global_control(tbb::global_control::max_allowed_parallelism, threadLimit);
+#endif 
 }
 
 void 
@@ -185,7 +211,11 @@ WorkSetConcurrencyLimitArgument(int n)
 unsigned
 WorkGetConcurrencyLimit()
 {
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
     return tbb::this_task_arena::max_concurrency();
+#else 
+    return kThreadLimit > 0 ? kThreadLimit: tbb::global_control::active_value(tbb::global_control::max_allowed_parallelism);
+#endif 
 }
 
 bool
diff --git pxr/imaging/garch/pch.h pxr/imaging/garch/pch.h
index 7ef3bd8af..3b285471b 100644
--- pxr/imaging/garch/pch.h
+++ pxr/imaging/garch/pch.h
@@ -145,7 +145,9 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/enumerable_thread_specific.h>
 #include <tbb/spin_rw_mutex.h>
 #ifdef PXR_PYTHON_SUPPORT_ENABLED
diff --git pxr/imaging/glf/pch.h pxr/imaging/glf/pch.h
index 9a7e85a6c..787e461cf 100644
--- pxr/imaging/glf/pch.h
+++ pxr/imaging/glf/pch.h
@@ -199,7 +199,9 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/weak_ptr.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git pxr/imaging/hd/pch.h pxr/imaging/hd/pch.h
index 604861b7b..57c3b018c 100644
--- pxr/imaging/hd/pch.h
+++ pxr/imaging/hd/pch.h
@@ -152,7 +152,9 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/weak_ptr.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git pxr/imaging/hdGp/pch.h pxr/imaging/hdGp/pch.h
index bf09080c2..cb0cdd6bd 100644
--- pxr/imaging/hdGp/pch.h
+++ pxr/imaging/hdGp/pch.h
@@ -120,7 +120,9 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_map.h>
diff --git pxr/imaging/hdMtlx/pch.h pxr/imaging/hdMtlx/pch.h
index bf8ff6a36..7395a347f 100644
--- pxr/imaging/hdMtlx/pch.h
+++ pxr/imaging/hdMtlx/pch.h
@@ -139,7 +139,9 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_hash_map.h>
 #include <tbb/concurrent_queue.h>
diff --git pxr/imaging/hdSt/pch.h pxr/imaging/hdSt/pch.h
index 196960f7b..8692a6ad0 100644
--- pxr/imaging/hdSt/pch.h
+++ pxr/imaging/hdSt/pch.h
@@ -170,7 +170,9 @@
 #include <opensubdiv/osd/cpuVertexBuffer.h>
 #include <opensubdiv/osd/mesh.h>
 #include <opensubdiv/version.h>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git pxr/imaging/hdar/pch.h pxr/imaging/hdar/pch.h
index 56d867c1c..43c9b79e2 100644
--- pxr/imaging/hdar/pch.h
+++ pxr/imaging/hdar/pch.h
@@ -131,7 +131,9 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/spin_mutex.h>
diff --git pxr/imaging/hdsi/pch.h pxr/imaging/hdsi/pch.h
index 1662d7e8b..f1ec0b6a4 100644
--- pxr/imaging/hdsi/pch.h
+++ pxr/imaging/hdsi/pch.h
@@ -119,7 +119,9 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/concurrent_queue.h>
 #ifdef PXR_PYTHON_SUPPORT_ENABLED
 #include "pxr/base/tf/pySafePython.h"
diff --git pxr/imaging/hdx/pch.h pxr/imaging/hdx/pch.h
index 33ddb1b5d..2022667b3 100644
--- pxr/imaging/hdx/pch.h
+++ pxr/imaging/hdx/pch.h
@@ -152,7 +152,9 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/weak_ptr.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git pxr/imaging/hgiMetal/pch.h pxr/imaging/hgiMetal/pch.h
index 877bc45ee..21bd16ffa 100644
--- pxr/imaging/hgiMetal/pch.h
+++ pxr/imaging/hgiMetal/pch.h
@@ -141,7 +141,9 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/weak_ptr.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/spin_mutex.h>
diff --git pxr/imaging/plugin/hdEmbree/pch.h pxr/imaging/plugin/hdEmbree/pch.h
index 771022980..fb0e5a6ba 100644
--- pxr/imaging/plugin/hdEmbree/pch.h
+++ pxr/imaging/plugin/hdEmbree/pch.h
@@ -154,7 +154,9 @@
 #include <embree3/rtcore.h>
 #include <embree3/rtcore_geometry.h>
 #include <embree3/rtcore_ray.h>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git pxr/imaging/plugin/hdStorm/pch.h pxr/imaging/plugin/hdStorm/pch.h
index 33c5124a9..284efd6ca 100644
--- pxr/imaging/plugin/hdStorm/pch.h
+++ pxr/imaging/plugin/hdStorm/pch.h
@@ -141,7 +141,9 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/weak_ptr.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/spin_mutex.h>
diff --git pxr/usd/ar/pch.h pxr/usd/ar/pch.h
index b3333376f..7303ee2a4 100644
--- pxr/usd/ar/pch.h
+++ pxr/usd/ar/pch.h
@@ -166,7 +166,9 @@
 #include <boost/type_traits/is_same.hpp>
 #include <boost/type_traits/remove_reference.hpp>
 #include <boost/utility/enable_if.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/concurrent_hash_map.h>
 #include <tbb/enumerable_thread_specific.h>
 #include <tbb/spin_rw_mutex.h>
diff --git pxr/usd/ndr/pch.h pxr/usd/ndr/pch.h
index 897ad796b..2b88557eb 100644
--- pxr/usd/ndr/pch.h
+++ pxr/usd/ndr/pch.h
@@ -198,7 +198,9 @@
 #include <boost/type_traits/remove_reference.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/enumerable_thread_specific.h>
diff --git pxr/usd/pcp/mapExpression.cpp pxr/usd/pcp/mapExpression.cpp
index d8f90d7ee..f5830cc14 100644
--- pxr/usd/pcp/mapExpression.cpp
+++ pxr/usd/pcp/mapExpression.cpp
@@ -238,7 +238,11 @@ PcpMapExpression::_Node::New( _Op op_,
         // Check for existing instance to re-use
         _NodeMap::accessor accessor;
         if (_nodeRegistry->map.insert(accessor, key) ||
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
             accessor->second->_refCount.fetch_and_increment() == 0) {
+#else 
+            accessor->second->_refCount.fetch_add(1, std::memory_order_relaxed) == 0) {
+#endif 
             // Either there was no node in the table, or there was but it had
             // begun dying (another client dropped its refcount to 0).  We have
             // to create a new node in the table.  When the client that is
@@ -388,7 +392,11 @@ intrusive_ptr_add_ref(PcpMapExpression::_Node* p)
 void
 intrusive_ptr_release(PcpMapExpression::_Node* p)
 {
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
     if (p->_refCount.fetch_and_decrement() == 1)
+#else 
+    if (p->_refCount.fetch_sub(1, std::memory_order_relaxed) == 1)
+#endif 
         delete p;
 }
 
diff --git pxr/usd/pcp/mapExpression.h pxr/usd/pcp/mapExpression.h
index 9c8920141..f8f698e8f 100644
--- pxr/usd/pcp/mapExpression.h
+++ pxr/usd/pcp/mapExpression.h
@@ -30,7 +30,9 @@
 
 #include <boost/intrusive_ptr.hpp>
 
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/spin_mutex.h>
 
 #include <atomic>
@@ -267,7 +269,11 @@ private: // data
         struct _NodeMap;
         static TfStaticData<_NodeMap> _nodeRegistry;
 
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
         mutable tbb::atomic<int> _refCount;
+#else 
+        mutable std::atomic<int> _refCount;
+#endif 
         mutable Value _cachedValue;
         mutable std::set<_Node*> _dependentExpressions;
         Value _valueForVariable;
diff --git pxr/usd/pcp/pch.h pxr/usd/pcp/pch.h
index a7180637d..5828e4dc8 100644
--- pxr/usd/pcp/pch.h
+++ pxr/usd/pcp/pch.h
@@ -194,7 +194,9 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_hash_map.h>
diff --git pxr/usd/plugin/usdAbc/pch.h pxr/usd/plugin/usdAbc/pch.h
index f5c7e6fb6..2daa8d6d3 100644
--- pxr/usd/plugin/usdAbc/pch.h
+++ pxr/usd/plugin/usdAbc/pch.h
@@ -206,7 +206,9 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git pxr/usd/plugin/usdDraco/pch.h pxr/usd/plugin/usdDraco/pch.h
index aff99924d..a1506ac40 100644
--- pxr/usd/plugin/usdDraco/pch.h
+++ pxr/usd/plugin/usdDraco/pch.h
@@ -169,7 +169,9 @@
 #include <draco/compression/encode.h>
 #include <draco/mesh/mesh.h>
 #include <draco/mesh/mesh_misc_functions.h>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git pxr/usd/sdf/changeManager.cpp pxr/usd/sdf/changeManager.cpp
index 7ea592d04..d5b58c483 100644
--- pxr/usd/sdf/changeManager.cpp
+++ pxr/usd/sdf/changeManager.cpp
@@ -34,7 +34,11 @@
 #include "pxr/base/tf/instantiateSingleton.h"
 #include "pxr/base/tf/stackTrace.h"
 
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#else 
+#include <atomic>
+#endif 
 
 using std::string;
 using std::vector;
@@ -150,9 +154,17 @@ Sdf_ChangeManager::_ProcessRemoveIfInert(_Data *data)
     TF_VERIFY(data->outermostBlock);
 }
 
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 static tbb::atomic<size_t> &
+#else
+static std::atomic<size_t> &
+#endif 
 _InitChangeSerialNumber() {
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
     static tbb::atomic<size_t> value;
+#else 
+    static std::atomic<size_t> value;
+#endif 
     value = 1;
     return value;
 }
@@ -191,8 +203,14 @@ Sdf_ChangeManager::_SendNotices(_Data *data)
     }
 
     // Obtain a serial number for this round of change processing.
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
     static tbb::atomic<size_t> &changeSerialNumber = _InitChangeSerialNumber();
     size_t serialNumber = changeSerialNumber.fetch_and_increment();
+#else 
+    static std::atomic<size_t> &changeSerialNumber = _InitChangeSerialNumber();
+    size_t serialNumber = changeSerialNumber.fetch_add(1, std::memory_order_relaxed);
+#endif 
+   
 
     // Send global notice.
     SdfNotice::LayersDidChange(changes, serialNumber).Send();
diff --git pxr/usd/sdf/pch.h pxr/usd/sdf/pch.h
index 0728ebe68..4ee12b616 100644
--- pxr/usd/sdf/pch.h
+++ pxr/usd/sdf/pch.h
@@ -225,7 +225,9 @@
 #include <boost/variant.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_hash_map.h>
diff --git pxr/usd/usd/crateData.cpp pxr/usd/usd/crateData.cpp
index 9fc96b377..41c086f18 100644
--- pxr/usd/usd/crateData.cpp
+++ pxr/usd/usd/crateData.cpp
@@ -803,8 +803,11 @@ private:
             TfAutoMallocTag tag("field data");
             auto &fieldValuePairs =
                 liveFieldSets[FieldSetIndex(fsBegin-fieldSets.begin())];
-                    
+#ifdef PXR_ONETBB_SUPPORT_ENABLED 
+            TaskOpenFieldData task(this, _crateFile.get(), fsBegin, fsEnd, fields, fieldValuePairs);
+#endif 
             dispatcher.Run(
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
                 [this, fsBegin, fsEnd, &fields, &fieldValuePairs]() mutable {
                     try{
                         // XXX Won't need first two tags when bug #132031 is
@@ -826,7 +829,11 @@ private:
                     } catch (...) {
                         TF_RUNTIME_ERROR("Encountered unknown exception");
                     }
-                });
+                }
+#else 
+                task
+#endif 
+                );
         }
                 
         dispatcher.Wait();
@@ -1058,6 +1065,56 @@ private:
         SdfSpecType specType;
     };
 
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+    struct TaskOpenFieldData {
+        typedef std::pair<TfToken, VtValue> FieldValuePair;
+        typedef Usd_Shared<_FieldValuePairVector> SharedFieldValuePairVector;
+        TaskOpenFieldData(Usd_CrateDataImpl* owner, CrateFile* crateFile, vector<Usd_CrateFile::FieldIndex>::iterator begin, vector<Usd_CrateFile::FieldIndex>::iterator end,
+            vector<CrateFile::Field> &fields, SharedFieldValuePairVector &fieldValuePairs)
+            :m_owner(owner),
+            m_crateFile(crateFile),
+            m_begin(begin),
+            m_end(end),
+            m_fields(fields),
+            m_fieldValuePairs(fieldValuePairs)
+        {
+
+        }
+
+        void operator()() const {
+            try{
+                // XXX Won't need first two tags when bug #132031 is
+                // addressed
+                TfAutoMallocTag tag(
+                    "Usd", "Usd_CrateDataImpl::Open", "field data");
+                auto &pairs = m_fieldValuePairs.GetMutable();
+                 vector<Usd_CrateFile::FieldIndex>::const_iterator begin = m_begin;
+                pairs.resize(m_end-begin);
+                for (size_t i = 0; begin != m_end; ++begin, ++i) {
+                    auto const &field = m_fields[begin->value];
+                    pairs[i].first = 
+                        m_crateFile->GetToken(field.tokenIndex);
+                    pairs[i].second = m_owner->_UnpackForField(field.valueRep);
+                } 
+            } catch (const std::exception &e){
+                TF_RUNTIME_ERROR("Encountered exception: %s %s", 
+                    e.what(), m_crateFile->GetAssetPath().c_str());
+
+            } catch (...) {
+                TF_RUNTIME_ERROR("Encountered unknown exception");
+            }
+        }
+
+    private:
+        Usd_CrateDataImpl *m_owner;
+        CrateFile         *m_crateFile;
+        vector<Usd_CrateFile::FieldIndex>::iterator m_begin;
+        vector<Usd_CrateFile::FieldIndex>::iterator m_end;
+        vector<CrateFile::Field>        m_fields;
+        SharedFieldValuePairVector      m_fieldValuePairs;
+    };
+#endif 
+
     using _HashMap = pxr_tsl::robin_map<
         SdfPath, _SpecData, SdfPath::Hash, std::equal_to<SdfPath>,
         std::allocator<std::pair<SdfPath, _SpecData>>,
diff --git pxr/usd/usd/crateFile.cpp pxr/usd/usd/crateFile.cpp
index 333a3edfb..db438bef0 100644
--- pxr/usd/usd/crateFile.cpp
+++ pxr/usd/usd/crateFile.cpp
@@ -3700,6 +3700,7 @@ CrateFile::_ReadPathsImpl(Reader reader,
             if (hasSibling) {
                 // Branch off a parallel task for the sibling subtree.
                 auto siblingOffset = reader.template Read<int64_t>();
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
                 dispatcher.Run(
                     [this, reader,
                      siblingOffset, &dispatcher, parentPath]() mutable {
@@ -3710,6 +3711,10 @@ CrateFile::_ReadPathsImpl(Reader reader,
                         reader.Seek(siblingOffset);
                         _ReadPathsImpl<Header>(reader, dispatcher, parentPath);
                     });
+#else 
+                TaskReadPath<Header, Reader> task(this, &reader, siblingOffset, &dispatcher, parentPath);
+                dispatcher.Run(task);
+#endif 
             }
             // Have a child (may have also had a sibling). Reset parent path.
             parentPath = _paths[h.index.value];
@@ -3836,6 +3841,7 @@ CrateFile::_BuildDecompressedPathsImpl(
                     return;
                 }
 #endif
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
                 dispatcher.Run(
                     [this, &pathIndexes, &elementTokenIndexes, &jumps,
                      siblingIndex, &dispatcher, parentPath]() mutable {
@@ -3847,6 +3853,10 @@ CrateFile::_BuildDecompressedPathsImpl(
                             pathIndexes, elementTokenIndexes, jumps,
                             siblingIndex, parentPath, dispatcher);
                     });
+#else 
+                TaskBuildDecompressedpath task(this, pathIndexes, elementTokenIndexes, jumps, siblingIndex, &dispatcher, parentPath);
+                dispatcher.Run(task);
+#endif
             }
             // Have a child (may have also had a sibling). Reset parent path.
             parentPath = _paths[pathIndexes[thisIndex]];
diff --git pxr/usd/usd/crateFile.h pxr/usd/usd/crateFile.h
index 67b1aa385..864e7c38d 100644
--- pxr/usd/usd/crateFile.h
+++ pxr/usd/usd/crateFile.h
@@ -338,10 +338,29 @@ private:
         class _Impl {
             friend class _FileMapping;
 
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+            class tbb_hash
+            {
+            public:
+                tbb_hash() {}
+
+                template<typename Key>
+                std::size_t operator () (const Key& z) const
+                {
+                   return TfHash::Combine(
+                        reinterpret_cast<uintptr_t>(z.GetAddr()),
+                        z.GetNumBytes()
+                    );
+                }
+            };
+#endif 
+
             // This is a foreign data source for VtArray that refers into a
             // memory-mapped region, and shares in the lifetime of the mapping.
             struct ZeroCopySource : public Vt_ArrayForeignDataSource {
-                explicit ZeroCopySource(_Impl *m,
+                ZeroCopySource() = default;
+
+                ZeroCopySource(_Impl *m,
                                         void const *addr,
                                         size_t numBytes);
                 
@@ -422,7 +441,11 @@ private:
             ArchConstFileMapping _mapping;
             char const *_start;
             int64_t _length;
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+            tbb::concurrent_unordered_set<ZeroCopySource, tbb_hash> _outstandingRanges;
+#else 
             tbb::concurrent_unordered_set<ZeroCopySource> _outstandingRanges;
+#endif 
         };
 
     public:
@@ -666,6 +689,69 @@ public:
         SdfSpecType specType;
     };
 
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+    template<typename Header, typename Reader>
+    struct TaskReadPath {
+        TaskReadPath(CrateFile* owner, Reader *reader, int64_t offset, WorkDispatcher* dispatcher, SdfPath path)
+            :m_owner(owner),
+            m_reader(reader),
+            m_offset(offset),
+            m_dispatcher(dispatcher),
+            m_path(path)
+        {
+
+        }
+
+        void operator()() const{
+            TfAutoMallocTag tag(
+                "Usd", "Usd_CrateDataImpl::Open",
+                "Usd_CrateFile::CrateFile::Open", "_ReadPaths");
+                m_reader->Seek(m_offset);
+                m_owner->_ReadPathsImpl<Header>(*m_reader, *m_dispatcher, m_path);
+        }
+
+    private:
+        CrateFile     *m_owner = nullptr;
+        Reader        *m_reader;
+        int64_t        m_offset = 0;
+        WorkDispatcher *m_dispatcher = nullptr;
+        SdfPath        m_path;
+    };
+
+    struct TaskBuildDecompressedpath {
+        TaskBuildDecompressedpath(CrateFile* owner, vector<uint32_t> const &pathIndexes,  vector<int32_t> const &elementTokenIndexes, vector<int32_t> const &jumps, 
+                int64_t offset, WorkDispatcher* dispatcher, SdfPath path)
+            :m_owner(owner),
+            m_pathIndexes(pathIndexes),
+            m_elementTokenIndexes(elementTokenIndexes),
+            m_jumps(jumps),
+            m_offset(offset),
+            m_dispatcher(dispatcher),
+            m_path(path)
+        {
+
+        }
+
+        void operator()() const{
+            TfAutoMallocTag tag(
+                            "Usd", "Usd_CrateDataImpl::Open",
+                            "Usd_CrateFile::CrateFile::Open", "_ReadPaths");
+            m_owner->_BuildDecompressedPathsImpl(
+                            m_pathIndexes, m_elementTokenIndexes, m_jumps,
+                            m_offset, m_path, *m_dispatcher);
+        }
+
+    private:
+        CrateFile         *m_owner = nullptr;
+        vector<uint32_t>  m_pathIndexes;
+        vector<int32_t>   m_elementTokenIndexes;
+        vector<int32_t>   m_jumps;
+        int64_t           m_offset = 0;
+        WorkDispatcher    *m_dispatcher = nullptr;
+        SdfPath           m_path;
+    };
+#endif 
+
     ~CrateFile();
 
     static bool CanRead(string const &assetPath);
diff --git pxr/usd/usd/pch.h pxr/usd/usd/pch.h
index d360999d4..00b77d42f 100644
--- pxr/usd/usd/pch.h
+++ pxr/usd/usd/pch.h
@@ -227,7 +227,9 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/utility/in_place_factory.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_hash_map.h>
diff --git pxr/usd/usdGeom/bboxCache.cpp pxr/usd/usdGeom/bboxCache.cpp
index 454f97bcb..428e3697c 100644
--- pxr/usd/usdGeom/bboxCache.cpp
+++ pxr/usd/usdGeom/bboxCache.cpp
@@ -49,6 +49,12 @@
 
 PXR_NAMESPACE_OPEN_SCOPE
 
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+#define TBB_TASK_CONST const
+#else 
+#define TBB_TASK_CONST
+#endif 
+
 namespace {
 
 // For code that knows at compile time whether we need to apply a transform.
@@ -99,9 +105,13 @@ public:
     explicit operator bool() const {
         return _owner;
     }
-    void operator()() {
+    void operator()() TBB_TASK_CONST {
         // Do not save state here; all state should be accumulated externally.
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+        _owner->_ResolvePrim(const_cast<_BBoxTask*>(this), _primContext, _inverseComponentCtm);
+#else 
         _owner->_ResolvePrim(this, _primContext, _inverseComponentCtm);
+#endif 
     }
     _ThreadXformCache* GetXformCaches() { return _xfCaches; }
 };
@@ -126,9 +136,21 @@ private:
     {
         _PrototypeTask() : numDependencies(0) { }
 
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+        _PrototypeTask(const _PrototypeTask& other)
+        {
+            dependentPrototypes = other.dependentPrototypes;
+            numDependencies.store(other.numDependencies.load(std::memory_order_relaxed), std::memory_order_relaxed);
+        }
+#endif 
+
         // Number of dependencies -- prototype prims that must be resolved
         // before this prototype can be resolved.
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+        std::atomic<size_t> numDependencies;
+#else 
         tbb::atomic<size_t> numDependencies;
+#endif 
 
         // List of prototype prims that depend on this prototype.
         std::vector<_PrimContext> dependentPrototypes;
@@ -172,9 +194,17 @@ private:
     void _PopulateTasksForPrototype(const _PrimContext& prototypePrim,
                                  _PrototypeTaskMap* prototypeTasks)
     {
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+        const std::pair<const _PrimContext, _PrototypeTask> pair = std::make_pair(
+            std::ref(prototypePrim), _PrototypeTask()
+        );
+        std::pair<_PrototypeTaskMap::iterator, bool> prototypeTaskStatus =
+            prototypeTasks->insert(pair);
+#else 
         std::pair<_PrototypeTaskMap::iterator, bool> prototypeTaskStatus =
-            prototypeTasks->insert(std::make_pair(
+         prototypeTasks->insert(std::make_pair(
                     prototypePrim, _PrototypeTask()));
+#endif 
         if (!prototypeTaskStatus.second) {
             return;
         }
@@ -220,7 +250,11 @@ private:
             _PrototypeTask& dependentPrototypeData =
                 prototypeTasks->find(dependentPrototype)->second;
             if (dependentPrototypeData.numDependencies
+#ifdef PXR_ONETBB_SUPPORT_ENABLED
+                .fetch_sub(1, std::memory_order_relaxed) == 1){
+#else 
                 .fetch_and_decrement() == 1){
+#endif 
                 dispatcher->Run(
                     &_PrototypeBBoxResolver::_ExecuteTaskForPrototype,
                     this, dependentPrototype, prototypeTasks, xfCaches,
diff --git pxr/usd/usdGeom/pch.h pxr/usd/usdGeom/pch.h
index 824c5b0f9..8fd26001f 100644
--- pxr/usd/usdGeom/pch.h
+++ pxr/usd/usdGeom/pch.h
@@ -181,7 +181,9 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git pxr/usd/usdHydra/pch.h pxr/usd/usdHydra/pch.h
index 5ba9df4c2..bf8da3d43 100644
--- pxr/usd/usdHydra/pch.h
+++ pxr/usd/usdHydra/pch.h
@@ -162,7 +162,9 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git pxr/usd/usdLux/pch.h pxr/usd/usdLux/pch.h
index 8fe34cb95..53493fce2 100644
--- pxr/usd/usdLux/pch.h
+++ pxr/usd/usdLux/pch.h
@@ -177,7 +177,9 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git pxr/usd/usdMedia/pch.h pxr/usd/usdMedia/pch.h
index 7802ec3e2..1cf939142 100644
--- pxr/usd/usdMedia/pch.h
+++ pxr/usd/usdMedia/pch.h
@@ -170,7 +170,9 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git pxr/usd/usdMtlx/pch.h pxr/usd/usdMtlx/pch.h
index 5eba44e7e..74eae71fa 100644
--- pxr/usd/usdMtlx/pch.h
+++ pxr/usd/usdMtlx/pch.h
@@ -193,7 +193,9 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_map.h>
diff --git pxr/usd/usdPhysics/pch.h pxr/usd/usdPhysics/pch.h
index 824c5b0f9..8fd26001f 100644
--- pxr/usd/usdPhysics/pch.h
+++ pxr/usd/usdPhysics/pch.h
@@ -181,7 +181,9 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git pxr/usd/usdProc/pch.h pxr/usd/usdProc/pch.h
index f40455a1c..4b0085676 100644
--- pxr/usd/usdProc/pch.h
+++ pxr/usd/usdProc/pch.h
@@ -165,7 +165,9 @@
 #include <boost/variant.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git pxr/usd/usdRender/pch.h pxr/usd/usdRender/pch.h
index 7802ec3e2..1cf939142 100644
--- pxr/usd/usdRender/pch.h
+++ pxr/usd/usdRender/pch.h
@@ -170,7 +170,9 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git pxr/usd/usdRi/pch.h pxr/usd/usdRi/pch.h
index 905d2a123..4f59dd994 100644
--- pxr/usd/usdRi/pch.h
+++ pxr/usd/usdRi/pch.h
@@ -173,7 +173,9 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git pxr/usd/usdShade/pch.h pxr/usd/usdShade/pch.h
index 698ab0ca6..720ca3f0d 100644
--- pxr/usd/usdShade/pch.h
+++ pxr/usd/usdShade/pch.h
@@ -179,7 +179,9 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git pxr/usd/usdSkel/pch.h pxr/usd/usdSkel/pch.h
index a4205ac46..5836259c3 100644
--- pxr/usd/usdSkel/pch.h
+++ pxr/usd/usdSkel/pch.h
@@ -180,7 +180,9 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git pxr/usd/usdUI/pch.h pxr/usd/usdUI/pch.h
index 47666439a..507bf5a06 100644
--- pxr/usd/usdUI/pch.h
+++ pxr/usd/usdUI/pch.h
@@ -168,7 +168,9 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git pxr/usd/usdUtils/pch.h pxr/usd/usdUtils/pch.h
index 3a108ee5e..31e73f23e 100644
--- pxr/usd/usdUtils/pch.h
+++ pxr/usd/usdUtils/pch.h
@@ -215,7 +215,9 @@
 #include <boost/unordered_map.hpp>
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git pxr/usd/usdVol/pch.h pxr/usd/usdVol/pch.h
index 7802ec3e2..1cf939142 100644
--- pxr/usd/usdVol/pch.h
+++ pxr/usd/usdVol/pch.h
@@ -170,7 +170,9 @@
 #include <boost/utility.hpp>
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git pxr/usdImaging/usdAppUtils/pch.h pxr/usdImaging/usdAppUtils/pch.h
index 70b9602d5..15b906455 100644
--- pxr/usdImaging/usdAppUtils/pch.h
+++ pxr/usdImaging/usdAppUtils/pch.h
@@ -173,7 +173,9 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
 #include <boost/weak_ptr.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_set.h>
diff --git pxr/usdImaging/usdImaging/pch.h pxr/usdImaging/usdImaging/pch.h
index 35ea5620e..d46bb736c 100644
--- pxr/usdImaging/usdImaging/pch.h
+++ pxr/usdImaging/usdImaging/pch.h
@@ -173,7 +173,9 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
 #include <boost/weak_ptr.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git pxr/usdImaging/usdImagingGL/pch.h pxr/usdImaging/usdImagingGL/pch.h
index b9dfa7e41..17ca7465c 100644
--- pxr/usdImaging/usdImagingGL/pch.h
+++ pxr/usdImaging/usdImagingGL/pch.h
@@ -186,7 +186,9 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
 #include <boost/weak_ptr.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_map.h>
diff --git pxr/usdImaging/usdProcImaging/pch.h pxr/usdImaging/usdProcImaging/pch.h
index 32358e284..3c5f46010 100644
--- pxr/usdImaging/usdProcImaging/pch.h
+++ pxr/usdImaging/usdProcImaging/pch.h
@@ -161,7 +161,9 @@
 #include <boost/variant.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_hash_map.h>
 #include <tbb/concurrent_queue.h>
diff --git pxr/usdImaging/usdRiPxrImaging/pch.h pxr/usdImaging/usdRiPxrImaging/pch.h
index 6ad2d403b..e244541df 100644
--- pxr/usdImaging/usdRiPxrImaging/pch.h
+++ pxr/usdImaging/usdRiPxrImaging/pch.h
@@ -169,7 +169,9 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
 #include <boost/weak_ptr.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_map.h>
diff --git pxr/usdImaging/usdSkelImaging/pch.h pxr/usdImaging/usdSkelImaging/pch.h
index 69caaac23..39fcc7f11 100644
--- pxr/usdImaging/usdSkelImaging/pch.h
+++ pxr/usdImaging/usdSkelImaging/pch.h
@@ -169,7 +169,9 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
 #include <boost/weak_ptr.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/blocked_range.h>
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
diff --git pxr/usdImaging/usdVolImaging/pch.h pxr/usdImaging/usdVolImaging/pch.h
index 0fd54d571..410b8b4e3 100644
--- pxr/usdImaging/usdVolImaging/pch.h
+++ pxr/usdImaging/usdVolImaging/pch.h
@@ -167,7 +167,9 @@
 #include <boost/utility/enable_if.hpp>
 #include <boost/variant.hpp>
 #include <boost/weak_ptr.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_queue.h>
 #include <tbb/concurrent_unordered_map.h>
diff --git pxr/usdImaging/usdviewq/pch.h pxr/usdImaging/usdviewq/pch.h
index 2b6f4d782..fa6057600 100644
--- pxr/usdImaging/usdviewq/pch.h
+++ pxr/usdImaging/usdviewq/pch.h
@@ -164,7 +164,9 @@
 #include <boost/variant.hpp>
 #include <boost/vmd/is_empty.hpp>
 #include <boost/vmd/is_tuple.hpp>
+#ifndef PXR_ONETBB_SUPPORT_ENABLED
 #include <tbb/atomic.h>
+#endif 
 #include <tbb/cache_aligned_allocator.h>
 #include <tbb/concurrent_hash_map.h>
 #include <tbb/concurrent_queue.h>
