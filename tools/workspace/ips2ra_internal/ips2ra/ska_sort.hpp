/******************************************************************************
 * include/ips2ra/ska_sort.hpp
 *
 * In-place Parallel Super Scalar Radix Sort (IPSÂ²Ra)
 *
 ******************************************************************************
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *****************************************************************************/

// Implementation adapted and simplified from the
// SkaSort project - https://github.com/skarupke/ska_sort
//          Copyright Malte Skarupke 2016.
// Distributed under the Boost Software License, Version 1.0.
//    (See http://www.boost.org/LICENSE_1_0.txt)

#pragma once

#include <algorithm>
#include <cstdint>
#include <tuple>
#include <type_traits>
#include <utility>

#include "base_case.hpp"

namespace ips2ra {
namespace detail {

struct PartitionInfo {
    PartitionInfo() : count(0) {}

    union {
        size_t count;
        size_t offset;
    };
    size_t next_offset;
};

template <typename It, typename Func>
inline void unroll_loop_four_times(It begin, size_t iteration_count, Func&& to_call) {
    size_t loop_count = iteration_count / 4;
    size_t remainder_count = iteration_count - loop_count * 4;
    for (; loop_count > 0; --loop_count) {
        to_call(begin);
        ++begin;
        to_call(begin);
        ++begin;
        to_call(begin);
        ++begin;
        to_call(begin);
        ++begin;
    }
    switch (remainder_count) {
        case 3: to_call(begin); ++begin;
        case 2: to_call(begin); ++begin;
        case 1: to_call(begin);
    }
}

template <typename It, typename F>
inline It custom_std_partition(It begin, It end, F&& func) {
    for (;; ++begin) {
        if (begin == end) return end;
        if (!func(*begin)) break;
    }
    It it = begin;
    for (++it; it != end; ++it) {
        if (!func(*it)) continue;

        std::iter_swap(begin, it);
        ++begin;
    }
    return begin;
}

template <std::ptrdiff_t kSmallestSortSize, std::ptrdiff_t kBaseCaseMaxSize,
          std::ptrdiff_t kAmericanFlagSortThreshold, typename KeyType>
class SimpleSkaSort {
 public:
    template <typename It, typename ExtractKey>
    static void Sort(It begin, It end, std::ptrdiff_t* offs, ExtractKey& extract_key,
                     std::size_t offset, std::size_t offset_end) {
        SimpleSkaSort<kSmallestSortSize, kBaseCaseMaxSize, kAmericanFlagSortThreshold,
                      KeyType>
                sorter;
        switchUnroll<0, sizeof(KeyType) - 1>(sorter, offset, begin, end, offset_end, offs,
                                             extract_key);
    }

    template <std::size_t Offset, typename It, typename ExtractKey>
    void operator()(It begin, It end, std::size_t offset_end, std::ptrdiff_t* offs,
                    ExtractKey& extract_key) {
        SimpleSkaSort<kSmallestSortSize, kBaseCaseMaxSize, kAmericanFlagSortThreshold,
                      KeyType>::RecSort<Offset>(begin, end, offset_end, offs,
                                                extract_key);
    }

 private:
    template <std::size_t Offset>
    constexpr inline static std::size_t ShiftAmount() {
        return (((sizeof(KeyType) - 1) - Offset) * 8);
    }

    template <std::size_t Offset, typename T>
    inline static uint8_t CurrentByte(T&& elem) {
        return elem >> ShiftAmount<Offset>();
    }

    template <std::size_t Offset, typename It, typename ExtractKey>
    static void RecSort(It begin, It end, std::size_t offset_end, std::ptrdiff_t* offs,
                        ExtractKey& extract_key) {
        const std::ptrdiff_t num_elements = end - begin;
        if (!BaseCaseIfLessThanThreshold(begin, end, num_elements, offs, extract_key)) {
            if (num_elements < kAmericanFlagSortThreshold)
                AmericanFlagSort<Offset>(begin, end, offset_end, offs, extract_key);
            else
                SkaByteSort<Offset>(begin, end, offset_end, offs, extract_key);
        }
    }

    template <typename It, typename ExtractKey>
    static bool BaseCaseIfLessThanThreshold(It begin, It end, std::ptrdiff_t num_elements,
                                            std::ptrdiff_t* offs,
                                            ExtractKey& extract_key) {
        if (num_elements >= kBaseCaseMaxSize) return false;
        ips2ra::detail::baseCaseSort<kSmallestSortSize, kBaseCaseMaxSize - 1>(
                begin, end, offs, extract_key);
        return true;
    }

    template <std::size_t Offset, typename It, typename ExtractKey>
    static void AmericanFlagSort(It begin, It end, std::size_t offset_end,
                                 std::ptrdiff_t* offs, ExtractKey& extract_key) {
        PartitionInfo partitions[256];
        for (It it = begin; it != end; ++it) {
            ++partitions[CurrentByte<Offset>(extract_key(*it))].count;
        }
        size_t total = 0;
        uint8_t remaining_partitions[256];
        int num_partitions = 0;
        for (int i = 0; i < 256; ++i) {
            size_t count = partitions[i].count;
            if (!count) continue;
            partitions[i].offset = total;
            total += count;
            partitions[i].next_offset = total;
            remaining_partitions[num_partitions] = i;
            ++num_partitions;
        }
        if (num_partitions > 1) {
            uint8_t* current_block_ptr = remaining_partitions;
            PartitionInfo* current_block = partitions + *current_block_ptr;
            uint8_t* last_block = remaining_partitions + num_partitions - 1;
            It it = begin;
            It block_end = begin + current_block->next_offset;
            It last_element = end - 1;
            for (;;) {
                PartitionInfo* block = partitions + CurrentByte<Offset>(extract_key(*it));
                if (block == current_block) {
                    ++it;
                    if (it == last_element)
                        break;
                    else if (it == block_end) {
                        for (;;) {
                            ++current_block_ptr;
                            if (current_block_ptr == last_block) goto recurse;
                            current_block = partitions + *current_block_ptr;
                            if (current_block->offset != current_block->next_offset)
                                break;
                        }

                        it = begin + current_block->offset;
                        block_end = begin + current_block->next_offset;
                    }
                } else {
                    size_t offset = block->offset++;
                    std::iter_swap(it, begin + offset);
                }
            }
        }
    recurse:
        if constexpr (Offset + 1 < sizeof(KeyType)) {
            if (Offset + 1 != offset_end) {
                size_t start_offset = 0;
                It partition_begin = begin;
                for (uint8_t *it = remaining_partitions,
                             *end = remaining_partitions + num_partitions;
                     it != end; ++it) {
                    size_t end_offset = partitions[*it].next_offset;
                    It partition_end = begin + end_offset;
                    SimpleSkaSort<kSmallestSortSize, kBaseCaseMaxSize,
                                  kAmericanFlagSortThreshold,
                                  KeyType>::RecSort<Offset + 1>(partition_begin,
                                                                partition_end, offset_end,
                                                                offs, extract_key);
                    start_offset = end_offset;
                    partition_begin = partition_end;
                }
            }
        }
    }

    template <std::size_t Offset, typename It, typename ExtractKey>
    static void SkaByteSort(It begin, It end, std::size_t offset_end,
                            std::ptrdiff_t* offs, ExtractKey& extract_key) {
        PartitionInfo partitions[256];
        for (It it = begin; it != end; ++it) {
            ++partitions[CurrentByte<Offset>(extract_key(*it))].count;
        }
        uint8_t remaining_partitions[256];
        size_t total = 0;
        int num_partitions = 0;
        for (int i = 0; i < 256; ++i) {
            size_t count = partitions[i].count;
            if (count) {
                partitions[i].offset = total;
                total += count;
                remaining_partitions[num_partitions] = i;
                ++num_partitions;
            }
            partitions[i].next_offset = total;
        }
        for (uint8_t *last_remaining = remaining_partitions + num_partitions,
                     *end_partition = remaining_partitions + 1;
             last_remaining > end_partition;) {
            last_remaining = custom_std_partition(
                    remaining_partitions, last_remaining, [&](uint8_t partition) {
                        size_t& begin_offset = partitions[partition].offset;
                        size_t& end_offset = partitions[partition].next_offset;
                        if (begin_offset == end_offset) return false;

                        unroll_loop_four_times(
                                begin + begin_offset, end_offset - begin_offset,
                                [partitions = partitions, begin, &extract_key](It it) {
                                    uint8_t this_partition =
                                            CurrentByte<Offset>(extract_key(*it));
                                    size_t offset = partitions[this_partition].offset++;
                                    std::iter_swap(it, begin + offset);
                                });
                        return begin_offset != end_offset;
                    });
        }
        if constexpr (Offset + 1 < sizeof(KeyType)) {
            if (Offset + 1 != offset_end) {
                for (uint8_t* it = remaining_partitions + num_partitions;
                     it != remaining_partitions; --it) {
                    uint8_t partition = it[-1];
                    size_t start_offset =
                            (partition == 0 ? 0 : partitions[partition - 1].next_offset);
                    size_t end_offset = partitions[partition].next_offset;
                    It partition_begin = begin + start_offset;
                    It partition_end = begin + end_offset;
                    SimpleSkaSort<kSmallestSortSize, kBaseCaseMaxSize,
                                  kAmericanFlagSortThreshold,
                                  KeyType>::RecSort<Offset + 1>(partition_begin,
                                                                partition_end, offset_end,
                                                                offs, extract_key);
                }
            }
        }
    }
};

}  // namespace detail
}  // namespace ips2ra
