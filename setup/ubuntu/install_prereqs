#!/bin/bash
# -*- python -*-
#
# Installs prerequisites for Drake on Ubuntu. This script is a small bash
# trampoline which first installs Python (if missing) and then uses Python
# for the remainder of the installation.
#
""""set -euo pipefail
if ! command -v python3 > /dev/null; then
  echo "Installing python3 ..."
  if [[ "${EUID}" -ne 0 ]]; then
    SUDO=sudo
  else
    SUDO=
  fi
  if ! ${SUDO} apt-get -y install python3; then
    ${SUDO} apt-get update || (sleep 30; apt-get update)
    ${SUDO} apt-get -y install python3
  fi
fi
exec python3 -B $0 "$@"
"""

__doc__ = """
Drake setup program to install necessary prerequisites.
"""

import argparse
import enum
import functools
import json
import hashlib
import logging
import os
import pathlib
import shlex
import shutil
import sys
import subprocess
import tempfile
import textwrap
import time
import urllib.parse
import urllib.request


# Our text assets are located in the same directory as this script.
_MY_DIR = pathlib.Path(__file__).parent.resolve()


class Flavor(enum.Enum):
    """Drake users (and developers) can choose a particular flavor of
    prerequisites to install, depending on which operations they need to
    accomplish."""

    # These are listed in order from narrowest to widest prerequisites.
    # Each flavor adds more prerequisites atop the prior flavor(s).
    BINARY = "to run a precompiled binary release"
    BUILD = "to build and install using CMake and GCC"
    CLANG = "to build and install using Clang"
    DEVELOPER = "to build and test with Bazel"
    DOC = "to generate the website"
    MAINTAINER = "to perform scheduled maintainence and releases"

    def __init__(self, description):
        self.description = description

    def __ge__(self, other):
        everything = list(Flavor)
        lhs = everything.index(self)
        rhs = everything.index(other)
        return lhs >= rhs


def _warn(message: str) -> None:
    """Logs a warning. For convenience, lines are unwrapped."""
    message = textwrap.dedent(message).replace("\n", " ").strip()
    logging.warning(message)


def _error(message: str) -> None:
    """Logs an error and exits. For convenience, lines are unwrapped."""
    message = textwrap.dedent(message).replace("\n", " ").strip()
    logging.error(message)
    sys.exit(1)


def _maybe_warn_conda() -> None:
    """Warns if conda is on the $PATH."""
    if shutil.which("conda") is None:
        return
    _warn(
        """Conda was detected on your $PATH. Drake is not tested regularly with
        Anaconda, so you may experience compatibility hiccups; when asking for
        help, be sure to mention that Conda is involved."""
    )


@functools.cache
def _check_sudo() -> None:
    """Checks that 'sudo' has sufficient credentials."""
    subprocess.check_call(["sudo", "-v"])


def _run(
    *,
    args: list,
    cwd: str = None,
    check: bool = True,
    superuser: bool = False,
    flaky: bool = False,
    quiet: bool = False,
) -> None:
    """Runs a subprocess command given by `args`. When `check` is true, failure
    of the command is an `_error`. When `superuser` is true, the command will
    be run under 'sudo' unless the euid is already root. When `flaky` is true,
    the command will be retried a couple times when it fails. When `quiet` is
    true, the command line will not be printed by default."""
    command = args[0]
    if superuser and os.geteuid() != 0:
        _check_sudo()
        args = ["sudo"] + args
    logging.log(
        msg=f"Running: {shlex.join(args)} ...",
        level=logging.DEBUG if quiet else logging.INFO,
    )
    num_attempts = 3 if flaky else 1
    for i in range(num_attempts):
        if i > 0:
            logging.info("... failed; waiting 30 sec before trying again ...")
            time.sleep(30)
        process = subprocess.run(
            args,
            cwd=cwd,
            stdin=subprocess.DEVNULL,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
        )
        problem = check and (process.returncode != 0)
        if not problem:
            break
    for line in process.stdout.splitlines():
        logging.log(
            msg=f"... from {command}: {line}",
            level=logging.INFO if problem else logging.DEBUG,
        )
    logging.debug(f"... finished {command}.")
    if problem:
        _error(f"{command} failed with returncode {process.returncode}")
    return process


def _check_lsb_release():
    """Returns the lsb_release details as a dict. If necessary, installs
    lsb-release before calling it. The dict keys will typically be:
    - 'Distributor ID' (example value 'Ubuntu')
    - 'Description'    (example value 'Ubuntu 12.34.5 LTS')
    - 'Release'        (example value '12.34')
    - 'Codename'       (example value 'foobar')
    The 'Codename' is always guaranteed to exist, but the rest are optional."""
    if shutil.which("lsb_release") is None:
        _run(
            args=[
                "apt-get",
                "install",
                "--no-install-recommends",
                "--yes",
                "lsb-release",
            ],
            superuser=True,
        )
    else:
        logging.debug("lsb-release is already installed")
    result = dict()
    process = _run(args=["lsb_release", "-idrc"], quiet=True)
    for line in process.stdout.splitlines():
        tokens = line.split(":", maxsplit=1)
        if len(tokens) == 2:
            key, value = tokens
            result[key.strip()] = value.strip()
    logging.debug(f"lsb_release = {result}")
    if "Codename" not in result:
        _error(f"Missing required information from lsb_release.")
    return result


@functools.cache
def _apt_update() -> None:
    """Runs 'apt-get update' to refresh available packages."""
    process = _run(
        args=["apt-get", "update"],
        superuser=True,
        flaky=True,
    )
    if process.returncode == 0:
        return
    _error(
        """Drake is unable to run 'sudo apt-get update', probably because this
        computer contains incorrect entries in its sources.list files, or
        possibly because an internet service is down. Run 'sudo apt-get update'
        and try to resolve whatever problems it reports. Do not try to set up
        Drake until that command succeeds. This is not a bug in Drake. Do not
        contact the Drake team for help."""
    )


def _apt_fix_broken() -> None:
    """Runs 'apt-get' with '--fix-broken' to recover from missing packages."""
    _apt_update()
    _run(
        args=["apt-get", "install", "--fix-broken", "-q"],
        superuser=True,
        quiet=True,
    )


def _get_dpkg_versions(package_names: list[str]) -> dict[str, str]:
    """Returns the installed version of packages. The input is a list of
    package names, and the return value is a dict mapping all of those
    names to their installed version (or None, if not installed)."""
    assert package_names
    result = {}
    for name in package_names:
        result[name] = None
    process = _run(
        args=[
            "dpkg-query",
            "--show",
            "--showformat=${Package} ${db:Status-Abbrev} ${Version}\n",
        ]
        + package_names,
        check=False,
        quiet=True,
    )
    for line in process.stdout.splitlines():
        tokens = line.split()
        if len(tokens) != 3:
            continue
        name, status, version = tokens
        if status == "ii":
            result[name] = version
    logging.debug(f"dpkg_versions = {result}")
    return result


def _get_dpkg_version(package_name: str) -> str:
    """Like _get_dpkg_versions but for a single package."""
    return _get_dpkg_versions([package_name])[package_name]


def _dpkg_download_install(
    *, temp_dir: pathlib.Path, urls: list[str], sha256: str
) -> None:
    """Downloads and installs a '*.deb' file, verifying the checksum."""
    assert urls and sha256
    # Try each url in turn.
    success = False
    errors = []
    for url in urls:
        logging.debug(f"Trying {url} ...")
        basename = urllib.parse.urlparse(url).path.split("/")[-1]
        temp_filename = temp_dir / basename
        hasher = hashlib.sha256()
        with temp_filename.open("wb") as f:
            try:
                with urllib.request.urlopen(url=url, timeout=30) as response:
                    while True:
                        data = response.read(4096)
                        if not data:
                            break
                        hasher.update(data)
                        f.write(data)
            except OSError as e:
                errors.append(f"Candidate {url} failed:\n{e}")
                continue
        download_sha256 = hasher.hexdigest()
        if download_sha256 == sha256:
            success = True
            break
        errors.append(
            f"Candidate {url} failed:\n"
            f"Checksum mismatch; was {download_sha256} but wanted {sha256}."
        )

    # Report in case no downloads succeeded.
    if not success:
        messages = "\n\n".join(errors)
        _error(f"All downloads failed:\n\n{messages}")

    # Install the deb (even though we're possibly missing its dependencies);
    # the apt_fix_broken call should be able to add the missing dependencies.
    _run(
        args=["dpkg", "--install", str(temp_filename)],
        superuser=True,
        quiet=True,
    )
    _apt_fix_broken()


def _apt_install(*, package_names: list[str], yes: bool) -> None:
    """Installs the given packages using 'apt-get'."""
    _apt_update()
    # XXX interactive
    args = [
        "apt-get",
        "install",
        "--no-install-recommends",
    ]
    if yes:
        args.append("--yes")
    args.extend(packages)
    _run(args=args, superuser=True)


def _apt_install_flavor(
    *, lsb_release: dict[str, str], flavor: Flavor, yes: bool
) -> None:
    """XXX docs."""
    assert isinstance(flavor, Flavor)
    codename = lsb_release["Codename"]
    description = lsb_release.get("Description", "<unknown>")
    packages = []
    for item in Flavor:
        txt_file = _MY_DIR / f"packages-{codename}-{item.name.lower()}.txt"
        if not txt_file.exists():
            _warn(f"No such file {str(txt_file)}.")
            _error(f"This script does not support {description}.")
        logging.debug(f"Reading {txt_file}.")
        for line in txt_file.read_text(encoding="utf-8").splitlines():
            line = line.split("#")[0].strip()
            if not line:
                continue
            packages.append(line)
        if item == flavor:
            break
    packages = sorted(packages)
    installed = _get_dpkg_versions(packages)
    missing_packages = [
        name for name, version in installed.items() if version is None
    ]
    if missing_packages:
        _apt_install(package_names=missing_packages, yes=yes)
    else:
        logging.debug("All selected packages-*.txt are already installed.")


def _dpkg_install_bazelisk():
    """Installs bazelisk using dpkg."""
    arch = _run(
        args=["dpkg", "--print-architecture"],
        quiet=True,
    ).stdout.strip()

    # Load the json metadata.
    content = (_MY_DIR / f"packages-bazelisk.json").read_text(encoding="utf-8")
    specs = json.loads(content)
    name = specs["name"]
    version = specs["version"]
    sha256 = specs["arch"][arch]["sha256"]
    urls = specs["arch"][arch]["urls"]

    # Bail out when already installed.
    if _get_dpkg_version(name) == version:
        logging.debug(f"{name} is already at version {version}")
        return

    # XXX ask?

    # Install.
    with tempfile.TemporaryDirectory(prefix="drake_prereqs_") as temp:
        logging.info(f"Installing {name} {version} ...")
        _dpkg_download_install(
            temp_dir=pathlib.Path(temp),
            urls=urls,
            sha256=sha256,
        )


def _setup_usr_bin_python(*, yes):
    """Ensure that /usr/bin/python exists."""
    if pathlib.Path("/usr/bin/python").exists():
        logging.debug("/usr/bin/python is already installed")
        return
    _apt_install(package_names=["python-is-python3"], yes=yes)


def _setup_locales():
    """Ensures that we have available a locale that supports UTF-8 for
    generating a C++ header containing Python API documentation during
    the build."""
    required_locale = "en_US.utf8"
    for line in _run(args=["locale", "-a"], quiet=True).stdout.splitlines():
        if line.strip() == required_locale:
            logging.debug(f"The {required_locale} locale already exists.")
            return
    _run(
        args=["locale-gen", required_locale],
        superuser=True,
    )


def _maybe_setup_gcc12(*, lsb_release: dict[str, str], yes: bool):
    """Corrects a common gcc12 installation mistake.
    On Jammy, Drake doesn't install anything related to GCC 12, but if the user
    has chosen to install some GCC 12 libraries but has failed to install all
    of them correctly as a group, Drake's documentation header file parser will
    fail with a libclang-related complaint. Therefore, we'll help the user
    clean up their mess, to avoid apparent Drake build errors."""
    if lsb_release["Codename"] != "jammy":
        # This fixup is only necessary on Jammy.
        return
    if _get_dpkg_version("libgcc-12-dev") is None:
        # GCC 12 is not installed, so we don't need to fix anything.
        return
    for package in ["libstdc++-12-dev", "libgfortran-12-dev"]:
        if _get_dpkg_version(package) is not None:
            continue
        _apt_install(package_names=[package], yes=yes)


def _setup_user_environment(*, lsb_release):
    """Writes user environment prerequisites for source builds of Drake."""
    # Write out the bazel configuration.
    workspace_dir = _MY_DIR.parent.parent
    (workspace_dir / "gen").mkdir(exist_ok=True)
    bazelrc = workspace_dir / "gen/environment.bazelrc"
    logging.info(f"Writing {str(bazelrc)} ...")
    bazelrc.write_text(
        textwrap.dedent(
            f"""\
            import %workspace%/tools/ubuntu.bazelrc
            import %workspace%/tools/ubuntu-{lsb_release["Codename"]}.bazelrc
            """
        ),
        encoding="utf-8",
    )

    # If the user mistakenly ran 'install_prereqs' under sudo, fix ownership
    # of the the generated file to match their actual user.
    if os.geteuid() == 0 and os.environ.get("SUDO_USER") is not None:
        stat = os.stat(__file__)
        os.chown(path=bazelrc, uid=stat.st_uid, gid=stat.st_gid)

    # Prefetch the bazelisk download of bazel. (This is especially helpful for
    # the "Provisioned" images in CI.)
    if os.geteuid() == 0:
        logging.warning("Not pre-fetching bazel for root user.")
    else:
        _run(args=["bazel", "version"], cwd=str(workspace_dir), quiet=True)


def _read_flavor_cookie(*, flavor_lookup) -> str:
    """Returns the most recently-installed flavor cookie (reading from disk),
    or None when unknown."""
    workspace_dir = _MY_DIR.parent.parent
    cookie = workspace_dir / "gen/install_prereqs.flavor"
    try:
        text = cookie.read_text(encoding="utf-8").strip()
    except IOError:
        logging.debug("No flavor cookie found.")
        return None
    # Confirm the prior text is still a valid flavor.
    if text not in flavor_lookup:
        logging.warning(f"Ignoring no-longer-valid flavor '{text}'")
        return None
    logging.info(f"Assuming --flavor={text} per most recent run.")
    return text


def _update_flavor_cookie(*, flavor: Flavor) -> None:
    """Updates (on disk) the most recently-installed flavor cookie.
    For developers this writes a cookie file with the selected flavor.
    For users, this deletes the cookie."""
    workspace_dir = _MY_DIR.parent.parent
    cookie = workspace_dir / "gen/install_prereqs.flavor"
    if flavor >= Flavor.DEVELOPER:
        logging.debug(f"Writing flavor cookie to {cookie}")
        flavor_lower = flavor.name.lower()
        cookie.write_text(f"{flavor_lower}\n")
    else:
        try:
            cookie.unlink()
            logging.debug(f"Removed flavor cookie {cookie}")
        except IOError:
            pass


def main():
    # Decide which flavors to offer.
    if _MY_DIR.name == "ubuntu":
        # We are in the source tree; all flavors are valid.
        flavor_lookup = dict((item.name.lower(), item) for item in Flavor)
        default_flavor = "build"
    else:
        # Not the source tree. We're a binary package install.
        flavor_lookup = {"binary": Flavor.BINARY}
        default_flavor = "binary"

    # Create the help string for flavors.
    help_details = ""
    if len(flavor_lookup) > 1:
        help_details = "\nThe available flavors of prerequisites are:\n"
        help_details += "\n".join(
            [
                f"- {name}: {value.description}."
                for name, value in flavor_lookup.items()
            ]
        )
        help_details += "\n\n"
        help_details += "Each flavor also incoroporates all prior flavors."

    parser = argparse.ArgumentParser(
        description=__doc__ + help_details,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "-y",
        action="store_true",
        dest="yes",
        help="Install without prompting for confirmation.",
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbosity.",
    )
    parser.add_argument(
        "--__only_user_environment", action="store_true",
        help=argparse.SUPPRESS,
    )
    parser.add_argument(
        "--flavor",
        choices=flavor_lookup.keys(),
        default=None,
        help=(
            "Which set of prerequisites to install. See descriptions above."
            if len(flavor_lookup) > 1
            else argparse.SUPPRESS
        ),
    )
    for lower in flavor_lookup:
        parser.add_argument(
            f"--{lower}",
            action="store_const",
            const=lower,
            dest="flavor",
            help=(
                f"Shortcut for --flavor={lower}."
                if len(flavor_lookup) > 1
                else argparse.SUPPRESS
            ),
        )
    args = parser.parse_args()
    is_root = os.geteuid() == 0

    # Choose which flavor to install:
    # (1) The command line always takes priority.
    # (2) When not given on the command line, and not running as root, and
    #     not running from a binary install, a per-user cookie file is used
    #     for developers to make the choice be "sticky".
    # (3) Otherwise, a nominal value is selected.
    flavor_lower = args.flavor
    if flavor_lower is None and not is_root and len(flavor_lookup) > 1:
        flavor_lower = _read_flavor_cookie(flavor_lookup=flavor_lookup)
    if flavor_lower is None:
        logging.info(f"Using default --flavor={default_flavor}.")
        flavor_lower = default_flavor
    args.flavor = flavor_lookup[flavor_lower]

    # Prepare for installation.
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    _maybe_warn_conda()
    if args.flavor >= Flavor.DEVELOPER and is_root:
        logging.warning(
            "Do NOT run install_prereqs as root or under sudo when using "
            "--flavor=developer or greater."
        )
    lsb_release = _check_lsb_release()

    # Deprecation shim until 2025-06-01.
    if args.__only_user_environment:
        _setup_user_environment(lsb_release=lsb_release)
        return

    # Install the prerequisites.
    _apt_install_flavor(
        lsb_release=lsb_release,
        flavor=args.flavor,
        yes=args.yes,
    )
    if args.flavor >= Flavor.DEVELOPER:
        _dpkg_install_bazelisk()

    # Configure the prerequisites.
    if args.flavor >= Flavor.BUILD:
        _setup_usr_bin_python(yes=args.yes)
        _setup_locales()
        _maybe_setup_gcc12(lsb_release=lsb_release, yes=args.yes)
    if args.flavor >= Flavor.DEVELOPER:
        _setup_user_environment(lsb_release=lsb_release)

    # Finished.
    if not is_root:
        _update_flavor_cookie(flavor=args.flavor)
    logging.info(f"Successfully installed --flavor={flavor_lower} prereqs.")


if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format="%(levelname)s: %(message)s",
    )
    main()
