"""Conducts integration tests by exercising the entire RPC pipeline that
contains a render client and a render server.  The tests then inspect the
generated images or glTF files by comparing them with the expected output.

As different renderers may have various rounding errors or subtle lighting
settings, two heuristic thresholds are applied, i.e., a per-pixel threshold for
each image type and an overall percentage threshold for invalid pixels.

Two images are considered close enough if the majority of the pixels are within
the per-pixel threshold.  The ground truth images are generated by
RenderEngineVtk.

For glTF comparison, the generated glTFs are compared against a carefully
inspected ground truth glTF file.  Some entries not in the scope of the glTF
test are replaced with placeholders to make the file size minimal.

See `Testing of the client-server RPC pipeline` section in the README file for
more information.
"""

import copy
import json
import os
import re
import subprocess
import sys
import unittest

from bazel_tools.tools.python.runfiles.runfiles import Create as CreateRunfiles
import numpy as np
from PIL import Image

COLOR_PIXEL_THRESHOLD = 20  # RGB pixel value tolerance.
DEPTH_PIXEL_THRESHOLD = 0.001  # Depth measurement tolerance in meters.
LABEL_PIXEL_THRESHOLD = 0
INVALID_PIXEL_FRACTION = 0.2


class TestIntegration(unittest.TestCase):
    def setUp(self):
        self.runfiles = CreateRunfiles()
        self.tmp_dir = os.environ.get("TEST_TMPDIR", "/tmp")

        server_demo = self.runfiles.Rlocation(
            "drake/geometry/render_gltf_client/server_demo"
        )

        # Start the server on the other process. Bind to port 0 and let the OS
        # assign an available port later on.
        server_args = [
            server_demo,
            "--host=127.0.0.1",
            "--port=0",
        ]
        self.server_proc = subprocess.Popen(
            server_args,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
        )

        # Wait to hear which port it's using.
        self.server_port = None
        while self.server_port is None:
            line = self.server_proc.stdout.readline().decode("utf-8")
            print(f"[server] {line}", file=sys.stderr, end="")
            match = re.search(r"Running on http://127.0.0.1:([0-9]+)", line)
            if match:
                (self.server_port,) = match.groups()

    def tearDown(self):
        self.server_proc.kill()

    def run_render_client(self, renderer, cleanup=True):
        """Invokes the client process to send rendering requests.  If cleanup
        is set to false, the client will keep the intermediate glTF files (and
        the images).
        """
        client_demo = self.runfiles.Rlocation(
            "drake/geometry/render_gltf_client/client_demo"
        )
        save_dir = os.path.join(self.tmp_dir, renderer)
        os.makedirs(save_dir, exist_ok=True)

        render_args = [
            client_demo,
            f"--render_engine={renderer}",
            "--simulation_time=0.1",
            f"--cleanup={cleanup}",
            f"--save_dir={save_dir}",
            f"--server_base_url=127.0.0.1:{self.server_port}",
        ]
        result = subprocess.run(
            render_args,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            encoding="utf-8",
        )
        if result.returncode != 0:
            for line in result.stdout.splitlines():
                print(f"[client] {line}", file=sys.stderr)
        result.check_returncode()
        return result

    def get_demo_image_paths(self, renderer):
        """Returns the curated image paths.  The output folder is assumed to
        contain at least 2 sets of color, depth, and label images for
        inspection.
        """
        save_dir = os.path.join(self.tmp_dir, renderer)

        image_sets = []
        for index in range(2):
            image_set = [
                f"{save_dir}/color_{index:03d}.png",
                f"{save_dir}/depth_{index:03d}.tiff",
                f"{save_dir}/label_{index:03d}.png",
            ]
            image_sets.append(image_set)
        return image_sets

    def get_gltf_path_pairs(self, gltf_file_dir):
        """Returns pairs of generated and ground truth glTF files for each
        image type for inspection.
        """
        gltf_path_pairs = []
        for index, image_type in enumerate(["color", "depth", "label"]):
            gltf_path = f"{gltf_file_dir}/{index+1:019d}-{image_type}.gltf"
            ground_truth_gltf = self.runfiles.Rlocation(
                "drake/geometry/render_gltf_client/test/"
                f"test_{image_type}_scene.gltf"
            )
            gltf_path_pairs.append((gltf_path, ground_truth_gltf))
        return gltf_path_pairs

    def assert_error_fraction_less(self, image_diff, fraction):
        image_diff_fraction = np.count_nonzero(image_diff) / image_diff.size
        self.assertLess(image_diff_fraction, fraction)

    _REPLACED = {
        "bufferView": "bufferViews",
        "camera": "cameras",
        "index": "textures",
        "indices": "accessors",
        "material": "materials",
        "mesh": "meshes",
        "sampler": "samplers",
        "source": "images",
        "POSITION": "accessors",
        "TEXCOORD_0": "accessors",
    }
    """The dict keys that their values should be replaced with actual data. """

    _IGNORED = ["buffer", "name"]
    """The dict keys that are order-dependent and should be ignored. """

    def _get_or_replace_value(self, gltf, keys, value=None):
        """Retrieves the data through a list of keys in a nested dict. If
        `value` is not provided, the function will iterate to the leaf node and
        return. Otherwise, the leaf node will be updated but return at the
        second-to-last layer.
        """
        entry = gltf
        for key in keys[:-1]:
            entry = entry[key]

        if value:
            entry[keys[-1]] = value
        else:
            entry = entry[keys[-1]]
        return entry

    def _traverse_and_mutate_recursively(self, gltf, keys):
        """The glTF entries usually contain indices that point to another
        entry. This function traverses through the dictionary recursively and
        replaces the indices with the actual data.
        """
        entry = self._get_or_replace_value(gltf, keys)
        entry_type = type(entry)
        if entry_type == dict:
            for k, v in entry.items():
                # Replace the index with the actual pointed data structure.
                if k in self._REPLACED.keys():
                    self._get_or_replace_value(
                        gltf, keys + [k], gltf[self._REPLACED[k]][v]
                    )
                elif k in self._IGNORED:
                    self._get_or_replace_value(gltf, keys + [k], "IGNORED")
                self._traverse_and_mutate_recursively(gltf, keys + [k])
        elif entry_type == list:
            if not all(isinstance(x, (int, float, str)) for x in entry):
                for index, _ in enumerate(entry):
                    self._traverse_and_mutate_recursively(gltf, keys + [index])

    def _fuzz_data_and_restructure(self, gltf):
        """Restructures the glTF by fuzzing irrelevant entries and unlinking
        the internal references to produce an order-agnostic dict for
        comparison.
        """
        result = copy.deepcopy(gltf)

        # The `buffers` entry encodes all the raw data, e.g., textures and
        # UV-coordinates, and is fuzzed out for comparison.
        result["buffers"] = "IGNORED"

        self._traverse_and_mutate_recursively(result, ["nodes"])
        return result

    def _check_one_gltf(self, gltf, ground_truth_gltf):
        actual = self._fuzz_data_and_restructure(gltf)
        expected = self._fuzz_data_and_restructure(ground_truth_gltf)

        # Compare each entry by their types. Note that `nodes` entry has
        # combined information for the rest of the entries, e.g., meshes,
        # cameras, materials, textures, accessors, etc.
        self.assertEqual(actual["scene"], expected["scene"])
        self.assertDictEqual(actual["asset"], expected["asset"])
        for entry in ["scenes", "nodes"]:
            self.assertCountEqual(actual[entry], expected[entry])

    def test_integration(self):
        """Quantitatively compares the images rendered by RenderEngineVtk and
        RenderEngineGltfClient via a fully exercised RPC pipeline.
        """
        self.run_render_client("vtk")
        vtk_image_sets = self.get_demo_image_paths("vtk")
        self.run_render_client("client")
        client_image_sets = self.get_demo_image_paths("client")

        for vtk_image_paths, client_image_paths in zip(
            vtk_image_sets, client_image_sets
        ):
            # Load the images and convert them to numpy arrays.
            vtk_color, vtk_depth, vtk_label = (
                np.array(Image.open(image_path))
                for image_path in vtk_image_paths
            )
            client_color, client_depth, client_label = (
                np.array(Image.open(image_path))
                for image_path in client_image_paths
            )

            # Convert uint8 images to float data type to avoid overflow during
            # calculation.
            color_diff = (
                np.absolute(
                    vtk_color.astype(float) - client_color.astype(float)
                )
                > COLOR_PIXEL_THRESHOLD
            )
            self.assert_error_fraction_less(color_diff, INVALID_PIXEL_FRACTION)

            # Set the infinite values in depth images to zero.
            vtk_depth[~np.isfinite(vtk_depth)] = 0.0
            client_depth[~np.isfinite(client_depth)] = 0.0
            depth_diff = (
                np.absolute(vtk_depth - client_depth) > DEPTH_PIXEL_THRESHOLD
            )
            self.assert_error_fraction_less(depth_diff, INVALID_PIXEL_FRACTION)

            label_diff = (
                np.absolute(vtk_label - client_label) > LABEL_PIXEL_THRESHOLD
            )
            self.assert_error_fraction_less(label_diff, INVALID_PIXEL_FRACTION)

    def test_gltf_conversion(self):
        """Checks that the fundamental structure of the generated glTF files is
        preserved.  The comparison of the exact texture information is not in
        the test's scope and is covered in the integration test above.
        """
        result = self.run_render_client("client", cleanup=False)

        # Scrape the directory for the glTF files.
        gltf_file_dir = None
        for line in result.stdout.splitlines():
            print(f"[client] {line}", file=sys.stderr)
            match = re.search(
                r".* scene exported to '(.*)/[0-9]+-color.gltf'", line
            )
            if match:
                (gltf_file_dir,) = match.groups()
                break
        self.assertIsNotNone(gltf_file_dir)

        # Iterate through each gltf file to compare against the ground truth.
        for gltf_path, ground_truth_gltf_path in self.get_gltf_path_pairs(
            gltf_file_dir
        ):
            with open(gltf_path, "r") as f:
                gltf = json.load(f)
            with open(ground_truth_gltf_path, "r") as g:
                ground_truth_gltf = json.load(g)
            with self.subTest(gltf_path=os.path.basename(gltf_path)):
                self._check_one_gltf(gltf, ground_truth_gltf)
