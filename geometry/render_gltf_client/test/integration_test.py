"""Conducts integration tests by exercising the entire RPC pipeline that
contains a render client and a render server.  The tests then inspect the
generated images or glTF files by comparing them with the expected output.

As different renderers may have various rounding errors or subtle lighting
settings, two heuristic thresholds are applied, i.e., a per-pixel threshold for
each image type and an overall percentage threshold for invalid pixels.

Two images are considered close enough if 90% of the pixels are within the
per-pixel threshold.  The ground truth images are generated by RenderEngineVtk.
"""

import glob
from multiprocessing import Process
import os
import subprocess
import unittest

from bazel_tools.tools.python.runfiles.runfiles import Create as CreateRunfiles
import numpy as np
from PIL import Image

from drake.geometry.render_gltf_client.test.server_demo import app

COLOR_PIXEL_THRESHOLD = 20  # RGB pixel value tolerance.
DEPTH_PIXEL_THRESHOLD = 0.001  # Depth measurement tolerance in meters.
LABEL_PIXEL_THRESHOLD = 0
INVALID_PIXEL_PERCENTAGE = 0.1

# TODO(zachfang): Add another test for glTF verification.


def run_server(host="127.0.0.1", port=8000):
    app.run(host=host, port=port)


class TestIntegration(unittest.TestCase):
    def setUp(self):
        self.runfiles = CreateRunfiles()
        # Start the server on the other process.
        self.server_proc = Process(target=run_server)
        self.server_proc.start()

    def tearDown(self):
        if self.server_proc is not None:
            self.server_proc.kill()

    def test_integration(self):
        tmp_dir = os.path.join(
            os.environ.get("TEST_TMPDIR", "/tmp"), "integration_test"
        )
        vtk_dir = os.path.join(tmp_dir, "vtk")
        os.makedirs(vtk_dir, exist_ok=True)
        client_dir = os.path.join(tmp_dir, "client")
        os.makedirs(client_dir, exist_ok=True)

        client_demo = self.runfiles.Rlocation(
            "drake/geometry/render_gltf_client/client_demo"
        )

        vtk_args = [
            client_demo,
            "--render_engine",
            "vtk",
            "--simulation_time",
            "0.1",
            "--save_dir",
            vtk_dir,
        ]
        subprocess.run(vtk_args)

        client_args = [
            client_demo,
            "--simulation_time",
            "0.1",
            "--save_dir",
            client_dir,
        ]
        subprocess.run(client_args)

        # Validate the number of the generated image files, i.e., greater than
        # zero and divisible by 3 (color, depth, and label).
        vtk_file_number = len(os.listdir(vtk_dir))
        client_file_number = len(os.listdir(client_dir))
        self.assertTrue(vtk_file_number > 0 and vtk_file_number % 3 == 0)
        self.assertTrue(client_file_number > 0 and client_file_number % 3 == 0)

        # Group images with the same index number for comparison, e.g.,
        # color_00.png, depth_000.tiff, and label_000.png.
        vtk_image_sets = []
        client_image_sets = []
        for index in range(min(vtk_file_number, client_file_number) // 3):
            vtk_image_set = sorted(
                glob.glob(os.path.join(vtk_dir, f"*{index:03d}*"))
            )
            vtk_image_sets.append(vtk_image_set)
            client_image_set = sorted(
                glob.glob(os.path.join(client_dir, f"*{index:03d}*"))
            )
            client_image_sets.append(client_image_set)

        for vtk_image_paths, client_image_paths in zip(
            vtk_image_sets, client_image_sets
        ):
            # Load the images and convert them to numpy arrays.
            vtk_color, vtk_depth, vtk_label = (
                np.array(Image.open(image_path))
                for image_path in vtk_image_paths
            )
            client_color, client_depth, client_label = (
                np.array(Image.open(image_path))
                for image_path in client_image_paths
            )

            color_diff = (
                np.absolute(vtk_color - client_color) > COLOR_PIXEL_THRESHOLD
            )
            color_diff_percentage = (
                np.count_nonzero(color_diff) / color_diff.size
            )
            self.assertTrue(color_diff_percentage < INVALID_PIXEL_PERCENTAGE)

            # Set the infinite values in depth images to zero.
            vtk_depth[~np.isfinite(vtk_depth)] = 0.0
            client_depth[~np.isfinite(client_depth)] = 0.0

            depth_diff = (
                np.absolute(vtk_depth - client_depth) > DEPTH_PIXEL_THRESHOLD
            )
            depth_diff_percentage = (
                np.count_nonzero(depth_diff) / depth_diff.size
            )
            self.assertTrue(depth_diff_percentage < INVALID_PIXEL_PERCENTAGE)

            label_diff = (
                np.absolute(vtk_label - client_label) > LABEL_PIXEL_THRESHOLD
            )
            label_diff_percentage = (
                np.count_nonzero(label_diff) / label_diff.size
            )
            self.assertTrue(label_diff_percentage < INVALID_PIXEL_PERCENTAGE)
