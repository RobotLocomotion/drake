"""Conducts integration tests by exercising the entire RPC pipeline that
contains a render client and a render server.  The tests then inspect the
generated images or glTF files by comparing them with the expected output.

As different renderers may have various rounding errors or subtle lighting
settings, two heuristic thresholds are applied, i.e., a per-pixel threshold for
each image type and an overall percentage threshold for invalid pixels.

Two images are considered close enough if the majority of the pixels are within
the per-pixel threshold.  The ground truth images are generated by
RenderEngineVtk.

For glTF comparison, the generated glTFs are compared against a carefully
inspected ground truth glTF file.  Some entries not in the scope of the glTF
test are replaced with placeholders to make the file size minimal.

See `Testing of the client-server RPC pipeline` section in the README file for
more information.
"""

import copy
import json
import os
import re
import subprocess
import sys
import unittest

from bazel_tools.tools.python.runfiles.runfiles import Create as CreateRunfiles
import numpy as np
from PIL import Image

COLOR_PIXEL_THRESHOLD = 20  # RGB pixel value tolerance.
DEPTH_PIXEL_THRESHOLD = 0.001  # Depth measurement tolerance in meters.
LABEL_PIXEL_THRESHOLD = 0
INVALID_PIXEL_FRACTION = 0.5


class TestIntegration(unittest.TestCase):
    def setUp(self):
        self.runfiles = CreateRunfiles()
        self.tmp_dir = os.environ.get("TEST_TMPDIR", "/tmp")

        server_demo = self.runfiles.Rlocation(
            "drake/geometry/render_gltf_client/server_demo"
        )

        # Start the server on the other process. Bind to port 0 and let the OS
        # assign an available port later on.
        server_args = [
            server_demo,
            "--host=127.0.0.1",
            "--port=0",
        ]
        self.server_proc = subprocess.Popen(
            server_args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
        )

        # Wait to hear which port it's using.
        self.server_port = None
        while self.server_port is None:
            line = self.server_proc.stdout.readline().decode("utf-8")
            print(f"[server] {line}", file=sys.stderr, end="")
            match = re.search(r"Running on http://127.0.0.1:([0-9]+)", line)
            if match:
                (self.server_port,) = match.groups()

    def tearDown(self):
        self.server_proc.kill()

    def run_render_client(self, renderer, cleanup=True):
        """Invokes the client process to send rendering requests.  If cleanup
        is set to false, the client will keep the intermediate glTF files (and
        the images).
        """
        client_demo = self.runfiles.Rlocation(
            "drake/geometry/render_gltf_client/client_demo"
        )
        save_dir = os.path.join(self.tmp_dir, renderer)
        os.makedirs(save_dir, exist_ok=True)

        render_args = [
            client_demo,
            f"--render_engine={renderer}",
            "--simulation_time=0.1",
            f"--cleanup={cleanup}",
            f"--save_dir={save_dir}",
            f"--server_base_url=127.0.0.1:{self.server_port}",
        ]
        result = subprocess.run(
            render_args,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            encoding="utf-8",
        )
        if result.returncode != 0:
            for line in result.stdout.splitlines():
                print(f"[client] {line}", file=sys.stderr)
        result.check_returncode()
        return result

    def get_demo_image_paths(self, renderer):
        """Returns the curated image paths.  The output folder is assumed to
        contain at least 2 sets of color, depth, and label images for
        inspection.
        """
        save_dir = os.path.join(self.tmp_dir, renderer)

        image_sets = []
        for index in range(2):
            image_set = [
                f"{save_dir}/color_{index:03d}.png",
                f"{save_dir}/depth_{index:03d}.tiff",
                f"{save_dir}/label_{index:03d}.png",
            ]
            image_sets.append(image_set)
        return image_sets

    def get_gltf_paths(self, gltf_file_dir):
        """Returns one glTF file for each image type for inspection."""
        return [
            f"{gltf_file_dir}/{1:019d}-color.gltf",
            f"{gltf_file_dir}/{2:019d}-depth.gltf",
            f"{gltf_file_dir}/{3:019d}-label.gltf",
        ]

    def assert_error_fraction_less(self, image_diff, fraction):
        image_diff_fraction = np.count_nonzero(image_diff) / image_diff.size
        self.assertLess(image_diff_fraction, fraction)

    def _fuzz_irrelevant_data(self, gltf, is_color_image):
        """Replaces irrelevant entries and returns the processed glTF dict for
        comparison.
        """
        result = copy.deepcopy(gltf)

        # These two entries encode the exact texture information and are
        # ignored for all image types.
        for entry in ["buffers", "bufferViews"]:
            result[entry] = "IGNORED"

        # These entries contain basic material properties, e.g., RGBA, and are
        # only relevant for color image comparison.
        if not is_color_image:
            for entry in [
                "accessors",
                "images",
                "materials",
                "samplers",
                "textures",
            ]:
                result[entry] = "IGNORED"
        return result

    def _check_one_gltf(self, gltf, ground_truth_gltf, is_color_image):
        actual = self._fuzz_irrelevant_data(gltf, is_color_image)
        expected = self._fuzz_irrelevant_data(
            ground_truth_gltf, is_color_image
        )
        # Check the glTF-related section in README for some troubleshooting
        # tips if this test failed.
        self.assertDictEqual(expected, actual)

    def test_integration(self):
        """Quantitatively compares the images rendered by RenderEngineVtk and
        RenderEngineGltfClient via a fully exercised RPC pipeline.
        """
        self.run_render_client("vtk")
        vtk_image_sets = self.get_demo_image_paths("vtk")
        self.run_render_client("client")
        client_image_sets = self.get_demo_image_paths("client")

        for vtk_image_paths, client_image_paths in zip(
            vtk_image_sets, client_image_sets
        ):
            # Load the images and convert them to numpy arrays.
            vtk_color, vtk_depth, vtk_label = (
                np.array(Image.open(image_path))
                for image_path in vtk_image_paths
            )
            client_color, client_depth, client_label = (
                np.array(Image.open(image_path))
                for image_path in client_image_paths
            )

            # Convert uint8 images to float data type to avoid overflow during
            # calculation.
            color_diff = (
                np.absolute(
                    vtk_color.astype(float) - client_color.astype(float)
                )
                > COLOR_PIXEL_THRESHOLD
            )
            self.assert_error_fraction_less(color_diff, INVALID_PIXEL_FRACTION)

            # Set the infinite values in depth images to zero.
            vtk_depth[~np.isfinite(vtk_depth)] = 0.0
            client_depth[~np.isfinite(client_depth)] = 0.0
            depth_diff = (
                np.absolute(vtk_depth - client_depth) > DEPTH_PIXEL_THRESHOLD
            )
            self.assert_error_fraction_less(depth_diff, INVALID_PIXEL_FRACTION)

            label_diff = (
                np.absolute(vtk_label - client_label) > LABEL_PIXEL_THRESHOLD
            )
            self.assert_error_fraction_less(label_diff, INVALID_PIXEL_FRACTION)

    def test_gltf_conversion(self):
        """Checks that the fundamental structure of the generated glTF files is
        preserved.  The comparison of the exact texture information is not in
        the test's scope and is covered in the integration test above.
        """
        result = self.run_render_client("client", cleanup=False)

        ground_truth_gltf_path = self.runfiles.Rlocation(
            "drake/geometry/render_gltf_client/test/ground_truth.gltf"
        )

        # Scrape the directory for the glTF files.
        gltf_file_dir = None
        for line in result.stdout.splitlines():
            print(f"[client] {line}", file=sys.stderr)
            match = re.search(
                r".* scene exported to '(.*)/[0-9]+-color.gltf'", line
            )
            if match:
                (gltf_file_dir,) = match.groups()
                break
        self.assertIsNotNone(gltf_file_dir)

        with open(ground_truth_gltf_path, "r") as gt:
            ground_truth_gltf = json.load(gt)

        # Iterate through each gltf file to compare against the ground truth.
        for gltf_path in self.get_gltf_paths(gltf_file_dir):
            is_color_image = "color.gltf" in gltf_path
            with open(gltf_path, "r") as f:
                gltf = json.load(f)
            with self.subTest(gltf_path=os.path.basename(gltf_path)):
                self._check_one_gltf(gltf, ground_truth_gltf, is_color_image)
