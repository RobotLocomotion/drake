"""Conducts integration tests by exercising the entire RPC pipeline that
contains a render client and a render server.  The tests then inspect the
generated images or glTF files by comparing them with the expected output.

As different renderers may have various rounding errors or subtle lighting
settings, two heuristic thresholds are applied, i.e., a per-pixel threshold for
each image type and an overall percentage threshold for invalid pixels.

Two images are considered close enough if the majority of the pixels are within
the per-pixel threshold.  The ground truth images are generated by
RenderEngineVtk.

For glTF comparison, the generated glTFs are compared against a carefully
inspected ground truth glTF file.  Some entries not in the scope of the glTF
test are replaced with placeholders to make the file size minimal.

See `Testing of the client-server RPC pipeline` section in the README file for
more information.
"""

import copy
import json
import os
import re
import subprocess
import sys
import unittest

from bazel_tools.tools.python.runfiles.runfiles import Create as CreateRunfiles
import numpy as np
from PIL import Image

COLOR_PIXEL_THRESHOLD = 20  # RGB pixel value tolerance.
DEPTH_PIXEL_THRESHOLD = 0.001  # Depth measurement tolerance in meters.
LABEL_PIXEL_THRESHOLD = 0
INVALID_PIXEL_FRACTION = 0.5


class TestIntegration(unittest.TestCase):
    def setUp(self):
        self.runfiles = CreateRunfiles()
        self.tmp_dir = os.environ.get("TEST_TMPDIR", "/tmp")

        server_demo = self.runfiles.Rlocation(
            "drake/geometry/render_gltf_client/server_demo"
        )

        # Start the server on the other process. Bind to port 0 and let the OS
        # assign an available port later on.
        server_args = [
            server_demo,
            "--host=127.0.0.1",
            "--port=0",
        ]
        self.server_proc = subprocess.Popen(
            server_args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
        )

        # Wait to hear which port it's using.
        self.server_port = None
        while self.server_port is None:
            line = self.server_proc.stdout.readline().decode("utf-8")
            print(f"[server] {line}", file=sys.stderr, end="")
            match = re.search(r"Running on http://127.0.0.1:([0-9]+)", line)
            if match:
                (self.server_port,) = match.groups()

    def tearDown(self):
        self.server_proc.kill()

    def run_render_client(self, renderer, cleanup=True):
        """Invokes the client process to send rendering requests.  If cleanup
        is set to false, the client will keep the intermediate glTF files (and
        the images).
        """
        client_demo = self.runfiles.Rlocation(
            "drake/geometry/render_gltf_client/client_demo"
        )
        save_dir = os.path.join(self.tmp_dir, renderer)
        os.makedirs(save_dir, exist_ok=True)

        render_args = [
            client_demo,
            f"--render_engine={renderer}",
            "--simulation_time=0.1",
            f"--cleanup={cleanup}",
            f"--save_dir={save_dir}",
            f"--server_base_url=127.0.0.1:{self.server_port}",
        ]
        result = subprocess.run(
            render_args,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            encoding="utf-8",
        )
        if result.returncode != 0:
            for line in result.stdout.splitlines():
                print(f"[client] {line}", file=sys.stderr)
        result.check_returncode()
        return result

    def get_demo_image_paths(self, renderer):
        """Returns the curated image paths.  The output folder is assumed to
        contain at least 2 sets of color, depth, and label images for
        inspection.
        """
        save_dir = os.path.join(self.tmp_dir, renderer)

        image_sets = []
        for index in range(2):
            image_set = [
                f"{save_dir}/color_{index:03d}.png",
                f"{save_dir}/depth_{index:03d}.tiff",
                f"{save_dir}/label_{index:03d}.png",
            ]
            image_sets.append(image_set)
        return image_sets

    def get_gltf_paths(self, gltf_file_dir):
        """Returns one glTF file for each image type for inspection."""
        return [
            f"{gltf_file_dir}/{1:019d}-color.gltf",
            f"{gltf_file_dir}/{2:019d}-depth.gltf",
            f"{gltf_file_dir}/{3:019d}-label.gltf",
        ]

    def assert_error_fraction_less(self, image_diff, fraction):
        image_diff_fraction = np.count_nonzero(image_diff) / image_diff.size
        self.assertLess(image_diff_fraction, fraction)

    def _fuzz_irrelevant_data(self, gltf, is_color_image):
        """Replaces irrelevant entries and returns the processed glTF dict for
        comparison.
        """
        result = copy.deepcopy(gltf)

        # These two entries encode the exact texture information and are
        # ignored for all image types.
        for entry in ["buffers", "bufferViews"]:
            result[entry] = "IGNORED"

        # These entries contain basic material properties, e.g., RGBA, and are
        # only relevant for color image comparison.
        if not is_color_image:
            for entry in [
                "accessors",
                "images",
                "materials",
                "samplers",
                "textures",
            ]:
                result[entry] = "IGNORED"
        return result

    def _check_one_gltf(self, gltf, ground_truth_gltf, is_color_image):
        actual = self._fuzz_irrelevant_data(gltf, is_color_image)
        expected = self._fuzz_irrelevant_data(
            ground_truth_gltf, is_color_image
        )
        self._check_gltf_recursive(expected, actual)

    def _check_gltf_recursive(self, expected, actual, from_key=None):
        """
        Recursively evaluate keys and nested keys of the glTF dictionaries.
        Perform floating point epsilon comparisons where applicable.  Helper
        method for _check_one_gltf in favor of `self.assertDictEqual` since
        floating point comparisons need tolerance checks."""
        __tracebackhide__ = True
        supported_types = (str, dict, list, float, int)
        for item in (expected, actual):
            self.assertTrue(
                isinstance(item, supported_types),
                f"Unexpected type {type(item)} in glTF comparison, this test "
                "needs to be updated to support more than "
                f"{', '.join(str(st) for st in supported_types)}")

        # The types must be equivalent before we can compare their values, with
        # the exception of float vs int (always cast int to float).
        if isinstance(expected, int):
            expected = float(expected)
        if isinstance(actual, int):
            actual = float(actual)
        expected_type = type(expected)
        actual_type = type(actual)
        self.assertEqual(
            actual_type, expected_type,
            f"Error performing glTF validation, cannot compare {actual_type} "
            f"with {expected_type}.")

        # For dictionaries assert the keys are equivalent, and then compare
        # each value individually.
        if actual_type == dict:
            # TODO(zachfang): on macOS the expected and actual data contains
            # mismatches related to texture unit coordinates.  Sometimes they
            # are not found in `expected`, sometimes they are different (21 vs
            # 22).  The expected data needs more oversight, for now we just
            # fake the keys that are problematic.  This occurs on on nested
            # dictionaries such as {"POSITION": 20, "TEXCOORD_0": 21}.  Some
            # examples `expected` has only POSITION, some examples both
            # `expected` and `actual` have both keys, but different values.
            # In either case, the final mapping to texture units is more or
            # less irrelevant and likely an implementation detail of
            # vtkGLTFExporter that in the bigger picture does not matter.
            if "darwin" in sys.platform:
                for override in {"POSITION", "TEXCOORD_0", "indices"}:
                    if override in expected:
                        actual[override] = expected[override]
                    elif override in actual:
                        expected[override] = actual[override]
            # Compare the dictionary keys first, then nested compare values.
            self.assertEqual(
                expected.keys(),
                actual.keys(),
                f"glTF dictionary keys do not match.  Expected: "
                f"{sorted(expected.keys())}, got: {sorted(actual.keys())}.")
            for k in expected.keys():
                self._check_gltf_recursive(expected[k], actual[k], from_key=k)
        elif actual_type == list:
            # NOTE: do *NOT* sort lists, that will break matrix comparisons.
            # Special treatment for lists that represent matrices.
            if all(isinstance(x, (float, int)) for x in actual):
                # Anything that is less than 1e-12 is set to zero before
                # comparing to prevent overly restrictive comparisons.
                actual_array = np.array(actual)
                expected_array = np.array(expected)
                actual_array[np.abs(actual_array) < 1e-12] = 0.0
                expected_array[np.abs(expected_array) < 1e-12] = 0.0
                np.testing.assert_allclose(actual_array, expected_array)
            else:
                self.assertEqual(len(actual), len(expected))
                for i in range(len(actual)):
                    self._check_gltf_recursive(actual[i], expected[i])
        elif actual_type in (str, int, float):
            # Terminal types should be exactly equal, including int and float.
            # Any float that needs epsilon comparison will be in a matrix
            # handled above, anything hitting this should be exactly equal.
            args = (expected, actual)
            kwargs = {}
            if from_key is not None:
                kwargs["msg"] = f"From key: {from_key}"
            self.assertEqual(*args, **kwargs)

    def test_integration(self):
        """Quantitatively compares the images rendered by RenderEngineVtk and
        RenderEngineGltfClient via a fully exercised RPC pipeline.
        """
        self.run_render_client("vtk")
        vtk_image_sets = self.get_demo_image_paths("vtk")
        self.run_render_client("client")
        client_image_sets = self.get_demo_image_paths("client")

        for vtk_image_paths, client_image_paths in zip(
            vtk_image_sets, client_image_sets
        ):
            # Load the images and convert them to numpy arrays.
            vtk_color, vtk_depth, vtk_label = (
                np.array(Image.open(image_path))
                for image_path in vtk_image_paths
            )
            client_color, client_depth, client_label = (
                np.array(Image.open(image_path))
                for image_path in client_image_paths
            )

            # Convert uint8 images to float data type to avoid overflow during
            # calculation.
            color_diff = (
                np.absolute(
                    vtk_color.astype(float) - client_color.astype(float)
                )
                > COLOR_PIXEL_THRESHOLD
            )
            self.assert_error_fraction_less(color_diff, INVALID_PIXEL_FRACTION)

            # Set the infinite values in depth images to zero.
            vtk_depth[~np.isfinite(vtk_depth)] = 0.0
            client_depth[~np.isfinite(client_depth)] = 0.0
            depth_diff = (
                np.absolute(vtk_depth - client_depth) > DEPTH_PIXEL_THRESHOLD
            )
            self.assert_error_fraction_less(depth_diff, INVALID_PIXEL_FRACTION)

            label_diff = (
                np.absolute(vtk_label - client_label) > LABEL_PIXEL_THRESHOLD
            )
            self.assert_error_fraction_less(label_diff, INVALID_PIXEL_FRACTION)

    @unittest.skipIf("darwin" in sys.platform, "Broken on macOS")
    def test_gltf_conversion(self):
        """Checks that the fundamental structure of the generated glTF files is
        preserved.  The comparison of the exact texture information is not in
        the test's scope and is covered in the integration test above.
        """
        result = self.run_render_client("client", cleanup=False)

        ground_truth_gltf_path = self.runfiles.Rlocation(
            "drake/geometry/render_gltf_client/test/ground_truth.gltf"
        )

        # Scrape the directory for the glTF files.
        gltf_file_dir = None
        for line in result.stdout.splitlines():
            print(f"[client] {line}", file=sys.stderr)
            match = re.search(
                r".* scene exported to '(.*)/[0-9]+-color.gltf'", line
            )
            if match:
                (gltf_file_dir,) = match.groups()
                break
        self.assertIsNotNone(gltf_file_dir)

        with open(ground_truth_gltf_path, "r") as gt:
            ground_truth_gltf = json.load(gt)

        # Iterate through each gltf file to compare against the ground truth.
        for gltf_path in self.get_gltf_paths(gltf_file_dir):
            is_color_image = "color.gltf" in gltf_path
            with open(gltf_path, "r") as f:
                gltf = json.load(f)
            with self.subTest(gltf_path=os.path.basename(gltf_path)):
                self._check_one_gltf(gltf, ground_truth_gltf, is_color_image)
