"""Conducts integration tests by exercising the entire RPC pipeline that
contains a render client and a render server.  The tests then inspect the
generated images or glTF files by comparing them with the expected output.

As different renderers may have various rounding errors or subtle lighting
settings, two heuristic thresholds are applied, i.e., a per-pixel threshold for
each image type and an overall percentage threshold for invalid pixels.

Two images are considered close enough if the majority of the pixels are within
the per-pixel threshold.  The ground truth images are generated by
RenderEngineVtk.

For glTF comparison, the generated glTFs are compared against a carefully
inspected ground truth glTF file.  Some entries, e.g., buffers and bufferViews,
irrelevant to the glTF test, are stripped out to make the file size minimal.
"""

import json
import os
import re
import subprocess
import sys
import unittest

from bazel_tools.tools.python.runfiles.runfiles import Create as CreateRunfiles
import numpy as np
from PIL import Image

COLOR_PIXEL_THRESHOLD = 20  # RGB pixel value tolerance.
DEPTH_PIXEL_THRESHOLD = 0.001  # Depth measurement tolerance in meters.
LABEL_PIXEL_THRESHOLD = 0
INVALID_PIXEL_FRACTION = 0.5


class TestIntegration(unittest.TestCase):
    def setUp(self):
        self.runfiles = CreateRunfiles()
        self.tmp_dir = os.environ.get("TEST_TMPDIR", "/tmp")

        server_demo = self.runfiles.Rlocation(
            "drake/geometry/render_gltf_client/server_demo"
        )

        # Start the server on the other process. Bind to port 0 and let the OS
        # assign an available port later on.
        server_args = [
            server_demo,
            "--host=127.0.0.1",
            "--port=0",
        ]
        self.server_proc = subprocess.Popen(
            server_args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
        )

        # Wait to hear which port it's using.
        self.server_port = None
        while self.server_port is None:
            line = self.server_proc.stdout.readline().decode("utf-8")
            print(f"[server] {line}", file=sys.stderr)
            match = re.search(r"Running on http://127.0.0.1:([0-9]+)", line)
            if match:
                (self.server_port,) = match.groups()

    def tearDown(self):
        self.server_proc.kill()

    def run_render_client(self, renderer, cleanup=True):
        """Invokes the client process to send rendering requests.  If cleanup
        is set to false, the client will keep the intermediate glTF files (and
        the images).
        """
        client_demo = self.runfiles.Rlocation(
            "drake/geometry/render_gltf_client/client_demo"
        )
        save_dir = os.path.join(self.tmp_dir, renderer)
        os.makedirs(save_dir, exist_ok=True)

        render_args = [
            client_demo,
            f"--render_engine={renderer}",
            "--simulation_time=0.1",
            f"--cleanup={cleanup}",
            f"--save_dir={save_dir}",
            f"--server_base_url=127.0.0.1:{self.server_port}",
        ]
        result = subprocess.run(
            render_args,
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            encoding="utf-8",
        )
        return result

    def get_demo_images(self, renderer):
        """Returns the curated image paths.  The output folder is assumed to
        contain at least 2 sets of color, depth, and label images for
        inspection.
        """
        save_dir = os.path.join(self.tmp_dir, renderer)

        image_sets = []
        for index in range(2):
            image_set = [
                f"{save_dir}/color_{index:03d}.png",
                f"{save_dir}/depth_{index:03d}.tiff",
                f"{save_dir}/label_{index:03d}.png",
            ]
            image_sets.append(image_set)
        return image_sets

    def get_gltf_files(self, save_dir):
        """Returns one glTF file for each image type for inspection."""
        return [
            f"{save_dir}/{1:019d}-color.gltf",
            f"{save_dir}/{2:019d}-depth.gltf",
            f"{save_dir}/{3:019d}-label.gltf",
        ]

    def assert_error_fraction_less(self, image_diff, fraction):
        image_diff_fraction = np.count_nonzero(image_diff) / image_diff.size
        self.assertLess(image_diff_fraction, fraction)

    def test_integration(self):
        """Quantitatively compares the images rendered by RenderEngineVtk and
        RenderEngineGltfClient via a fully exercised RPC pipeline.
        """
        self.run_render_client("vtk")
        vtk_image_sets = self.get_demo_images("vtk")
        self.run_render_client("client")
        client_image_sets = self.get_demo_images("client")

        for vtk_image_paths, client_image_paths in zip(
            vtk_image_sets, client_image_sets
        ):
            # Load the images and convert them to numpy arrays.
            vtk_color, vtk_depth, vtk_label = (
                np.array(Image.open(image_path))
                for image_path in vtk_image_paths
            )
            client_color, client_depth, client_label = (
                np.array(Image.open(image_path))
                for image_path in client_image_paths
            )

            # Convert uint8 images to float data type to avoid overflow during
            # calculation.
            color_diff = (
                np.absolute(
                    vtk_color.astype(float) - client_color.astype(float)
                )
                > COLOR_PIXEL_THRESHOLD
            )
            self.assert_error_fraction_less(color_diff, INVALID_PIXEL_FRACTION)

            # Set the infinite values in depth images to zero.
            vtk_depth[~np.isfinite(vtk_depth)] = 0.0
            client_depth[~np.isfinite(client_depth)] = 0.0
            depth_diff = (
                np.absolute(vtk_depth - client_depth) > DEPTH_PIXEL_THRESHOLD
            )
            self.assert_error_fraction_less(depth_diff, INVALID_PIXEL_FRACTION)

            label_diff = (
                np.absolute(vtk_label - client_label) > LABEL_PIXEL_THRESHOLD
            )
            self.assert_error_fraction_less(label_diff, INVALID_PIXEL_FRACTION)

    def test_gltf_conversion(self):
        """Checks that the fundamental structure of the generated glTF files is
        preserved.  The comparison of the exact texture information is not in
        the test's scope and is covered in the integration test above.
        """
        result = self.run_render_client("client", False)

        ground_truth_gltf_file = self.runfiles.Rlocation(
            "drake/geometry/render_gltf_client/test/ground_truth.gltf"
        )

        # Scrape the directory for the glTF files.
        gltf_file_dir = None
        for line in result.stdout.splitlines():
            print(f"[client] {line}", file=sys.stderr)
            match = re.search(
                r".* scene exported to '(.*)/[0-9]+-color.gltf'", line
            )
            if match:
                (gltf_file_dir,) = match.groups()
                break
        self.assertIsNotNone(gltf_file_dir)

        # Iterate through each gltf file to compare against the ground truth.
        gltf_files = self.get_gltf_files(gltf_file_dir)
        with open(ground_truth_gltf_file, "r") as gt:
            ground_truth_gltf = json.load(gt)

            for gltf_file in gltf_files:
                with open(gltf_file, "r") as f:
                    gltf = json.load(f)

                    # These entries define the basic hierarchical structure of
                    # a glTF, the poses of the included geometries, and the
                    # camera properties (intrinsics and extrinsics).
                    for entry in [
                        "scene",
                        "scenes",
                        "nodes",
                        "meshes",
                        "cameras",
                        "asset",
                    ]:
                        self.assertEqual(gltf[entry], ground_truth_gltf[entry])

                    # Texture-related entries are only for glTFs used to render
                    # color images.
                    if "color.gltf" in gltf_file:
                        for entry in ["textures", "images", "samplers"]:
                            self.assertEqual(
                                gltf[entry], ground_truth_gltf[entry]
                            )

                    # `Accessors` entry indicates how to interpret the buffer
                    # data.  For color glTFs, they should be identical.  For
                    # the other two image types, only the length of the array
                    # is checked (the elements inside the array are enumerated
                    # differently).
                    if "color.gltf" in gltf_file:
                        self.assertEqual(
                            gltf["accessors"], ground_truth_gltf["accessors"]
                        )
                    else:
                        self.assertEqual(
                            len(gltf["accessors"]),
                            len(ground_truth_gltf["accessors"]),
                        )
