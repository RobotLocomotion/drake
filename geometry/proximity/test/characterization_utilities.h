#pragma once

/* @file A collection of utilities to facilitate proximity query testing. The
 functionality specifically targets proximity queries that are signed distance
 (or equivalent to signed distance). It allows for compact representation of
 test scenarios with outcome expectations and provides the common code to
 exercise the various proximity queries. It is the expectation that these
 utilities will be exercised by each set of *callback* unit tests, providing
 correctness coverage and characterization of the query's "quality".  */

#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

#include <fcl/fcl.h>
#include <gtest/gtest.h>

#include "drake/common/default_scalars.h"
#include "drake/common/unused.h"
#include "drake/geometry/proximity/collision_filter_legacy.h"
#include "drake/math/rigid_transform.h"

namespace drake {
namespace geometry {
namespace internal {

/* The base class defining a self-contained wrapper for distance-related
 callbacks. To test a single callback, this class should be derived and
 implemented with the details of the particular callback and its callback data
 hidden as implementation details.  */
template <typename T>
class DistanceCallback {
 public:
  virtual ~DistanceCallback() = default;

  /* Invokes the underlying callback for the given data. This invocation will
   append any reports to the persistent set of stored results. The caller is
   responsible for calling ClearResults() if it wants the results of this
   invocation to be distinct from other invocations. */
  virtual bool Invoke(
      fcl::CollisionObjectd*, fcl::CollisionObjectd*,
      const CollisionFilterLegacy*,
      const std::unordered_map<GeometryId, math::RigidTransform<T>>*) = 0;

  /* Forces all results to be cleared. */
  virtual void ClearResults() = 0;

  /* Reports the number of results generated by the last call to Invoke(). */
  virtual int GetNumResults() const = 0;

  /* Reports the distance contained in the first result.
   @pre GetNumResults() > 0. */
  virtual T GetFirstSignedDistance() const = 0;
};

/* Reports the expected outcome for a characterized result test. If can_compute
 is true, `max_error` should be non-negative measure (in meters) which should
 be *near* the worst observed error. If false, `error_message` should be valid.
 */
struct Expectation {
  bool can_compute{};
  double max_error{};
  std::string error_message;
};

/* Defines a test configuration for two shapes: the pose between the two
 shapes, the expected signed_distance, and a description to aid in assessing
 test failure. */
template <typename T>
struct Configuration {
  math::RigidTransform<T> X_AB;
  double signed_distance{};
};

/* Renders an FCL enumeration into a string to support intelligible error
 messages. Note: we're only covering the enumeration values that Drake
 specifically uses.  */
std::string to_string(const fcl::NODE_TYPE& node);

/* @name Fcl geometry from drake shape specifications. */
class MakeFclShape : public ShapeReifier {
 public:
  explicit MakeFclShape(const Shape& shape);

  /* Implementation of ShapeReifier interface  */
  using ShapeReifier::ImplementGeometry;
  void ImplementGeometry(const Sphere& sphere, void*) final;

  std::shared_ptr<fcl::CollisionGeometry<double>> object() const {
    return object_;
  }

 private:
  std::shared_ptr<fcl::CollisionGeometry<double>> object_{};
};

/* This test provides a common framework for testing signed-distance based
 proximity queries. Specifically, it provides *direct* support in populating
 the scalar support/precision table. It indirectly provides the basis for
 showing general mathematical correctness of the query's underlying math.

 This test supports the documented support table in a very specific way. We want
 these characterization tests to detect regression in underlying code, but also
 to detect improvements in the code under test so that the table can be
 updated. When a test fails, it reports whether the expected precision (as
 declared in the specific test) is too high or too low and direct the developer
 to resolve it and update the table in query_object.h as appropriate.

 The tests are formulated to collide two shapes in various configurations. None
 of the configurations are *trivial* -- we want to avoid the case where the
 algorithm can "luck" in to a high precision solution. Instead, we want to test
 it for some vague "typical" case. So, we have no identity poses and non-zero
 translations. The measures of the geometry are values that are not perfectly
 represented in binary (e.g., prefer 1/3 over 1/2). */
template <typename T>
class CharacterizeResultTest : public ::testing::Test {
 public:
  /* Constructs an instance of the test for the given callback implementation.
   */
  explicit CharacterizeResultTest(std::unique_ptr<DistanceCallback<T>> callback)
      : callback_(std::move(callback)) {}

  /* Runs a single instance of the callback for the given collision objects.
   Confirms the computability of the callback against the expectation. If
   expectation.can_compute is true, it confirms the successful execution of the
   query reports a single result. Otherwise, confirms that the callback
   throws with an error matching that contained in the expectation. */
  void RunCallback(
      const Expectation& expectation, fcl::CollisionObjectd* obj_A,
      fcl::CollisionObjectd* obj_B,
      const CollisionFilterLegacy* collision_filter,
      const std::unordered_map<GeometryId, math::RigidTransform<T>>* X_WGs)
      const;

  /* Computes the *absolute* error of the result produced by the last invocation
   of the callback against the given `expected_distance`. If there are no
   results reported, no error is returned.
   @pre expected_distance != 0. */
  std::optional<double> ComputeErrorMaybe(double expected_distance) const;

  /* Runs the test to characterize the query error between geometries of
   two shape types: Shape1 and Shape2. The caller provides one or more
   configuration specifications (including relative poses of the two shapes
   X_AB and the expected signed distance that pose would produce).

   This method transforms the two shapes into the world frame via an arbitrary
   transform X_WA (see corresponding static method). This guarantees that
   we're testing the query under non-trivial transforms. The query is repeated
   twice: once as (A, B) and again as (B, A) for each configuration.

   The expected outcome of the query is contained in the given `expectation`. It
   declares whether the query runs at all (`expectation.can_compute`). If it
   can be computed, error is computed between the returned signed distance and
   the expected signed distance. Across *all* queries, the worst error is
   stored. The worst error can't be too much worse or too much *better* than the
   expected value (`expectation.max_error`) to pass. If the expectation is
   that the query cannot be computed, we confirm an exception with the given
   `expectation`'s error message.

   This test does most of the work to run the test (accumulating and testing
   worst error), but it uses `RunCallback` to execute the callback and assert
   query expectations and `ComputeErrorMaybe` to compute reportable error.

   The test passes if the worst error lies in the interval:

                |    error    |
                |-------------|     e = expectation.max_error
                |             |
               e/2            e

   This gives us a reasonably tight bound on the error.

   If the expected maximum error is "close" to epsilon, we test it against the
   *open* interval:

                    error    |
                -------------|     e = expectation.max_error
                             |
                             3

   If the expected error is already functionally epsilon, than having the worst
   error being smaller than epsilon/2 is no bad thing.

   N.B. This testing strategy is *atypical*. Rather than just asserting the
   answer is no worse than an expected level of precision, we also want to
   confirm that it is no better (the lower bound on the interval). The purpose
   of this test is to detect if the quality of the query improves so that we can
   update the table in query_object.h. Therefore, we want to detect if the
   answers get "too good" and the table in the documentation needs updating.

   It is the responsibility of the caller to define poses X_AB that truly tax
   the underlying code. There are configuration where even badly written code
   can get the correct answer to within machine epsilon. We want to report the
   *worst case* error and the tests should be articulated as such.

   @param expectation  The expectation for the query result.
   @param shape_A      The first shape in the pair.
   @param shape_B      The second shape in the pair.
   @param configs      A collection of test configurations against which we
                       evaluate the callback. */
  void RunCharacterization(const Expectation& expectation, const Shape& shape_A,
                           const Shape& shape_B,
                           const std::vector<Configuration<T>>& configs);

  /* Generates a geometry id for the given collision object, encodes the id
   into the object, and returns the id.  */
  GeometryId EncodeData(fcl::CollisionObjectd* obj);

  /* Returns a collection of transforms to map an experiment expressed in a
   shape A's frame A, to the world frame. The transforms are arbitrary but
   constructed such that the transforms are non-trivial. This is to make sure we
   don't exhibit high precision due to an overly simplified scenario. */
  static std::vector<math::RigidTransform<T>> X_WAs();

  /* @name A consistent set of shapes to use across all tests

   Each method can produce one of two instances of the shape (for doing, e.g.,
   Box-Box tests with two different proportions).

   As documented in query_object.h, at least one measure of each geometry should
   be approximately 20 cm. The other measures (based on shape parameterization)
   have been arbitrarily selected to avoid symmetry and perfectly represented
   numerical values. */
  //@{

  /* As documented in query_object.h, the 2mm distance/depth for which the
   queries are characterized. */
  static constexpr double kDistance{2e-3};

  static Sphere sphere(bool alt = false) {
    unused(alt);
    return Sphere(kDistance * 100);
  }

  //}

 protected:
  CollisionFilterLegacy collision_filter_;
  std::unique_ptr<DistanceCallback<T>> callback_;
};

}  // namespace internal
}  // namespace geometry
}  // namespace drake

DRAKE_DECLARE_CLASS_TEMPLATE_INSTANTIATIONS_ON_DEFAULT_NONSYMBOLIC_SCALARS(
  class ::drake::geometry::internal::CharacterizeResultTest)
