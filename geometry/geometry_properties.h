#pragma once

#include <functional>
#include <memory>
#include <set>
#include <string>
#include <unordered_map>

#include "fmt/ostream.h"
#include <Eigen/Dense>

#include "drake/common/copyable_unique_ptr.h"
#include "drake/common/drake_deprecated.h"
#include "drake/common/never_destroyed.h"
#include "drake/common/unused.h"
#include "drake/common/value.h"
#include "drake/geometry/rgba.h"

namespace drake {
namespace geometry {

/** The base class for defining a set of geometry properties.

 Each property consists of a property name and a typed value. In a set of
 properties, every name must be unique. The only restriction on the value type
 is that it is compatible with AbstractValue.

 A set of geometry property values are defined when geometry is registered
 with SceneGraph by an instantiator and accessed by some downstream consumer
 entity. Each consumer specifies what properties it expects to find and what
 default values (if any) it provides. For example, the consumer could document
 that a particular property is always required and its absence would throw an
 exception. Alternatively, it could indicate that a property is optional
 and a default value will be used in its absence. It is the responsibility of
 the instantiator to make sure that the geometry property values are _correctly_
 defined according to the expected consumer's specification. Correctness
 includes such issues as spelling property names correctly and property values
 having the expected type. Correct spelling includes correct case. The
 instantiator uses the Add() method to add new properties to the set.

 To read the property 'property_name' from a property set:

   1. Optionally test to see if the property exists by calling HasProperty().
      Attempting to access a non-existent property may lead to an exception
      (see API documentation below).
   2. Acquire a property value via the Get() or GetPropertyOrDefault() methods.
      NOTE: Reading a property requires a compile-time declaration of the _type_
      of value being read. If the stored value is of a different type, an
      exception will be thrown.

 <h2>Common workflows</h2>

 The following examples outline a number of ways to create and consume geometry
 properties. By design, %GeometryProperties cannot be constructed,
 copied, or moved directly. Only derived classes can choose to do so. This
 facilitates _strongly typed_ sets of properties associated with particular
 geometry roles. So, for these examples we'll exercise the derived class
 associated with proximity queries: ProximityProperties.

 The string-based structure of %GeometryProperties provides a great deal of
 flexibility at the cost of spelling sensitivity. It would be easy to introduce
 typos that would then "hide" property values in some group a consumer
 wouldn't look. It is critical to confirm that the properties are "spelled"
 correctly.

 <h3>Creating properties</h3>

 <h4>Creating properties in a new group</h4>

 This is a simple example in which a single group is added with properties
 of various types.

 ```
 ProximityProperties properties;
 // This first invocation implicitly creates the group "my_group".
 properties.Add("count", 7);   // int
 properties.Add("length", 7.); // double
 properties.Add("name", "7");  // std::string
 ```

 <h4>Aggregate properties in a struct</h4>

 In some cases, there is a set of values that will _always_ be accessed
 together (specified with coordinated semantics). In these cases, it makes sense
 to aggregate them into a struct and store that as a single value. This reduces
 the number of lookups required.

 It's worth noting, that if the data value is a struct, calls to
 GetPropertyOrDefault() still operate as an "all-or-nothing" basis.
 If the property _struct_ exists, it will be returned, if it's missing the
 default struct will be returned. There is no concept of a "partial" struct
 in which some undefined values in the struct will be replaced with their
 corresponding values in the default struct.

 ```
 struct MyData {
    int i{};
    double d{};
    std::string s;
 };

 ProximityProperties properties;
 MyData data{7, 7., "7"};
 properties.Add("data1", data);
 properties.Add("data2", MyData{6, 6., "6"});
 properties.Add<MyData>("data3", {6, 6., "6"});
 ```

 <h3>Reading properties</h3>

 This section describes how to read properties under several different
 scenarios: (a) when specific properties are required, (b) when the consumer
 provides a default value for missing properties, and (c) when the consumer
 needs to inspect what properties are available.

 <h4>Look up specific, _required_ properties</h4>

 In this case, the consumer of the properties is looking for one or more
 specific properties. It will ignore any other properties. More particularly, if
 those properties are missing, it is considered a runtime error and an exception
 is thrown.

 The error can be handled in one of two ways: simply let the generic exception
 generated by %GeometryProperties propagate upward, or detect the missing
 property and throw an exception with a custom message. The example below shows
 both approaches.

 ```
 const IllustrationProperties& properties = FunctionThatReturnsProperties();
 // Looking for a Rgba-typed value named "rgba" - send generic error that
 // the property set is missing the required property.
 const Rgba rgba = properties.Get<Rgba>("rgba");

 // Explicitly detect missing property and throw exception with custom message.
 if (!properties.HasProperty("rgba")) {
   throw std::logic_error(
       "ThisClass: Missing the necessary 'rgba' property; the object cannot be "
       "rendered");
 }
 // Otherwise acquire value, confident that no exception will be thrown.
 const Rgba rgba = properties.Get<Rgba>("rgba");
 ```

 @note calls to `Get()` always require the return type template value (e.g.,
 `Rgba`) to be specified in the call.

 <h4>Look up specific properties with default property values</h4>

 As with the previous case, the consumer is looking for one or more specific
 properties. However, in this case, the consumer provides a default value to
 use in case the target property is not defined. In this invocation, the
 template parameter need not be explicitly declared -- the inferred return type
 will be the same as the default value.

 ```
 const IllustrationProperties& properties = FunctionThatReturnsProperties();
 // Looking for a Rgba-typed value named "rgba".
 const Rgba default_color{0.9, 0.9, 0.9};
 const Rgba rgba = properties.GetPropertyOrDefault("rgba", default_color);
 ```

 Alternatively, the default value can be provided in one of the following forms:

 ```
 properties.GetPropertyOrDefault("rgba", Rgba{0.9, 0.9, 0.9});
 properties.GetPropertyOrDefault<Rgba>("rgba", {0.9, 0.9, 0.9});
 ```

 <h4>Iterating through provided properties</h4>

 Another alternative is to iterate through the properties that _have_ been
 provided. This might be done for several reasons, e.g.:

   - the consumer wants to validate the set of properties, giving the user
     feedback if an unsupported property has been provided, and/or
   - the consumer has a default value for every property and allows the
     registering code to define only those properties that deviate from the
     specified default.

 Working with properties in this manner requires knowledge of how to work with
 AbstractValue.

 ```
 const IllustrationProperties& properties = FunctionThatReturnsProperties();
 for (const auto& pair : properties.GetProperties() {
   const std::string& name = pair.first;
   if (name == "rgba") {
     // Throws an exception if the named parameter is of the wrong type.
     const Rgba& rgba = pair.second->GetValueOrThrow<Rgba>();
   }
 }
 ```
*/
class GeometryProperties {
 public:
  virtual ~GeometryProperties() = default;

  /** Returns all of the properties in the set.  */
  const std::unordered_map<std::string, copyable_unique_ptr<AbstractValue>>&
  GetAllProperties() const {
    return values_;
  }

  /** Adds a property `value` with the given `name`.

   @param name         The name of the property.
   @param value        The value to assign to the property.
   @throws std::logic_error if `name` is already in use.
   @tparam ValueType   The type of data to store with the attribute -- must be
                       copy constructible or cloneable (see Value).
   @returns A reference to `this` set of properties.  */
  template <typename ValueType>
  GeometryProperties& Add(const std::string& name, const ValueType& value) {
    if constexpr (std::is_same_v<ValueType, Eigen::Vector4d>) {
      return AddAbstract(name, Value(ToRgba(value)));
    } else {
      return AddAbstract(name, Value(value));
    }
  }

  /** Updates the property `value` with the given `name`. If the `name` isn't
   already in use, it is equivalent to calling `Add`. If the `name` is in use,
   its value (which must have the same type as `value`) will be replaced.

   @param name         The name of the property.
   @param value        The value to assign to the property.
   @throws std::logic_error if the property exists with a different type.
   @tparam ValueType   The type of data to store with the attribute -- must be
                       copy constructible or cloneable (see Value).
   @returns A reference to `this` set of properties.  */
  template <typename ValueType>
  GeometryProperties& Update(const std::string& name, const ValueType& value) {
    return UpdateAbstract(name, Value(value));
  }

  /** Adds the property `value` with the given `name`.

   @param name         The name of the property.
   @param value        The value to assign to the property.
   @throws std::logic_error if `name` is already in use.
   @returns A reference to `this` set of properties.  */
  GeometryProperties& AddAbstract(const std::string& name,
                                  const AbstractValue& value);

  /** Updates the property `value` with the given `name`. If the `name` isn't
   already in use, it is equivalent to calling `AddAbstract`. If the `name` is
   in use, its value (which must have the same type as `value`) will be
   replaced.

   @param name         The name of the property.
   @param value        The value to assign to the property.
   @throws std::logic_error if the property exists with a different type.
   @returns A reference to `this` set of properties.  */
  GeometryProperties& UpdateAbstract(const std::string& name,
                                     const AbstractValue& value);

  /** Reports if the property (`group_name`, `name`) exists in the group.

   @param name         The name of the property.
   @returns true iff a property with the given `name` exists.  */
  bool HasProperty(const std::string& name) const;

  /** Retrieves the typed value for the property with the given `name`.

   @param name         The name of the property.
   @throws std::logic_error if the property name is invalid, or
                            the property type is not that specified.
   @tparam ValueType  The expected type of the desired property.
   @returns const ValueType& of the stored value.
            If ValueType is Eigen::Vector4d, the return type will be a copy
            translated from Rgba.
   */
  template <typename ValueType>
  decltype(auto) Get(const std::string& name) const {
    const AbstractValue& abstract = GetAbstract(name);
    if constexpr (std::is_same_v<ValueType, Eigen::Vector4d>) {
      const Rgba color = GetValueOrThrow<Rgba>(
          "Get", name, abstract, NiceTypeName::Get<Eigen::Vector4d>());
      return ToVector4d(color);
    } else {
      return GetValueOrThrow<ValueType>("Get", name, abstract);
    }
  }

  /** Retrieves the type-erased value for the property with the given `name`.

   @param name         The name of the property.
   @throws std::logic_error if `name` isn't found. */
  const AbstractValue& GetAbstract(const std::string& name) const;

  /** Retrieves the typed value for the property with the given `name` (if it
   exists), otherwise returns the given default value. The given `default_value`
   is returned only if the property is missing. If the property exists and is of
   a _different_ type, an exception will be thrown. If it is of the expected
   type, the stored value will be returned.

   Generally, it is unnecessary to explicitly declare the `ValueType` of the
   property value; it will be inferred from the provided default value.
   Sometimes it is convenient to provide the default value in a form that can
   be implicitly converted to the final type. In that case, it is necessary
   to explicitly declare the desired `ValueType` so the compiler does not
   infer the wrong type, e.g.:

   ```
   // Note the _integer_ value as default value would lead to an error if
   // a the value stored with "p" is a double.
   const double my_value = properties.GetPropertyOrDefault<double>("p", 2);
   ```

   @param name           The name of the property.
   @param default_value  The alternate value to return if the property cannot
                         be acquired.
   @throws std::logic_error if a property of the given name exists but is not
                            of `ValueType`.  */
  template <typename ValueType>
  ValueType GetPropertyOrDefault(const std::string& name,
                                 ValueType default_value) const {
    const AbstractValue* abstract = GetAbstractMaybe(name);
    if (!abstract) {
      return default_value;
    } else {
      if constexpr (std::is_same_v<ValueType, Eigen::Vector4d>) {
        const Rgba color =
            GetValueOrThrow<Rgba>("GetPropertyOrDefault", name, *abstract,
                                  NiceTypeName::Get<Eigen::Vector4d>());
        return ToVector4d(color);
      } else {
        // This incurs the cost of copying a stored value.
        return GetValueOrThrow<ValueType>("GetPropertyOrDefault", name,
                                          *abstract);
      }
    }
  }

  /** Removes the property with the given `name` (if it exists). Upon completion
   the property will not be in the set.

   @param name           The name of the property.
   @returns `true` if the `name` was present prior to the call.  */
  bool Remove(const std::string& name);

  /** @name Legacy (group, property) names

   In its original incarnation, property names were defined hierarchically:
   (group_name, property_name). As time has passed, the intent behind this
   hierarchy has not proven itself to be worthwhile. In fact, it has proven
   itself to be unwieldy.

   That paradigm has been replaced with a single name. We rely on the caller
   to provide meaningful suffixes/prefixes to what might otherwise be very
   similar property names (e.g., phong_diffuse vs blinn_diffuse). There are two
   implications to these changes:

     - Groups no longer exist as a meaningful concept.
     - Properties specified as ("group", "property") are actually stored as
       "group/property".

   The APIs included in this group are all to be deprecated soon. During the
   transition process, the API for querying groups is still available and should
   largely be equivalent to the legacy behavior. But it would be better to no
   longer rely on groups at all.
   */
  //@{

  /** The properties for a single group as a property name-value map.  */
  using Group =
      std::unordered_map<std::string, copyable_unique_ptr<AbstractValue>>;

  /** Returns `true` if any property starts with the string `group_name + "/"`.
   */
  DRAKE_DEPRECATED("2020-11-01", "Groups will no longer be used")
  bool HasGroup(const std::string& group_name) const;

  /** Reports the number of "groups" (see HasGroup() for definition of a group).
   */
  DRAKE_DEPRECATED("2020-11-01", "Groups will no longer be used")
  int num_groups() const;

  /** Returns a *copy* of all of the properties whose names begin with the
   substring `group_name + "/"`.  */
  DRAKE_DEPRECATED("2020-11-01", "Groups will no longer be used")
  Group GetPropertiesInGroup(const std::string& group_name) const;

  /** Returns all the unique group names (see HasGroup() for the definition of
   a group).  */
  DRAKE_DEPRECATED("2020-11-01", "Groups will no longer be used")
  std::set<std::string> GetGroupNames() const;

  /** Variant of Add() on the property "group_name/name".  */
  template <typename ValueType>
  DRAKE_DEPRECATED("2020-11-01", "Please use Add instead of AddProperty")
  void AddProperty(const std::string& group_name, const std::string& name,
                   const ValueType& value) {
    Add(encode_group(group_name, name), value);
  }

  /** Variant of Update() on the property "group_name/name".  */
  template <typename ValueType>
  DRAKE_DEPRECATED("2020-11-01", "Please use Update instead of UpdateProperty")
  void UpdateProperty(const std::string& group_name, const std::string& name,
                      const ValueType& value) {
    Update(encode_group(group_name, name), value);
  }

  /** Variant of AddAbstract() on the property "group_name/name".  */
  DRAKE_DEPRECATED("2020-11-01", "Please use AddAbstract instead of "
                                 "AddPropertyAbstract")
  void AddPropertyAbstract(const std::string& group_name,
                           const std::string& name,
                           const AbstractValue& value) {
    AddAbstract(encode_group(group_name, name), value);
  }

  /** Variant of UpdateAbstract() on the property "group_name/name".  */
  DRAKE_DEPRECATED("2020-11-01", "Please use UpdateAbstract instead of "
                                 "UpdatePropertyAbstract")
  void UpdatePropertyAbstract(const std::string& group_name,
                              const std::string& name,
                              const AbstractValue& value) {
    UpdateAbstract(encode_group(group_name, name), value);
  }

  /** Variant of HasProperty() on the property "group_name/name".  */
  DRAKE_DEPRECATED("2020-11-01", "Please use HasProperty(string) "
                                 "instead of HasProperty(string, string)")
  bool HasProperty(const std::string& group_name,
                   const std::string& name) const {
    return HasProperty(encode_group(group_name, name));
  }

  /** Variant of Get() on the property "group_name/name".  */
  template <typename ValueType>
  DRAKE_DEPRECATED("2020-11-01", "Please use Get instead of GetProperty")
  decltype(auto) GetProperty(const std::string& group_name,
                             const std::string& name) const {
    return Get<ValueType>(encode_group(group_name, name));
  }

  /** Variant of GetAbstract() on the property "group_name/name".  */
  DRAKE_DEPRECATED("2020-11-01", "Please use GetAbstract instead of "
                                 "GetPropertyAbstract")
  const AbstractValue& GetPropertyAbstract(const std::string& group_name,
                                           const std::string& name) const {
    return GetAbstract(encode_group(group_name, name));
  }

  /** Variant of GetPropertyOrDefault() on the property "group_name/name".  */
  template <typename ValueType>
  DRAKE_DEPRECATED("2020-11-01",
                   "Please use GetPropertyOrDefault(string, value) "
                   "instead of GetPropertyOrDefault(string, string, value)")
  ValueType GetPropertyOrDefault(const std::string& group_name,
                                 const std::string& name,
                                 ValueType default_value) const {
    return GetPropertyOrDefault(encode_group(group_name, name), default_value);
  }

  /** Returns the default group name. There is no guarantee as to _what_ string
   corresponds to the default group. Therefore it should always be accessed via
   this method.  */
  DRAKE_DEPRECATED("2020-11-01", "Groups will no longer be used")
  static const std::string& default_group_name() {
    static const never_destroyed<std::string> kDefaultGroup("");
    return kDefaultGroup.access();
  }

  /** Variant of Remove() where ('group_name', 'name') are given explicitly.  */
  DRAKE_DEPRECATED("2020-11-01",
                   "Please use Remove instead of RemoveProperty")
  bool RemoveProperty(const std::string& group_name, const std::string& name) {
    return Remove(encode_group(group_name, name));
  }

  //@}

#ifndef DRAKE_DOXYGEN_CXX
  // Note: these overloads of the property access methods exist to enable
  // calls like `properties.Add("group/property", "string literal");
  // Template matching would deduce that the `ValueType` in this case is a const
  // char* (which is not copyable). By explicitly declaring this API, we can
  // implicitly convert the string literals to copyable std::strings. We assume
  // that the user is never actually trying to store const char*. We omit
  // these from the doxygen because they provide no value there.
  DRAKE_DEPRECATED("2020-11-01", "Please use Add instead of AddProperty")
  void AddProperty(const std::string& group_name, const std::string& name,
                   const char* value) {
    Add<std::string>(encode_group(group_name, name), value);
  }

  DRAKE_DEPRECATED("2020-11-01", "Please use Uppdate instead of UpdateProperty")
  void UpdateProperty(const std::string& group_name, const std::string& name,
                      const char* value) {
    Update<std::string>(encode_group(group_name, name), value);
  }

  DRAKE_DEPRECATED("2020-11-01",
                   "Please use GetPropertyOrDefault(string, value) "
                   "instead of GetPropertyOrDefault(string, string, value)")
  std::string GetPropertyOrDefault(const std::string& group_name,
                                   const std::string& name,
                                   const char* default_value) const {
    return GetPropertyOrDefault(encode_group(group_name, name),
                                std::string(default_value));
  }

  GeometryProperties& Add(const std::string& name, const char* value) {
    return Add<std::string>(name, value);
  }

  GeometryProperties& Update(const std::string& name, const char* value) {
    return Update<std::string>(name, value);
  }

  std::string GetPropertyOrDefault(const std::string& name,
                                   const char* default_value) const {
    return GetPropertyOrDefault(name, std::string(default_value));
  }

#endif

 protected:
  /** Constructs an empty property set. Derived classes have access so that
   they can make themselves constructible.  */
  GeometryProperties() = default;

  // Derived subclasses are allowed to make copy/move/assign public.
  DRAKE_DEFAULT_COPY_AND_MOVE_AND_ASSIGN(GeometryProperties)

  /** Derived classes can optionally enforce invariants on properties. When a
   property is to be added or updated, it will be passed to this method. The
   derived class can determine that the type or value adheres to arbitrary
   restrictions and throw if it doesn't meet requirements. The default
   implementation considers all parameters valid.  */
  virtual void DoThrowIfInvalid(const PropertyName& property,
                                const AbstractValue& value) const {
    unused(property, value);
  }

  /** Utility function for derived classes to use to implement DoThrowIfInvalid.
   First it tests to see if the `value` contains a value of type `ValueType`
   and then passes it to the `is_valid` method to determine if it is valid
   (throwing if not).

   @param property    The ('group', 'property') name of the validated property.
   @param value       The type-erased value to test.
   @param is_valid    Validation function, should return `true` if the value in
                      `value` is acceptable.
   @param condition   A description of the condition that is_valid tests for.
   @throws std::logic_error  If type is wrong, or is_valid reports `false`.  */
  template <typename ValueType>
  void ValidateOrThrow(const PropertyName& property, const AbstractValue& value,
                       std::function<bool(const ValueType&)> is_valid,
                       const char* condition) const {
    if (value.type_info() != typeid(ValueType)) {
      throw std::logic_error(fmt::format(
          "Failed to validate property {}; expected type {}, given type {}",
          property, NiceTypeName::Get<ValueType>(), value.GetNiceTypeName()));
    }
    if (!is_valid(value.get_value<ValueType>())) {
      throw std::logic_error(
          fmt::format("Failed to validate property {}; value {} doesn't "
                      "satisfy the condition: {}",
                      property, value.get_value<ValueType>(), condition));
    }
  }

 private:
  // TODO(SeanCurtis-TRI) Remove these helpers when the (group, name) API is
  //  removed.
  static std::string encode_group(const std::string& group,
                                  const std::string& name) {
    return group + "/" + name;
  }

  static std::string extract_group(const std::string& name);
  static std::string extract_property(const std::string& name);

  // The collection of property groups.
  std::unordered_map<std::string, copyable_unique_ptr<AbstractValue>> values_;

  // Return value or nullptr if it does not exist.
  const AbstractValue* GetAbstractMaybe(const std::string& name) const;

  // Get the wrapped value from an AbstractValue, or throw an error message
  // that is easily traceable to this class.
  template <typename ValueType>
  static const ValueType& GetValueOrThrow(
      const std::string& method, const std::string& name,
      const AbstractValue& abstract,
      const std::string& nice_type_name = NiceTypeName::Get<ValueType>()) {
    const ValueType* value = abstract.maybe_get_value<ValueType>();
    if (value == nullptr) {
      throw std::logic_error(fmt::format(
          "{}(): The property '{}' exists, but is of a different type. "
          "Requested '{}', but found '{}'",
          method, name, nice_type_name, abstract.GetNiceTypeName()));
    }
    return *value;
  }

  // TODO(eric.cousineau): Enable this.
  // DRAKE_DEPRECATED(
  //     "2020-10-01", "Use Rgba instead of Vector4d to define diffuse color.")
  static Eigen::Vector4d ToVector4d(const Rgba& color) {
    return Eigen::Vector4d(color.r(), color.g(), color.b(), color.a());
  }

  // TODO(eric.cousineau): Enable this.
  // DRAKE_DEPRECATED(
  //     "2020-10-01", "Use Rgba instead of Vector4d to define diffuse color.")
  static Rgba ToRgba(const Eigen::Vector4d& value) {
    return Rgba(value(0), value(1), value(2), value(3));
  }

  friend std::ostream& operator<<(std::ostream& out,
                                  const GeometryProperties& props);
};

}  // namespace geometry
}  // namespace drake
