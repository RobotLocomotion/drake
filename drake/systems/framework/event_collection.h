#pragma once

#include <memory>
#include <utility>
#include <vector>

#include "drake/common/drake_copyable.h"
#include "drake/systems/framework/context.h"
#include "drake/systems/framework/event.h"
#include "drake/systems/framework/state.h"
#include "drake/systems/framework/trigger.h"

namespace drake {
namespace systems {

/**
 * There are three concrete event types for any System: publish, discrete
 * state update and unrestricted state update. This is a base class that
 * represents simultaneous events of the same type at a particular time.
 * Each concrete event has an optional callback function for event
 * handling, and a Trigger object that holds information for the handler
 * function such as why the event occurred and optional additional data to
 * facilitate data flow from event triggering to handling.
 *
 * For each event type (publish, discrete update and unrestricted update),
 * the LeafSystem API provides a unique customizable function for handling all
 * the simultaneous events of that type, e.g.
 * LeafSystem::DoPublish(const Context&, const vector<const PublishEvent*>&)
 * for publish events, where the second argument represents all the publish
 * events that occur simultaneously for a leaf system. The default
 * implementations process the events in the same order of the second argument.
 * The user is responsible for overriding such functions to handle each event
 * in the desired order. For example, suppose two publish events are being
 * handled, events = {per step publish, periodic publish}. Depending on the
 * desired behavior, the user has the freedom to ignore both, handle only one,
 * or both in any arbitrary order. Note that for each type of events at any
 * given time, its handler should only be invoked once. The System and Diagram
 * API only provide dispatch mechanisms that delegate actual event handling
 * to all the constituent leaf systems.
 *
 * The System API provides several functions for customizable event scheduling
 * and generation such as System::DoCalcNextUpdateTime() or
 * System::DoGetPerStepEvents(). These functions can generate any number of
 * events of arbitrary types, and the resulting events are stored in separate
 * CombinedEventCollection instances. Before calling the event handlers, all
 * these
 * CombinedEventCollection objects need to be merged to generate a complete
 * set of simultaneous events. Then, only events of the appropriate type are
 * passed to the event handlers. (e.g. sys.Publish(context,
 * combined_event_collection.get_publish_events()))
 *
 * Here is a complete example. For some LeafSystem `sys` at time `t`, its
 * System::DoCalcNextUpdateTime() generates the following
 * CombinedEventCollection (`events1`):
 * <pre>
 *   PublishEvent: {event1(kPeriodic, callback1)}
 *   DiscreteUpdateEvent: {event2(kPeriodic, callback2)}
 *   UnrestrictedUpdateEvent: {}
 * </pre>
 * It also has per step events (`events2`) generated by its
 * System::DoGetPerStepEvents():
 * <pre>
 *   PublishEvent: {event3(kPerStep, callback3)}
 *   DiscreteUpdateEvent: {}
 *   UnrestrictedUpdateEvent: {event4(kPerStep,callback4)}
 * </pre>
 * Simultaneous events `events1` and `events2` are then
 * merged into `all_events`:
 * <pre>
 *   PublishEvent: {event1, event3}
 *   DiscreteUpdateEvent: {event2}
 *   UnrestrictedUpdateEvent: {event4}
 * </pre>
 *
 * To handle these events:
 * <pre>
 *   sys.CalcUnrestrictedUpdate(context,
 * all_events.get_unrestricted_update_events(), state);
 *   sys.CalcDiscreteVariableUpdates(context,
 * all_events.get_discrete_update_events(), discrete_state);
 *   sys.Publish(context, all_events.get_publish_events())
 * </pre>
 * For a LeafSystem, this is equivalent to (by expanding the dispatch mechanisms
 * in the System API):
 * <pre>
 *   sys.DoCalcUnrestrictedUpdate(context, {event4}, state);
 *   sys.DoCalcDiscreteVariableUpdates(context, {event2}, discrete_state);
 *   sys.DoPublish(context, {event1, event3})
 * </pre>
 *
 * @tparam EventType should be concrete derived types of Event.
 */
template <typename EventType>
class EventCollection {
 public:
  DRAKE_NO_COPY_NO_MOVE_NO_ASSIGN(EventCollection)

  virtual ~EventCollection() {}

  /**
   * Clears all the events maintained by this, and adds all the events in
   * @p other to this.
   */
  void SetFrom(const EventCollection<EventType>& other) {
    Clear();
    Merge(other);
  }

  /**
   * Merges all of @p other's events into this. See derived DoMerge() for more
   * details.
   */
  void Merge(const EventCollection<EventType>& other) {
    if (&other == this) return;
    DoMerge(&other);
  }

  /**
   * Clears all the maintained events.
   */
  virtual void Clear() = 0;

  /**
   * Returns true if no event exists.
   */
  virtual bool HasNoEvents() const = 0;

  bool HasEvents() const { return !HasNoEvents(); }

 protected:
  /**
   * Constructor only accessible by derived class.
   */
  EventCollection() = default;

  /**
   * Derived implementation can assume that @p is not null, and it is does not
   * equal to this.
   */
  virtual void DoMerge(const EventCollection<EventType>* other) = 0;
};

/**
 * A concrete class that holds all the simultaneous homogeneous events for a
 * Diagram. For
 * each sub system in the corresponding Diagram, a derived EventCollection
 * instance is maintained internally. This effectively holds the same recursive
 * tree structure as the corresponding Diagram.
 */
template <typename EventType>
class DiagramEventCollection final : public EventCollection<EventType> {
 public:
  DRAKE_NO_COPY_NO_MOVE_NO_ASSIGN(DiagramEventCollection)

  /**
   * Constructor. Note that this constructor only resizes the containers, but
   * does not allocate any derived EventCollection instances.
   *
   * @note Users should almost never call this explicitly. Use
   * System::AllocateEventCollection() instead.
   *
   * @param num_sub_systems Number of sub systems in the corresponding Diagram.
   */
  explicit DiagramEventCollection(int num_sub_systems)
      : EventCollection<EventType>(),
        sub_event_collection_(num_sub_systems),
        owned_sub_event_collection_(num_sub_systems) {}

  /**
   * Returns the number of constituent EventCollection that correspond to each
   * sub system.
   */
  int num_sub_event_collection() const {
    return static_cast<int>(sub_event_collection_.size());
  }

  /**
   * Transfers @p sub_event_collection ownership to this, and associate it with
   * sub system identified by @p index.
   */
  void set_and_own_sub_event_collection(
      int index,
      std::unique_ptr<EventCollection<EventType>> sub_event_collection) {
    DRAKE_DEMAND(index >= 0 && index < num_sub_event_collection());
    owned_sub_event_collection_[index] = std::move(sub_event_collection);
    sub_event_collection_[index] = owned_sub_event_collection_[index].get();
  }

  /**
   * Associate @p sub_event_collection with sub system identified by @p index.
   * Ownership of the object that @p sub_event_collection is maintained
   * elsewhere, and its life span must be longer than this.
   */
  void set_sub_event_collection(
      int index, EventCollection<EventType>* sub_event_collection) {
    DRAKE_DEMAND(index >= 0 && index < num_sub_event_collection());
    sub_event_collection_[index] = sub_event_collection;
  }

  /**
   * Returns a const pointer to sub system's EventCollection at @p index.
   */
  const EventCollection<EventType>* get_sub_event_collection(int index) const {
    DRAKE_DEMAND(index >= 0 && index < num_sub_event_collection());
    return sub_event_collection_[index];
  }

  /**
   * Returns a mutable pointer to sub system's EventCollection at @p index.
   */
  EventCollection<EventType>* get_mutable_sub_event_collection(int index) {
    DRAKE_DEMAND(index >= 0 && index < num_sub_event_collection());
    return sub_event_collection_[index];
  }

  /**
   * Goes through each sub event collection and clears its content.
   */
  void Clear() override {
    for (EventCollection<EventType>* sub_event : sub_event_collection_) {
      sub_event->Clear();
    }
  }

  /**
   * Returns true if none of the sub event collection has any events.
   */
  bool HasNoEvents() const override {
    for (const EventCollection<EventType>* sub_event : sub_event_collection_) {
      if (!sub_event->HasNoEvents()) return false;
    }
    return true;
  }

 protected:
  // These are protected for doxygen.

  /**
   * Goes through each sub event collection and merges in the corresponding one
   * in @p other_collection. Assumes that @p other_collection is an instance of
   * DiagramEventCollection and has the same number of sub event collections.
   * Aborts otherwise.
   */
  void DoMerge(const EventCollection<EventType>* other_collection) override {
    const DiagramEventCollection<EventType>* other =
        dynamic_cast<const DiagramEventCollection<EventType>*>(
            other_collection);
    DRAKE_DEMAND(other != nullptr);
    DRAKE_DEMAND(num_sub_event_collection() ==
                 other->num_sub_event_collection());

    for (int i = 0; i < num_sub_event_collection(); i++) {
      sub_event_collection_[i]->Merge(*(other->get_sub_event_collection(i)));
    }
  }

 private:
  std::vector<EventCollection<EventType>*> sub_event_collection_;
  std::vector<std::unique_ptr<EventCollection<EventType>>>
      owned_sub_event_collection_;
};

/**
 * A concrete class that holds all simultaneous homogeneous events for a
 * LeafSystem. e.g.
 * <pre>
 *   EventType: {event1, event2, ...}
 * </pre>
 */
template <typename EventType>
class LeafEventCollection final : public EventCollection<EventType> {
 public:
  DRAKE_NO_COPY_NO_MOVE_NO_ASSIGN(LeafEventCollection)

  /**
   * Constructor.
   */
  LeafEventCollection() = default;

  /**
   * Returns a const reference to the vector of const pointers to all the
   * events.
   */
  const std::vector<const EventType*>& get_events() const { return events_; }

  /**
   * Add @p event to the existing event. Ownership of @p event is transfered.
   */
  void add_event(std::unique_ptr<EventType> event) {
    owned_events_.push_back(std::move(event));
    events_.push_back(owned_events_.back().get());
  }

  /**
   * Returns true if no event exists.
   */
  bool HasNoEvents() const override { return events_.empty(); }

  /**
   * Clears all events.
   */
  void Clear() override {
    owned_events_.clear();
    events_.clear();
  }

 protected:
  // These are protected for doxygen.

  /**
   * All events in @p other_info is added to this. Assumes that @p other_info
   * is an instance of LeafEventCollection. Aborts otherwise.
   *
   * Here is an example. Suppose this has the following events:
   * <pre>
   *   EventType: {event1, event2, event3}
   * </pre>
   * @p other_info has:
   * <pre>
   *   EventType: {event4}
   * </pre>
   * After calling DoMerge(other_info), this looks like this:
   * <pre>
   *   EventType: {event1, event2, event3, event4}
   * </pre>
   */
  void DoMerge(const EventCollection<EventType>* other_info) override {
    const LeafEventCollection<EventType>* other =
        dynamic_cast<const LeafEventCollection<EventType>*>(other_info);
    DRAKE_DEMAND(other != nullptr);

    const std::vector<const EventType*>& other_events = other->get_events();
    for (const EventType* other_event : other_events) {
      other_event->add_to(this);
    }
  }

 private:
  // Owned event unique pointers.
  std::vector<std::unique_ptr<EventType>> owned_events_;

  // Points to the corresponding unique pointers.
  std::vector<const EventType*> events_;
};

/**
 * This class bundles an instance of each EventCollection<EventType> into one
 * object.
 * <pre>
 * CombinedEventCollection<T> = {
 *   EventCollection<PublishEvent<T>>,
 *   EventCollection<DiscreteUpdateEvent<T>>,
 *   EventCollection<UnrestrictedUpdate<T>>}
 * </pre>
 */
template <typename T>
class CombinedEventCollection {
 public:
  DRAKE_NO_COPY_NO_MOVE_NO_ASSIGN(CombinedEventCollection)

  virtual ~CombinedEventCollection() {}

  /**
   * Clears all publish, discrete update and unrestricted update events.
   */
  void Clear() {
    publish_events_->Clear();
    discrete_update_events_->Clear();
    unrestricted_update_events_->Clear();
  }

  /**
   * Returns true if not a single event of any type exists.
   */
  bool HasNoEvents() const {
    return (publish_events_->HasNoEvents() &&
            discrete_update_events_->HasNoEvents() &&
            unrestricted_update_events_->HasNoEvents());
  }

  /**
   * Merges this' EventCollection<PublishEvent<T>> with @p other's
   * EventCollection<PublishEvent<T>>, and so on.
   */
  void Merge(const CombinedEventCollection<T>& other) {
    publish_events_->Merge(other.get_publish_events());
    discrete_update_events_->Merge(other.get_discrete_update_events());
    unrestricted_update_events_->Merge(other.get_unrestricted_update_events());
  }

  /**
   * Sets this' EventCollection<PublishEvent<T>> to @p other's
   * EventCollection<PublishEvent<T>>, and so on.
   */
  void SetFrom(const CombinedEventCollection<T>& other) {
    publish_events_->SetFrom(other.get_publish_events());
    discrete_update_events_->SetFrom(other.get_discrete_update_events());
    unrestricted_update_events_->SetFrom(
        other.get_unrestricted_update_events());
  }

  /**
   * Returns a const reference to EventCollection<PublishEvent<T>>.
   */
  virtual const EventCollection<PublishEvent<T>>& get_publish_events() const {
    return *publish_events_;
  }

  /**
   * Returns a const reference to EventCollection<DiscreteUpdateEvent<T>>.
   */
  virtual const EventCollection<DiscreteUpdateEvent<T>>&
  get_discrete_update_events() const {
    return *discrete_update_events_;
  }

  /**
   * Returns a const reference to EventCollection<UnrestrictedUpdateEvent<T>>.
   */
  virtual const EventCollection<UnrestrictedUpdateEvent<T>>&
  get_unrestricted_update_events() const {
    return *unrestricted_update_events_;
  }

  /**
   * Returns a mutable pointer to EventCollection<PublishEvent<T>>.
   */
  virtual EventCollection<PublishEvent<T>>* get_mutable_publish_events() const {
    return publish_events_.get();
  }

  /**
   * Returns a mutable pointer to EventCollection<DiscreteUpdateEvent<T>>.
   */
  virtual EventCollection<DiscreteUpdateEvent<T>>*
  get_mutable_discrete_update_events() const {
    return discrete_update_events_.get();
  }

  /**
   * Returns a mutable pointer to EventCollection<UnrestrictedUpdateEvent<T>>.
   */
  virtual EventCollection<UnrestrictedUpdateEvent<T>>*
  get_mutable_unrestricted_update_events() const {
    return unrestricted_update_events_.get();
  }

 protected:
  /**
   * Takes ownership of @p pub, @p discrete and @p unrestricted.
   */
  CombinedEventCollection(
      std::unique_ptr<EventCollection<PublishEvent<T>>> pub,
      std::unique_ptr<EventCollection<DiscreteUpdateEvent<T>>> discrete,
      std::unique_ptr<EventCollection<UnrestrictedUpdateEvent<T>>> unrestricted)
      : publish_events_(std::move(pub)),
        discrete_update_events_(std::move(discrete)),
        unrestricted_update_events_(std::move(unrestricted)) {}

 private:
  std::unique_ptr<EventCollection<PublishEvent<T>>> publish_events_{nullptr};
  std::unique_ptr<EventCollection<DiscreteUpdateEvent<T>>>
      discrete_update_events_{nullptr};
  std::unique_ptr<EventCollection<UnrestrictedUpdateEvent<T>>>
      unrestricted_update_events_{nullptr};
};

/**
 * A CombinedEventCollection for a LeafSystem. i.e.
 * <pre>
 *   PublishEvent<T>: {event1i, ...}
 *   DiscreteUpdateEvent<T>: {event2i, ...}
 *   UnrestrictedUpdateEvent<T>: {event3i, ...}
 * </pre>
 */
template <typename T>
class LeafCombinedEventCollection : public CombinedEventCollection<T> {
 public:
  DRAKE_NO_COPY_NO_MOVE_NO_ASSIGN(LeafCombinedEventCollection)

  LeafCombinedEventCollection()
      : CombinedEventCollection<T>(
            std::make_unique<LeafEventCollection<PublishEvent<T>>>(),
            std::make_unique<LeafEventCollection<DiscreteUpdateEvent<T>>>(),
            std::make_unique<
                LeafEventCollection<UnrestrictedUpdateEvent<T>>>()) {}

  /**
   * Adds a publish event @p event, whose ownership is also transferred to this.
   */
  void add_publish_event(std::unique_ptr<PublishEvent<T>> event) {
    auto events = dynamic_cast<LeafEventCollection<PublishEvent<T>>*>(
        this->get_mutable_publish_events());
    DRAKE_ASSERT(events != nullptr);
    events->add_event(std::move(event));
  }

  /**
   * Adds a discrete_update event @p event, whose ownership is also transferred
   * to this.
   */
  void add_discrete_update_event(
      std::unique_ptr<DiscreteUpdateEvent<T>> event) {
    auto events = dynamic_cast<LeafEventCollection<DiscreteUpdateEvent<T>>*>(
        this->get_mutable_discrete_update_events());
    DRAKE_ASSERT(events != nullptr);
    events->add_event(std::move(event));
  }

  /**
   * Adds a unrestricted_update event @p event, whose ownership is also
   * transferred to this.
   */
  void add_unrestricted_update_event(
      std::unique_ptr<UnrestrictedUpdateEvent<T>> event) {
    auto events =
        dynamic_cast<LeafEventCollection<UnrestrictedUpdateEvent<T>>*>(
            this->get_mutable_unrestricted_update_events());
    DRAKE_ASSERT(events != nullptr);
    events->add_event(std::move(event));
  }

  // My failed? attempt to do covariant return type..
  const LeafEventCollection<PublishEvent<T>>& get_publish_events()
      const override {
    return dynamic_cast<const LeafEventCollection<PublishEvent<T>>&>(
        CombinedEventCollection<T>::get_publish_events());
  }

  const LeafEventCollection<DiscreteUpdateEvent<T>>&
  get_discrete_update_events() const override {
    return dynamic_cast<const LeafEventCollection<DiscreteUpdateEvent<T>>&>(
        CombinedEventCollection<T>::get_discrete_update_events());
  }

  const LeafEventCollection<UnrestrictedUpdateEvent<T>>&
  get_unrestricted_update_events() const override {
    return dynamic_cast<const LeafEventCollection<UnrestrictedUpdateEvent<T>>&>(
        CombinedEventCollection<T>::get_unrestricted_update_events());
  }

 private:
};

/**
 * CombinedEventCollection for a Diagram.
 */
template <typename T>
class DiagramCombinedEventCollection : public CombinedEventCollection<T> {
 public:
  DRAKE_NO_COPY_NO_MOVE_NO_ASSIGN(DiagramCombinedEventCollection)

  /**
   * Allocated CombinedEventCollection for all constituent sub systems are
   * passed in @p sub_events, whose ownership are also transferred to this.
   */
  explicit DiagramCombinedEventCollection(
      std::vector<std::unique_ptr<CombinedEventCollection<T>>> sub_events)
      : CombinedEventCollection<T>(
            std::make_unique<DiagramEventCollection<PublishEvent<T>>>(
                sub_events.size()),
            std::make_unique<DiagramEventCollection<DiscreteUpdateEvent<T>>>(
                sub_events.size()),
            std::make_unique<
                DiagramEventCollection<UnrestrictedUpdateEvent<T>>>(
                sub_events.size())),
        owned_sub_event_collection_(std::move(sub_events)) {
    size_t num_sub_systems = owned_sub_event_collection_.size();

    for (size_t i = 0; i < num_sub_systems; ++i) {
      DiagramEventCollection<PublishEvent<T>>* sub_publish =
          dynamic_cast<DiagramEventCollection<PublishEvent<T>>*>(
              this->get_mutable_publish_events());
      // Sets sub_publish's i'th sub system's EventCollection<PublishEvent>
      // pointer to owned_sub_event_collection_[i].get_mutable_publish_events().
      // So that sub_publish has the same pointer structure, but does not
      // duplicate actual data.
      sub_publish->set_sub_event_collection(
          i, owned_sub_event_collection_[i]->get_mutable_publish_events());

      DiagramEventCollection<DiscreteUpdateEvent<T>>* sub_discrete_update =
          dynamic_cast<DiagramEventCollection<DiscreteUpdateEvent<T>>*>(
              this->get_mutable_discrete_update_events());
      sub_discrete_update->set_sub_event_collection(
          i,
          owned_sub_event_collection_[i]->get_mutable_discrete_update_events());

      DiagramEventCollection<UnrestrictedUpdateEvent<T>>*
          sub_unrestricted_update =
              dynamic_cast<DiagramEventCollection<UnrestrictedUpdateEvent<T>>*>(
                  this->get_mutable_unrestricted_update_events());
      sub_unrestricted_update->set_sub_event_collection(
          i, owned_sub_event_collection_[i]
                 ->get_mutable_unrestricted_update_events());
    }
  }

  /**
   * Returns the number of constituent CombinedEventCollection.
   */
  int num_sub_event_collection() const {
    return static_cast<int>(owned_sub_event_collection_.size());
  }

  CombinedEventCollection<T>* get_mutable_sub_event_collection(int index) {
    DRAKE_DEMAND(index >= 0 && index < num_sub_event_collection());
    return owned_sub_event_collection_[index].get();
  }

  const CombinedEventCollection<T>& get_sub_event_collection(int index) const {
    DRAKE_DEMAND(index >= 0 && index < num_sub_event_collection());
    return *owned_sub_event_collection_[index];
  }

 private:
  std::vector<std::unique_ptr<CombinedEventCollection<T>>>
      owned_sub_event_collection_;
};

}  // namespace systems
}  // namespace drake
