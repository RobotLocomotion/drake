#pragma once

#include <string>
#include <unordered_map>
#include <vector>

#include "drake/examples/QPInverseDynamicsForHumanoids/param_parsers/rigid_body_tree_alias_groups.h"
#include "drake/examples/QPInverseDynamicsForHumanoids/qp_controller_common.h"

#include "yaml-cpp/yaml.h"

namespace drake {
namespace examples {
namespace qp_inverse_dynamics {
namespace param_parsers {

/**
 * Struct for storing parameters for generating a desired acceleration
 * objective \f$ \dot{v}_d \f$ for the QP inverse dynamics controller. A way
 * to generate \f$ \dot{v}_d \f$ is through a simple PD law around a nominal
 * setpoint \f$ (q^*, v^*, \dot{v}^*) \f$ as:
 * \f[
 * \dot{v}_d = Kp (q^* - q) + Kd (v^* - v) + \dot{v}^*.
 * \f]
 * This setpoint is typically generated by some motion planner or simple
 * heuristics. \f$ \dot{v}_d \f$ is then used in the quadratic cost function
 * in the QP inverse dynamics controller. The cost function typically looks
 * like:
 * \f[
 * min_{\dot{v}} (\dot{v}_d - \dot{v})^T W (\dot{v}_d - \dot{v}),
 * \f]
 * where \f$ W \f$ is a diagonal weighting matrix. \f$ W \f$'s diagonal terms
 * are from `weight`. Depending on the application, \f$ \dot{v}_d \f$ can also
 * be ignored or treated as an equality constraint in the optimization.
 * If `weight(i)` is positive, \f$ \dot{v}_d(i) \f$ is used as a cost term.
 * If `weight(i)` is negative, \f$ \dot{v}_d(i) \f$ is used as an equality
 * constraint. If weight(i) is zero, \f$ \dot{v}_d(i) \f$ is ignored.
 *
 * This struct holds name, Kp, Kd, and weight.
 */
struct DesiredMotionParam {
  /// Name can be arbitrary.
  std::string name;
  VectorX<double> Kp;
  VectorX<double> Kd;
  VectorX<double> weight;

  DesiredMotionParam() {}

  explicit DesiredMotionParam(int dim) {
    Kp = VectorX<double>::Zero(dim);
    Kd = VectorX<double>::Zero(dim);
    weight = VectorX<double>::Zero(dim);
  }

  bool operator==(const DesiredMotionParam& other) const {
    if (!Kp.isApprox(other.Kp)) return false;
    if (!Kd.isApprox(other.Kd)) return false;
    if (!weight.isApprox(other.weight)) return false;
    return true;
  }

  bool operator!=(const DesiredMotionParam& other) const {
    return !(*this == other);
  }
};

std::ostream& operator<<(std::ostream& out, const DesiredMotionParam& param);

/**
 * A struct for holding contact-related parameters such as local offsets of the
 * contact points, friction coefficient, etc. These can be used to make a
 * ContactInformation which is used by the QP inverse dynamics controller.
 * Please see ContactInformation for more details.
 */
struct ContactParam {
  /// Name can be arbitrary.
  std::string name;
  /// Specified in the body frame.
  Matrix3X<double> contact_points;
  /// Specified in the body frame.
  Vector3<double> normal;
  int num_basis_per_contact_point;
  /// Friction coefficient.
  double mu;
  /// The QP controller tries to damp contact motions by adding a desired
  /// acceleration objective / constraint as \f$ \dot{v}_d = -Kd v \f$.
  /// `weight` is used to specify how \f$ \dot{v}_d \f$ is used in the
  /// optimization. If `weight` is positive, \f$ \dot{v}_d \f$ is used as a
  /// cost term. If `weight` is negative, \f$ \dot{v}_d \f$ is used as an
  /// equality constraint. `weight` shouldn't be zero.
  double Kd;
  double weight;

  bool operator==(const ContactParam& other) const {
    if (num_basis_per_contact_point != other.num_basis_per_contact_point)
      return false;
    if (mu != other.mu) return false;
    if (Kd != other.Kd) return false;
    if (weight != other.weight) return false;
    if (!normal.isApprox(other.normal)) return false;
    if (!contact_points.isApprox(other.contact_points)) return false;
    return true;
  }

  bool operator!=(const ContactParam& other) const { return !(*this == other); }
};

std::ostream& operator<<(std::ostream& out, const ContactParam& param);

/**
 * A class for parsing and storing parameters that are used to generate QpInput
 * for the QP inverse dynamics controller. Utility methods for generating
 * ContactInformation, DesiredBodyMotion, DesiredDoFMotion and
 * DesiredCentroidalMomentumDot from the stored parameters are also provided.
 * DesiredBodyMotion, DesiredDoFMotion and DesiredCentroidalMomentumDot consist
 * of two groups of numbers: gains / weights and desired acceleration. This
 * class only works with the gains and weights. The second group needs to be
 * computed by some feedback policy, which outside the scope of this class.
 */
class ParamSet {
 public:
  ParamSet() {}

  ParamSet(const ParamSet& other) = delete;
  ParamSet& operator=(const ParamSet& other) = delete;

  /**
   * Loads parameters from a YAML config file, which needs to contain at least
   * 5 sections: ContactForceBasis, Contacts, BodyMotions, DoFMotions, and
   * CentroidalMomentum.
   *
   * For the Contacts, BodyMotions and DoFMotions sections, entries are
   * specified based on body or joint groups rather than RigidBody names or
   * DrakeJoint to decouple these parameters from a specific RigidBodyTree.
   * The relationship between body / joint groups and RigidBodyTree is provided
   * by RigidBodyTreeAliasGroups.
   *
   * For the Contacts, BodyMotions and DoFMotions sections, default entries can
   * be provided to cover situations where parameters are queried for bodies or
   * joints whose parameters are not explicitly defined. The default parameters
   * are also used to fill incomplete entries. Complete default parameters for
   * these sections are thus required. Here is a simple example:
   * <pre>
   * DoFMotions:
   *   default:
   *     Kp: 0
   *     Kd: 0
   *     weight: 1e-2
   *
   *   left_arm:
   *     Kp: 1
   * </pre>
   * The parameters for joint group `left_arm` will be `Kp = 1, Kd = 0,
   * weight = 1e-2`, and the parameters for joint group `right_arm` will be
   * `Kp = 0, Kd = 0, weight = 1e-2`.
   *
   * The complete format for entries in BodyMotions is:
   * <pre>
   * group_name:
   *   Kp: [double, double, double, double, double, double]
   *   Kd: [double, double, double, double, double, double]
   *   weight: [double, double, double, double, double, double]
   * </pre>
   * Kp, Kd and weight can either be a vector of 6 doubles, a vector of 1
   * double or a singleton double.
   *
   * The complete format for entries in DoFMotions is:
   * <pre>
   * group_name:
   *   Kp: [double, ..., double]
   *   Kd: [double, ..., double]
   *   weight: [double, ..., double]
   * </pre>
   * Kp, Kd and weight can either be a vector of N doubles, a vector of 1
   * double or a singleton double, where N is the number of DoF for that
   * group. Kp, Kd, and weight for the default entry must have length one.
   *
   * The valid format for entries in Contacts is:
   * <pre>
   * group_name:
   *   weight: double
   *   Kd: double
   *   mu: double
   *   contact_points:
   *     [[double, double, double],
   *      ...,
   *     [double, double, double]]
   *   num_basis_per_contact_point: int
   *   normal: [double, double, double]
   * </pre>
   * contact_points: can be a single vector of 3 doubles if there is only
   * one contact point. Contact points and normal are specified in the body
   * frame.
   *
   * The format for CentroidalMomentum is:
   * <pre>
   * Kp: [double, double, double, double, double, double]
   * Kd: [double, double, double, double, double, double]
   * weight: [double, double, double, double, double, double]
   * </pre>
   *
   * The format for ContactForceBasis is:
   * <pre>
   * weight: double
   * </pre>
   *
   * @param config YAML node parsed from the config file.
   * @param alias_group Specifies the relationship between body / joint groups
   * and the RigidBodyTree it is constructed from.
   *
   * @throws std::runtime_error if the config file is not formatted correctly.
   */
  void LoadFromYAMLConfigFile(
      const YAML::Node& config,
      const RigidBodyTreeAliasGroups<double>& alias_group);

  /**
   * Returns a map from body names to ContactInformation, where the body names
   * belong to the body group specified by @p group_name in @p alias_group.
   * For each body without a corresponding ContactParam, a ContactInformation
   * will be constructed using the default ContactParam. If @p alias_group
   * does not contain @p group_name, an empty map will be returned.
   *
   * @param group_name Name of the body group of interest.
   * @param alias_group Specifies the relationship between body / joint groups
   * and the RigidBodyTree it is constructed from.
   * @return A map from body names to ContactInformation
   */
  std::unordered_map<std::string, ContactInformation> MakeContactInformation(
      const std::string& group_name,
      const RigidBodyTreeAliasGroups<double>& alias_group) const;

  /**
   * Returns a map from body names to DesiredBodyMotions, where the body names
   * belongs to the body group specified by @p group_name in @p alias_group.
   * This method only sets the weights and constraint_types fields of
   * DesiredBodyMotion; it does not set the values, which must be set
   * separately. For each body name, if it has no corresponding
   * DesiredMotionParam, a DesiredBodyMotion will be constructed using the
   * default DesiredMotionParam. If @p alias_group does not contain
   * @p group_name, an empty map will be returned.
   *
   * @param group_name Name of the body group of interest.
   * @param alias_group Specifies the relationship between body / joint groups
   * and the RigidBodyTree it is constructed from.
   * @return A map from body names to DesiredBodyMotions.
   */
  std::unordered_map<std::string, DesiredBodyMotion> MakeDesiredBodyMotion(
      const std::string& group_name,
      const RigidBodyTreeAliasGroups<double>& alias_group) const;

  /**
   * Returns a single ContactInformation for @p body. If @p body has no
   * corresponding ContactParam, a ContactInformation constructed with the
   * default ContactParam will be returned.
   */
  ContactInformation MakeContactInformation(
      const RigidBody<double>& body) const;

  /**
   * Returns a single DesiredBodyMotion for @p body. This method only sets the
   * weights and constraint_types fields of DesiredBodyMotion; it does not set
   * the values, which must be set separately. If @p body has no corresponding
   * DesiredMotionParam, a DesiredBodyMotion constructed with the default
   * DesiredMotionParam will be returned.
   */
  DesiredBodyMotion MakeDesiredBodyMotion(const RigidBody<double>& body) const;

  /**
   * Finds the Kp and Kd gains for all the bodies in the body group specified
   * by @p group_name. For each body in body group @p group_name, if it has no
   * corresponding DesiredMotionParam, its Kp and Kd will be set to the values
   * in the default DesiredMotionParam. The ith entry in @p Kp and @p Kd
   * correspond to the ith entry in body group @p group_name.
   * @p Kp and @p Kd will be resized to match the size of the body group
   * specified by @p group_name. If @p group_name does not exist in
   * @p alias_group, @p Kp and @p Kd will be cleared.
   *
   * @param group_name Name of the body group of interest.
   * @param alias_group RigidBodyTreeAliasGroups specifying the relationship
   * between body / joint groups and the RigidBodyTree it is constructed from.
   * @param[out] Kp container for Kp's output.
   * @param[out] Kd container for Kd's output.
   */
  void LookupDesiredBodyMotionGains(
      const std::string& group_name,
      const RigidBodyTreeAliasGroups<double>& alias_group,
      std::vector<Vector6<double>>* Kp, std::vector<Vector6<double>>* Kd) const;

  /**
   * Finds the Kp and Kd gains for @p body. If it has no corresponding
   * DesiredMotionParam, the Kp and Kd will be set to the values in the default
   * DesiredMotionParam.
   *
   * @param body Referent to the RigidBody of interest.
   * @param[out] Kp output.
   * @param[out] Kd output.
   */
  void LookupDesiredBodyMotionGains(const RigidBody<double>& body,
                                    Vector6<double>* Kp,
                                    Vector6<double>* Kd) const;

  /**
   * Obtains the Kp and Kd gains for all DoF.
   * @p Kp and @p Kd will be resized to match the number of DoFs of the
   * RigidBodyTree in the RigidBodyTreeAliasGroups passed to
   * LoadFromYAMLConfigFile.
   *
   * @param[out] Kp output.
   * @param[out] Kd output.
   */
  void LookupDesiredDofMotionGains(VectorX<double>* Kp,
                                   VectorX<double>* Kd) const;

  /**
   * Obtains the Kp and Kd gains for the centroidal momentum tracker.
   *
   * @param[out] Kp output.
   * @param[out] Kd output.
   */
  void LookupDesiredCentroidalMomentumDotGains(Vector6<double>* Kp,
                                               Vector6<double>* Kd) const;

  /**
   * Returns DesiredDofMotions configured by DesiredMotionParam for all DoF.
   * This method only sets the weights and constraint_types fields in
   * DesiredDofMotions. The values field needs to be set separately.
   * For each DoF with no DesiredMotionParam, the default DesiredMotionParam
   * will be used.
   */
  DesiredDofMotions MakeDesiredDofMotions() const;

  /**
   * Returns DesiredCentroidalMomentumDot configured by the DesiredMotionParam
   * for centroidal momentum. This method only sets the weights and
   * constraint_types fields in DesiredCentroidalMomentumDot. The values field
   * needs to be set separately.
   */
  DesiredCentroidalMomentumDot MakeDesiredCentroidalMomentumDot() const;

  QpInput MakeQpInput(
      const std::vector<std::string>& contact_body_groups,
      const std::vector<std::string>& tracked_body_groups,
      const RigidBodyTreeAliasGroups<double>& alias_group) const;

  /**
   * Returns the weight for regularizing the basis vectors of contact forces.
   */
  double get_basis_regularization_weight() const {
    return basis_regularization_weight_;
  }

  /**
   * Returns the name of this ParamSet.
   */
  const std::string& get_name() const { return name_; }

  /**
   * Sets the name of this ParamSet.
   * @param name New name for this ParamSet.
   */
  void set_name(const std::string& name) { name_ = name; }

 private:
  // Name of this ParamSet.
  std::string name_;

  double basis_regularization_weight_ {0};

  // Maps from body_name (or "default") to ContactParam.
  std::unordered_map<std::string, ContactParam> contact_params_;
  // Maps from body_name (or "default") to DesiredMotionParam.
  std::unordered_map<std::string, DesiredMotionParam> body_motion_params_;

  // One DesiredMotionParam of size 1 per DoF.
  std::vector<DesiredMotionParam> dof_motion_params_;
  DesiredMotionParam default_dof_motion_param_;

  DesiredMotionParam centroidal_momentum_dot_params_;

  // Generates a ContactInformation for @p body based on @p param.
  ContactInformation MakeContactInformationFromParam(
      const RigidBody<double>& body, const ContactParam& param) const;

  // Generates a DesiredBodyMotion for @p body based on @p param.
  DesiredBodyMotion MakeDesiredBodyMotionFromParam(
      const RigidBody<double>& body, const DesiredMotionParam& param) const;
};

}  // namespace param_parsers
}  // namespace qp_inverse_dynamics
}  // namespace examples
}  // namespace drake
