#pragma once

namespace drake {
namespace solvers {
class MathematicalProgram;

enum SolutionSummary {
  kSolutionFound = 0,
  kInvalidInput = -1,
  kInfeasibleConstraints = -2,
  kUnknownError = -3,
};

/// This is the returned type of MathematicalProgramSolverInterface::Solve().
/// It contains the information generated by each solver, when solving the
/// optimization problem.
class MathematicalProgramSolverResult {
 public:
  MathematicalProgramSolverResult(SolutionSummary summary) : summary_(summary) {}

  /** Getter for summary. */
  SolutionSummary summary() const {return summary_;}

 private:
  const SolutionSummary summary_;
};

/// Interface used by implementations of individual solvers.
class MathematicalProgramSolverInterface {
 public:
  virtual ~MathematicalProgramSolverInterface() = default;

  /// Returns true iff this solver was enabled at compile-time.
  bool available() const { return available_impl();}

  /// Returns the name of the solver.
  std::string SolverName() const { return SolverName_impl();}

  /// Sets values for the decision variables on the given MathematicalProgram
  /// @p prog, or:
  ///  * If no solver is available, throws std::runtime_error
  ///  * If the solver returns an error, returns a nonzero SolutionSummary.
  // TODO(#2274) Fix NOLINTNEXTLINE(runtime/references).
  std::unique_ptr<MathematicalProgramSolverResult> Solve(MathematicalProgram &prog) const {return std::unique_ptr<MathematicalProgramSolverResult>(Solve_impl(prog));}

 protected:
  virtual bool available_impl() const = 0;

  virtual std::string SolverName_impl() const = 0;

  /**
   * @return The raw pointer to the newly constructed result.
   */
  virtual MathematicalProgramSolverResult* Solve_impl(MathematicalProgram& prog) const = 0;
};
} // namespace solvers
} // namespace drake