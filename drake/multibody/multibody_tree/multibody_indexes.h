#pragma once

#include "drake/common/drake_assert.h"

#include <iostream>

/// A type-safe `int` that can be associated to a tag name. Different
/// instantiations of TaggedInt are not interconvertible.
/// TaggedInt allows for instantiations from an `int` as well as it allows to
/// convert back to an `int` via its conversion operator.
/// TaggedInt can be used in places where an index is needed and therefore basic
/// operations such as prefix and postfix increment/decrement are implemented.
/// As an example, consider the creation of a tagged index associated with class
/// `Foo`. This can be done in code as: <pre>
///   using FooIndex = TaggedInt<class FooTag>;
/// </pre>
///
/// @tparam Tag The name of the tag associated with a class type.
template <class Tag>
class TaggedInt {
 public:
  DRAKE_DEFAULT_COPY_AND_MOVE_AND_ASSIGN(TaggedInt)

  /// Default constructor intializes `this` to Invalid().
  TaggedInt() : ix(InvalidIndex) {}

  /// Construction from an `int` value.
  /// This constructor aborts if the provided input `int` @p i is negative.
  /// Construction from Invalid() is allowed.
  explicit TaggedInt(int i) : ix(i) {
    DRAKE_ASSERT(i >= 0 || i == InvalidIndex);
  }

  /// Converstion to int operator.
  operator int() const { return ix;}

  /// @name Validity operations/checks.
  ///@{

  /// Returns `true` if this index is greater than or equal to zero.
  /// Otherwise it returns `false`.
  bool is_valid() const { return ix >= 0;}

  /// Returns `true` if this index equals Invalid() and `true` otherwise.
  bool is_invalid() const { return ix == InvalidIndex;}

  /// Sets `this` index to Invalid().
  void invalidate() { ix = InvalidIndex;}

  ///@}

  /// @name Relational operators
  ///@{

  /// Equal to operator.
  bool operator==(int  i) const { return ix == i;}

  /// Not equal to operator.
  bool operator!=(int  i) const { return !operator==(i);}

  /// Less than operator.
  bool operator< (int  i) const { return ix < i;}

  /// Greather than or equal to operator.
  bool operator>=(int  i) const { return !operator<(i);}

  /// Greather than operator.
  bool operator> (int  i) const { return ix > i;}

  /// Less than or equal to operator.
  bool operator<=(int  i) const { return !operator>(i);}
  ///@}

  /// @name Arithmetic operators.
  ///@{

  /// Prefix increment operator.
  const TaggedInt& operator++() {
    DRAKE_ASSERT(is_valid());
    ++ix;
    return *this;
  }

  /// Postfix increment operator.
  TaggedInt operator++(int) {
    DRAKE_ASSERT(is_valid()); ++ix; return TaggedInt(ix-1);
  }

  /// Prefix decrement operator.
  const TaggedInt& operator--() {
    DRAKE_ASSERT(is_valid()); --ix; return *this;
  }

  /// Postfix decrement operator.
  TaggedInt operator--(int) {
    DRAKE_ASSERT(is_valid()); --ix; return TaggedInt(ix+1);
  }
  ///@}

  /// @name Compound assignment operators.
  ///@{

  /// Addition assignment operator.
  TaggedInt& operator+=(int i) {
    DRAKE_ASSERT(is_valid());
    ix += i;
    return *this;
  }

  /// Subtraction assignment operator.
  TaggedInt& operator-=(int i) {
    DRAKE_ASSERT(is_valid());
    ix -= i;
    return *this;
  }
  ///@}

  /// Returns a TaggedInt initialized to an invalid value. Checking with
  /// is_valid() on a TaggedInt set to Invalid() will return `false`.
  static const TaggedInt& Invalid() {
    static const TaggedInt invalid;
    return invalid;
  }

 private:
  int ix;
  static const int InvalidIndex{-1111111111};
};

/// Stream insertion operator to write a TaggedInt into a std::ostream.
/// Invalid TaggedInt's (as generated by TaggedInt::Invalid()) are written to
/// the stream as "Invalid".
template <class Tag>
inline std::ostream& operator<<(
    std::ostream& o, const TaggedInt<Tag>& index) {
  if (index.is_invalid())
    o << "Invalid";
  else
    o << int(index);
  return o;
}

namespace drake {
namespace multibody {

using FrameIndex = TaggedInt<class FrameTag>;
using BodyIndex = TaggedInt<class BodyTag>;
using MobilizerIndex = TaggedInt<class MobilizerTag>;

/// For every MultibodyTree<T> the **world** body _always_ has this unique
/// identifier and it is always zero.
static const BodyIndex kWorldBodyId(0);

}  // namespace multibody
}  // namespace drake
