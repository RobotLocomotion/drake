#include "drake/multibody/plant/contact_results_to_lcm.h"

#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <vector>

#include <fmt/format.h>
#include <gtest/gtest.h>

#include "drake/common/never_destroyed.h"
#include "drake/common/test_utilities/eigen_matrix_compare.h"
#include "drake/geometry/proximity/triangle_surface_mesh.h"
#include "drake/geometry/query_results/contact_surface.h"
#include "drake/lcmt_contact_results_for_viz.hpp"
#include "drake/multibody/plant/contact_results.h"
#include "drake/multibody/plant/multibody_plant.h"
#include "drake/systems/framework/context.h"
#include "drake/systems/framework/diagram_builder.h"
#include "drake/systems/lcm/lcm_publisher_system.h"

namespace drake {

using geometry::ContactSurface;
using geometry::GeometryId;
using geometry::MeshFieldLinear;
using geometry::PenetrationAsPointPair;
using geometry::SceneGraph;
using geometry::Sphere;
using geometry::SurfaceTriangle;
using geometry::TriangleSurfaceMesh;
using math::RigidTransform;
using multibody::internal::GeometryNames;
using std::function;
using std::make_unique;
using std::move;
using std::nullopt;
using std::optional;
using std::string;
using std::unique_ptr;
using std::unordered_map;
using std::vector;
using symbolic::Expression;
using systems::Context;
using systems::DiagramBuilder;

namespace multibody {

namespace {

/* The fixed number of faces in the test mesh for hydroelastic contact. */
constexpr int kNumFaces = 2;
constexpr int kNumPointPerTri = 3;

/* Creates an arbitrary contact surface representing contact between the
 geometries identified by `id_M` and `id_N`. The surface data (vertex positions,
 pressure field) are largely garbage. The value aren't used in math, only to
 be copied and compared. The underlying mesh's vertex positions can be offset
 by the given `offset` value so that we can distinguish between two "different"
 meshes. */
template <typename T>
ContactSurface<T> MakeContactSurface(GeometryId id_M, GeometryId id_N,
                                     const Vector3<T>& offset) {
  /* Create the surface mesh first. It is simply two triangles (make sure we're
   looping through elements). The position of the vertices is offset by offset.
   The position of the vertices is irrelevant -- the mesh is just a collection
   of doubles that get copied. */
  vector<SurfaceTriangle> faces;
  vector<Vector3<T>> vertices;
  vertices.emplace_back(Vector3<double>(0.5, 0.5, -0.5) + offset);
  vertices.emplace_back(Vector3<double>(-0.5, 0.5, -0.5) + offset);
  vertices.emplace_back(Vector3<double>(-0.5, -0.5, -0.5) + offset);
  vertices.emplace_back(Vector3<double>(0.5, -0.5, -0.5) + offset);
  faces.emplace_back(0, 1, 2);
  faces.emplace_back(2, 3, 0);
  auto mesh = make_unique<TriangleSurfaceMesh<T>>(move(faces), move(vertices));

  /* Create the "e" field values (i.e., "hydroelastic pressure") - simply
   increasing values at each vertex. */
  vector<T> e_MN(mesh->num_vertices());
  std::iota(e_MN.begin(), e_MN.end(), 1);

  TriangleSurfaceMesh<T>* mesh_pointer = mesh.get();
  EXPECT_EQ(mesh->num_triangles(), kNumFaces);
  return ContactSurface<T>(
      id_M, id_N, move(mesh),
      make_unique<MeshFieldLinear<T, TriangleSurfaceMesh<T>>>(move(e_MN),
                                                              mesh_pointer));
}

/* Makes quadrature data sufficient for the ContactSurface generated by
 MakeContactSurface(). */
template <typename T>
vector<HydroelasticQuadraturePointData<T>> MakeQuadratureData(
    const Vector3<T>& offset) {
  /* We'll pick *three* quadrature points per triangle, to make sure we get
   proper loop iteration. For simplicitly, we'll explicitly define the first
   quadrature point and then express the others in terms of the first. */
  constexpr int kNumPoints = kNumFaces * kNumPointPerTri;
  vector<HydroelasticQuadraturePointData<T>> quadrature_point_data(kNumPoints);

  quadrature_point_data[0].p_WQ = Vector3<double>(1, 3, 5) + offset;
  quadrature_point_data[0].vt_BqAq_W = Vector3<double>(7, 11, 13) + offset;
  quadrature_point_data[0].traction_Aq_W = Vector3<double>(17, 19, 23) + offset;
  quadrature_point_data[0].face_index = 0;
  for (int i = 1; i < kNumPoints; ++i) {
    quadrature_point_data[i].p_WQ = quadrature_point_data[i - 1].p_WQ + offset;
    quadrature_point_data[i].vt_BqAq_W =
        quadrature_point_data[i - 1].vt_BqAq_W + offset;
    quadrature_point_data[i].traction_Aq_W =
        quadrature_point_data[i - 1].traction_Aq_W + offset;
    quadrature_point_data[i].face_index = i / kNumPointPerTri;
  }
  return quadrature_point_data;
}

/* Retrieves a set of fixed geometry ids -- always the same N values for a given
 N. */
template <int N>
const std::array<GeometryId, N>& GetGeometryIds() {
  static bool initialized = false;
  static std::array<GeometryId, N> ids;
  if (!initialized) {
    initialized = true;
    for (int i = 0; i < N; ++i) {
      ids[i] = GeometryId::get_new_id();
    }
  }
  return ids;
}

/* ContactResultsToLcmSystem basically does two things:

  - Upon construction, save a bunch of data about the population of the given
    MultibodyPlant into one or more tables.
  - In calculating its output value (lcm message), combine input ContactResults
    with the stored tables to make the messages.

 The testing exploits this structure directly. To test the constructor, we'll
 use friend access to examine the internal tables directly -- in other words,
 answer the question: given a plant, do we correctly populate the tables?

 Independently, we'll test the output calculation by asking, given a known
 set of tables, and a known contact result, do we get the expected message?

 Finally, we need to test its scalar support: both in constructing a system as
 well as transmogrifying it. This test harness and the supporting functions are
 all designed to support this testing strategy.

 When constructing T-valued ContactResults, we only use constant values. When
 T = symbolic::Expression, we do not have values that are symbolic::Variables.
 As constants, the tests pass as is, with Variables, they would throw (can't
 extract a double value from a Variable without an environment). This throwing
 behavior is not explicitly tested.

 ContactResults contains various vectors of data (e.g., vertex positions,
 quadrature point data, etc.) The test is *assuming* that the order of the
 data in the input is the order of the data on the output. It simplifies the
 test and only fails if the serialization perturbs the order. */
template <typename T>
class ContactResultsToLcmTest : public ::testing::Test {
 protected:
  /* Adds a body with the given `name` to the given `plant` as part of the given
   model instance.

   @param body_name     The name of the body to add.
   @param model_index   The model instance to which this body will be added.
   @param plant         The plant to add the body to.
   @pre `model_index` is a valid model instance index. */
  void AddBody(const std::string& body_name,
               ModelInstanceIndex model_index,
               MultibodyPlant<T>* plant) {
    plant->AddRigidBody(body_name, model_index, SpatialInertia<double>());
  }

  /* Adds fake point contact results to the given set of contact `results`. */
  template <typename U = T>
  static void AddFakePointPairContact(ContactResults<U>* results) {
    const BodyIndex b0{1};
    const BodyIndex b1{2};
    const BodyIndex b2{3};

    static const never_destroyed<PointPairContactInfo<U>> pair1(
        b0, b1, Vector3<U>{1.1, 2.2, 3.3}, Vector3<U>{4.4, 5.5, 6.6}, 7.7, 8.8,
        PenetrationAsPointPair<U>{
            GeometryId::get_new_id(), GeometryId::get_new_id(),
            Vector3<U>{11.1, 22.2, 33.3}, Vector3<U>{44.4, 55.5, 66.6},
            Vector3<U>{77.7, 88.8, 99.9}, 101.1});
    results->AddContactInfo(pair1.access());
    static const never_destroyed<PointPairContactInfo<U>> pair2(
        b1, b2, Vector3<U>{1.2, 2.3, 3.4}, Vector3<U>{4.5, 5.6, 6.7}, 7.8, 8.9,
        PenetrationAsPointPair<U>{
            GeometryId::get_new_id(), GeometryId::get_new_id(),
            Vector3<U>{11.2, 22.3, 33.4}, Vector3<U>{44.5, 55.6, 66.7},
            Vector3<U>{77.8, 88.9, 99.1}, 101.1});
    results->AddContactInfo(pair2.access());
  }

  /* Adds fake hydro contact results to the given set of contact `results`. */
  template <typename U = T>
  static void AddFakeHydroContact(ContactResults<U>* results) {
    /* Everything here is static because the ContactResults really doesn't own
     any of its data; it keeps pointers to data stored elsewhere. So, we need
     this data to persist, so we keep it function static so it persists through
     the duration of the test. */
    const std::array<GeometryId, 4>& ids = GetGeometryIds<4>();

    /* In creating this fake contact data, what matters *most* is that the body
     indices used map to values in the names we've added above. All other values
     can be meaningless garbage. All that matters is that they are unique values
     such that we can confirm that the right value got written to the right
     field. */
    static const never_destroyed<ContactSurface<U>> surface1(
        MakeContactSurface<U>(ids[0], ids[1], Vector3<U>{1, 2, 3}));
    static const never_destroyed<HydroelasticContactInfo<U>> pair1(
        &surface1.access(),
        SpatialForce<U>(Vector3<U>(1.1, 2.2, 3.3), Vector3<U>(4.4, 5.5, 6.6)),
        MakeQuadratureData<U>(Vector3<U>{1, 2, 3}));
    results->AddContactInfo(&pair1.access());

    static const never_destroyed<ContactSurface<U>> surface2(
        MakeContactSurface<U>(ids[2], ids[3], Vector3<U>{-3, -1, 2}));
    static const never_destroyed<HydroelasticContactInfo<U>> pair2(
        &surface2.access(),
        SpatialForce<U>(Vector3<U>(1.2, 2.3, 3.4), Vector3<U>(4.5, 5.6, 6.7)),
        MakeQuadratureData<U>(Vector3<U>{-3, -1, -2}));
    results->AddContactInfo(&pair2.access());
  }
};

using ScalarTypes = ::testing::Types<double, AutoDiffXd, Expression>;
TYPED_TEST_SUITE(ContactResultsToLcmTest, ScalarTypes);

/* We construct a plant with known contents, instantiate an instance of
 ContactResultsToLcmSystem on it and confirm the internal tables are populated
 as we expect them to be.

 We're exercising the private constructor that takes the geometry-naming
 functor. Accessing that functionality is only *really* available by calling
 ConnectContactResultsToDrakeVisualizer(), but by testing the functor flavor
 of the constructor *here*, we leverage this code for both modes of construction
 and simplify the tests on those functions to simply look for evidence that
 the proper constructor was called (having already shown the constructor to be
 correct). */
TYPED_TEST(ContactResultsToLcmTest, Constructor) {
  using T = TypeParam;

  for (bool use_geometry_names : {true, false}) {
    /* These mirror the internal data tables in ContactResultsToLcmSystem. We'll
     populate them as we populate MBP and confirm that the resulting tables
     match the tables we build by hand. */

    MultibodyPlant<T> plant(0.0);
    /* Bodies 1 and 2 go to the same model instance. Body 3 goes to its own.
      Body 1 gets two geometries (to test the geometry_count field). Bodies 1
      and 3 have the same name (to test body_name_is_unique_field).  */
    const ModelInstanceIndex model12 = plant.AddModelInstance("JustForBody12");

    this->AddBody("dupe_name", model12, &plant);
    this->AddBody("body2", model12, &plant);

    const ModelInstanceIndex model3 = plant.AddModelInstance("JustForBody3");
    this->AddBody("dupe_name", model3, &plant);

    plant.Finalize();

    SCOPED_TRACE(use_geometry_names ? "Using geometry names"
                                    : "Using default names");
    /* Construction should populate tables about bodies. */
    unique_ptr<ContactResultsToLcmSystem<T>> lcm{};
    if (use_geometry_names) {
      lcm = std::make_unique<ContactResultsToLcmSystem<T>>(
          plant, scene_graph.model_inspector());
    } else {
      lcm = std::make_unique<ContactResultsToLcmSystem<T>>(plant);
    }

    /* Examine the constructed tables. */
    // XXX ummm ....

    /* We'll further confirm that the system has its default name and ports
     available. */
    EXPECT_EQ(lcm->get_name(), "ContactResultsToLcmSystem");
    EXPECT_NO_THROW(lcm->get_contact_result_input_port());
    EXPECT_NO_THROW(lcm->get_lcm_message_output_port());
  }
}

/* Confirms that empty ContactResults produces an empty message. */
TYPED_TEST(ContactResultsToLcmTest, EmptyContactResults) {
  using T = TypeParam;

  /* We're not going to populate the plant, because we're going to set the
   internal tables by hand and fix the input for the context. */
  MultibodyPlant<T> plant(0.0);
  plant.Finalize();
  ContactResultsToLcmSystem<T> lcm(plant);
  const unique_ptr<Context<T>> context = lcm.AllocateContext();

  const double kTime = 1.5;
  context->SetTime(kTime);
  lcm.get_contact_result_input_port().FixValue(context.get(),
                                               ContactResults<T>{});

  /* We'll do this twice, once with *empty* internal tables, and once with
   tables with values. We want to make sure that empty contact, even with
   populated tables is not a problem. */
  auto confirm_empty = [&lcm, &context = *context, kTime]() {
    const auto& message =
        lcm.get_lcm_message_output_port()
            .template Eval<lcmt_contact_results_for_viz>(context);

    // Message time is an integer number of microseconds.
    const double kTimeMicroSec = static_cast<int64_t>(kTime * 1e6);
    EXPECT_EQ(message.timestamp, kTimeMicroSec);
    EXPECT_EQ(message.num_point_pair_contacts, 0);
    EXPECT_EQ(message.point_pair_contact_info.size(), 0);
    EXPECT_EQ(message.num_hydroelastic_contacts, 0);
    EXPECT_EQ(message.hydroelastic_contacts.size(), 0);
  };

  {
    SCOPED_TRACE("With empty tables");
    confirm_empty();
  }

  /* Add some content to the tables and try again. The actual content is
   arbitrary garbage. */
  {
    // XXX
    SCOPED_TRACE("With populated tables");
    confirm_empty();
  }
}

/* Tests the case where ContactResults contains *only* point-pair data. This
 test bears primary responsibility to make sure that point pair data is
 serialized correctly.

 Translation of point pair contact results to lcm message is straightforward.
 There are *three* things that this system does in the process:

   - Extracts double values from T-Valued quantities.
   - Looks up body names based on *body indices*.
   - Writes various Vector3 quantities (forces, positions, etc. -- all Vector3-
     valued data, but with different semantics). We'll want to make sure that
     each Vector3-valued quantity gets mapped to the right part of the message,
     because type checking isn't going to do it for us.

 As such, we don't need much for this test. We'll do two point-pair contacts
 with unique values to confirm successful iteration and copying. */
TYPED_TEST(ContactResultsToLcmTest, PointPairContactOnly) {
  using T = TypeParam;

  /* We're not going to populate the plant, because we're going to set the
   internal tables by hand and fix the input for the context. */
  MultibodyPlant<T> plant(0.0);
  plant.Finalize();
  ContactResultsToLcmSystem<T> lcm(plant);
  const unique_ptr<Context<T>> context = lcm.AllocateContext();

  /* The time *also* gets set inside the per-point-pair messages. We want to
   detect that. */
  const double kTime = 1.5;
  context->SetTime(kTime);
  ContactResults<T> contacts;
  this->AddFakePointPairContact(&contacts);
  lcm.get_contact_result_input_port().FixValue(context.get(), contacts);

  const auto& message =
      lcm.get_lcm_message_output_port()
          .template Eval<lcmt_contact_results_for_viz>(*context);

  EXPECT_EQ(message.num_point_pair_contacts, 2);
  EXPECT_EQ(message.point_pair_contact_info.size(), 2);
  EXPECT_EQ(message.num_hydroelastic_contacts, 0);
  EXPECT_EQ(message.hydroelastic_contacts.size(), 0);

  /* Test the message for a point pair contact against the input point pair
   data. */
  auto confirm_message = [kTime](
                             const lcmt_contact_results_for_viz& message_in,
                             const ContactResults<T>& contacts_in, int i) {
    // Message time is an integer number of microseconds.
    const double kTimeMicroSec = static_cast<int64_t>(kTime * 1e6);
    const auto& pair_message = message_in.point_pair_contact_info[i];
    const auto& pair_data = contacts_in.point_pair_contact_info(i);

    EXPECT_EQ(pair_message.timestamp, kTimeMicroSec);
#if 0  // XXX
    EXPECT_EQ(pair_message.body1_name, body_names[pair_data.bodyA_index()]);
    EXPECT_EQ(pair_message.body2_name, body_names[pair_data.bodyB_index()]);
#endif
    // clang-format off
    EXPECT_TRUE(CompareMatrices(
        Vector3<double>(pair_message.contact_point),
        ExtractDoubleOrThrow(pair_data.contact_point())));
    EXPECT_TRUE(CompareMatrices(
        Vector3<double>(pair_message.contact_force),
        ExtractDoubleOrThrow(pair_data.contact_force())));
    EXPECT_TRUE(CompareMatrices(
        Vector3<double>(pair_message.normal),
        ExtractDoubleOrThrow(pair_data.point_pair().nhat_BA_W)));
    // clang-format on
    /* None of the rest of the pair data makes it to the message. */
  };

  for (int c = 0; c < 2; ++c) {
    SCOPED_TRACE(fmt::format("Penetration point pair {} out of 2", (c + 1)));
    confirm_message(message, contacts, c);
  }
}

/* Tests the case where ContactResults contains *only* hydroelastic data. This
 test bears primary responsibility to make sure that hydroelastic data is
 serialized correctly.

 Translation of hydroelastic contact results to lcm message is straightforward.
 There are *three* things that this system does in the process:

   - Extracts double values from T-Valued quantities.
   - Looks up body names based on geometry ids.
   - Writes various Vector3 quantities (forces, positions, etc. -- all Vector3-
     valued data, but with different semantics). We'll want to make sure that
     each Vector3-valued quantity gets mapped to the right part of the message,
     because type checking isn't going to do it for us.

 As such, we don't need much for this test. We'll do two hydroelastic contacts
 with unique values to confirm successful iteration and copying. */
TYPED_TEST(ContactResultsToLcmTest, HydroContactOnly) {
  using T = TypeParam;

  /* We're not going to populate the plant, because we're going to set the
   internal tables by hand and fix the input for the context. */
  MultibodyPlant<T> plant(0.0);
  plant.Finalize();
  ContactResultsToLcmSystem<T> lcm(plant);
  const unique_ptr<Context<T>> context = lcm.AllocateContext();

  /* Hydroelastic contact doesn't store time; so we'll leave it alone. */
  ContactResults<T> contacts;
  this->AddFakeHydroContact(&contacts);
  lcm.get_contact_result_input_port().FixValue(context.get(), contacts);

  const auto& message =
      lcm.get_lcm_message_output_port()
          .template Eval<lcmt_contact_results_for_viz>(*context);

  EXPECT_EQ(message.num_point_pair_contacts, 0);
  EXPECT_EQ(message.point_pair_contact_info.size(), 0);
  EXPECT_EQ(message.num_hydroelastic_contacts, 2);
  EXPECT_EQ(message.hydroelastic_contacts.size(), 2);

  /* Test the message for hydro contact against the input hydro data. */
  auto confirm_message = [](const lcmt_contact_results_for_viz& message_in,
                            const ContactResults<T>& contacts_in, int i) {
    const auto& pair_message = message_in.hydroelastic_contacts[i];
    const auto& pair_data = contacts_in.hydroelastic_contact_info(i);
    const auto& surface = pair_data.contact_surface();
    const auto& mesh = surface.tri_mesh_W();
    const auto& field = surface.tri_e_MN();

#if 0
    const auto& name1 = geo_to_body_map.at(surface.id_M());
    EXPECT_EQ(pair_message.body1_name, name1.body);
    EXPECT_EQ(pair_message.model1_name, name1.model);
    EXPECT_EQ(pair_message.geometry1_name, name1.geometry);
    EXPECT_EQ(pair_message.body1_unique, name1.body_name_is_unique);
    EXPECT_EQ(pair_message.collision_count1, name1.geometry_count);

    const auto& name2 = geo_to_body_map.at(surface.id_N());
    EXPECT_EQ(pair_message.body2_name, name2.body);
    EXPECT_EQ(pair_message.model2_name, name2.model);
    EXPECT_EQ(pair_message.geometry2_name, name2.geometry);
    EXPECT_EQ(pair_message.body2_unique, name2.body_name_is_unique);
    EXPECT_EQ(pair_message.collision_count2, name2.geometry_count);
#endif

    /* Mesh aggregate results: centroid, force, moment. */
    // clang-format off
    EXPECT_TRUE(CompareMatrices(
        Vector3<double>(pair_message.centroid_W),
        ExtractDoubleOrThrow(mesh.centroid())));
    EXPECT_TRUE(CompareMatrices(
        Vector3<double>(pair_message.force_C_W),
        ExtractDoubleOrThrow(pair_data.F_Ac_W().translational())));
    EXPECT_TRUE(CompareMatrices(
        Vector3<double>(pair_message.moment_C_W),
        ExtractDoubleOrThrow(pair_data.F_Ac_W().rotational())));
    // clang-format on

    /* Compare meshes and pressure fields. */

    /* Confirm vertices (count and values) and per-vertex pressure values. */
    EXPECT_EQ(static_cast<int>(pair_message.pressure.size()),
              mesh.num_vertices());
    EXPECT_EQ(pair_message.num_vertices, mesh.num_vertices());
    EXPECT_EQ(static_cast<int>(pair_message.p_WV.size()), mesh.num_vertices());
    for (int v = 0; v < mesh.num_vertices(); ++v) {
      const auto& point_WV = pair_message.p_WV[v];
      const Vector3<double> p_WV_message(point_WV.x, point_WV.y, point_WV.z);
      EXPECT_TRUE(CompareMatrices(p_WV_message, mesh.vertex(v)));
      EXPECT_EQ(pair_message.pressure[v], field.EvaluateAtVertex(v));
    }

    /* Confirm faces. Each triangle produces a sequence that looks like:
    // [3, i0, i1, i2] in the face data. Confirm size and contents. */
    ASSERT_EQ(pair_message.poly_data_int_count, mesh.num_triangles() * 4);
    ASSERT_EQ(pair_message.poly_data.size(), mesh.num_triangles() * 4);

    int index = -1;
    for (int f = 0; f < mesh.num_triangles(); ++f) {
      const auto& tri = mesh.element(f);
      ASSERT_EQ(pair_message.poly_data[++index], 3);
      ASSERT_EQ(pair_message.poly_data[++index], tri.vertex(0));
      ASSERT_EQ(pair_message.poly_data[++index], tri.vertex(1));
      ASSERT_EQ(pair_message.poly_data[++index], tri.vertex(2));
    }

    /* Compare quadrature data. */
    const auto& data_quads = pair_data.quadrature_point_data();
    const auto& message_quads = pair_message.quadrature_point_data;
    EXPECT_EQ(pair_message.num_quadrature_points, data_quads.size());
    EXPECT_EQ(message_quads.size(), data_quads.size());
    EXPECT_EQ(pair_message.num_quadrature_points,
              mesh.num_triangles() * kNumPointPerTri);
    for (int q = 0; q < static_cast<int>(data_quads.size()); ++q) {
      // clang-format off
      EXPECT_TRUE(CompareMatrices(
        Vector3<double>(message_quads[q].p_WQ),
        ExtractDoubleOrThrow(data_quads[q].p_WQ)));
      EXPECT_TRUE(CompareMatrices(
        Vector3<double>(message_quads[q].vt_BqAq_W),
        ExtractDoubleOrThrow(data_quads[q].vt_BqAq_W)));
      EXPECT_TRUE(CompareMatrices(
        Vector3<double>(message_quads[q].traction_Aq_W),
        ExtractDoubleOrThrow(data_quads[q].traction_Aq_W)));
      // clang-format on
    }
  };

  for (int c = 0; c < 2; ++c) {
    SCOPED_TRACE(fmt::format("Hydro contact {} out of 2", (c + 1)));
    confirm_message(message, contacts, c);
  }
}

/* Tests the case where ContactResults contains mixed data. This test assumes
 that point and hydro data, if represented *at all*, are represented correctly.
 It just attempts to confirm that the two result types don't interfere.
 Correctness of the serialization of each type relies on previous tests. */
TYPED_TEST(ContactResultsToLcmTest, MixedContactData) {
  using T = TypeParam;

  /* We're not going to populate the plant, because we're going to set the
   internal tables by hand and fix the input for the context. */
  MultibodyPlant<T> plant(0.0);
  plant.Finalize();
  ContactResultsToLcmSystem<T> lcm(plant);
  const unique_ptr<Context<T>> context = lcm.AllocateContext();

  ContactResults<T> contacts;
  this->AddFakePointPairContact(&contacts);
  this->AddFakeHydroContact(&contacts);
  lcm.get_contact_result_input_port().FixValue(context.get(), contacts);

  const auto& message =
      lcm.get_lcm_message_output_port()
          .template Eval<lcmt_contact_results_for_viz>(*context);

  EXPECT_EQ(message.num_point_pair_contacts, 2);
  EXPECT_EQ(message.point_pair_contact_info.size(), 2);
  EXPECT_EQ(message.num_hydroelastic_contacts, 2);
  EXPECT_EQ(message.hydroelastic_contacts.size(), 2);
  /* Knowing that we have the right *numbers* of contact results suffices. We
   assume if the serialization got that far, it did the right thing at the
   detail level based on previous tests. */
}

/* Previous tests confirmed that construction ContactResultsToLcmSystem for
 various T works. This confirms that transmogrifying from double likewise
 works.

 ContactResultsToLcmSystem provides a private Equal() method to compare systems.
 This is a good minimum condition, but we also use a smoke test that things are
 correct -- we want to make sure the transmogrified result is *functional*.

 Starting with a double-valued system, we'll transmogrify it, allocate a
 context, fix a non-empty contact result to the input port, evaluate the output
 port, and make sure things got serialized. */
TYPED_TEST(ContactResultsToLcmTest, Transmogrifcation) {
  using T = TypeParam;

  MultibodyPlant<double> plant(0.0);
  plant.Finalize();
  auto custom_names = [](GeometryId id) {
    return fmt::format("String that must be copied to match {}", id);
  };
  auto lcm_double = std::make_unique<ContactResultsToLcmSystem<T>>(
      plant, scene_graph.model_inspector());
  lcm_double->set_name("Ad hoc name");

  /* We don't care about double-valued results, we're just using it to
   populate the tables in lcm_double. These will get copied over. */
  ContactResults<double> contacts_double;
  this->AddFakePointPairContact(&contacts_double);
  this->AddFakeHydroContact(&contacts_double);

  auto system_T = [&double_source = *lcm_double]() {
    if constexpr (std::is_same_v<T, double>) {
      /* We support AutoDiffXd -> double. So, when T is double, we'll convert to
       AutoDiffXd and *back*. Obviously if double -> AutoDiffXd is broken both
       that specific test and this test will fail. */
      return double_source.ToAutoDiffXd()->template ToScalarType<double>();
    } else {
      return double_source.template ToScalarType<T>();
    }
  }();
  ContactResultsToLcmSystem<T>* lcm_T =
      dynamic_cast<ContactResultsToLcmSystem<T>*>(system_T.get());
  ASSERT_NE(lcm_T, nullptr);

  // umm ....
  // EXPECT_TRUE(ContactResultsToLcmTester::Equals(*lcm_double, *lcm_T));

  ContactResults<T> contacts;
  this->template AddFakePointPairContact<T>(&contacts);
  this->template AddFakeHydroContact<T>(&contacts);
  const unique_ptr<Context<T>> context = lcm_T->AllocateContext();
  lcm_T->get_contact_result_input_port().FixValue(context.get(), contacts);

  const auto& message =
      lcm_T->get_lcm_message_output_port()
          .template Eval<lcmt_contact_results_for_viz>(*context);

  EXPECT_EQ(message.num_point_pair_contacts, 2);
  EXPECT_EQ(message.point_pair_contact_info.size(), 2);
  EXPECT_EQ(message.num_hydroelastic_contacts, 2);
  EXPECT_EQ(message.hydroelastic_contacts.size(), 2);
}

/* There are two overloads of ConnectContactResultsToDrakeVisualizer(). They
 differ in whether we connect directly to the plant, or else to some arbitrary
 passed OutputPort. This fixture supports easy test of all overloads.
 */
class ConnectVisualizerTest : public ::testing::Test {
 protected:
  void AddPlantAndSceneGraph() {
    auto system_pair = AddMultibodyPlantSceneGraph(&builder_, 0.0);
    plant_ = &system_pair.plant;
    scene_graph_ = &system_pair.scene_graph;
    plant_->Finalize();
  }

  DiagramBuilder<double> builder_;
  MultibodyPlant<double>* plant_{};
  SceneGraph<double>* scene_graph_{};
};

TEST_F(ConnectVisualizerTest, ToPlant) {
  AddPlantAndSceneGraph();
  auto* publisher =
      ConnectContactResultsToDrakeVisualizer(&builder_, *plant_, *scene_graph_);
  ASSERT_NE(publisher, nullptr);
}

TEST_F(ConnectVisualizerTest, ToPort) {
  AddPlantAndSceneGraph();
  auto* publisher = ConnectContactResultsToDrakeVisualizer(
      &builder_, *plant_, *scene_graph_, *contact_results_port_);
  ASSERT_NE(publisher, nullptr);
}

TEST_F(ConnectVisualizerTest, ToPlantWithPeriod) {
  AddPlantAndSceneGraph();
  auto* publisher = ConnectContactResultsToDrakeVisualizer(
      &builder_, *plant_, *scene_graph_, nullptr, 0.5);
  ASSERT_NE(publisher, nullptr);
  EXPECT_EQ(publisher->get_publish_period(), 0.5);
}

TEST_F(ConnectVisualizerTest, ToPortWithPeriod) {
  AddPlantAndSceneGraph();
  auto* publisher = ConnectContactResultsToDrakeVisualizer(
      &builder_, *plant_, *scene_graph_, *contact_results_port_, nullptr, 0.5);
  ASSERT_NE(publisher, nullptr);
  EXPECT_EQ(publisher->get_publish_period(), 0.5);
}

}  // namespace
}  // namespace multibody
}  // namespace drake
