#pragma once

#include <memory>
#include <vector>

#include "drake/common/autodiff.h"
#include "drake/common/drake_assert.h"
#include "drake/common/drake_copyable.h"
#include "drake/common/unused.h"
#include "drake/multibody/math/spatial_force.h"
#include "drake/multibody/tree/multibody_element.h"
#include "drake/multibody/tree/multibody_forces.h"
#include "drake/multibody/tree/multibody_tree_indexes.h"
#include "drake/multibody/tree/multibody_tree_topology.h"
#include "drake/multibody/tree/position_kinematics_cache.h"
#include "drake/multibody/tree/velocity_kinematics_cache.h"

namespace drake {
namespace multibody {

/// A %ForceElement allows modeling state and time dependent forces in a
/// multibody model. Examples of such forces are springs, dampers, drag and
/// gravity. Forces that depend on accelerations such as virtual mass cannot be
/// modeled with a %ForceElement.
/// This abstract class provides a number of APIs that all force elements
/// subclasses must implement in order to be fully defined. These are:
///
/// - DoAddForceContribution(): computes the force of the force element and adds
///   its contribution.
/// - DoCalcPotentialEnergy(): computes a force element potential energy
///   contribution.
/// - DoCalcConservativePower(): computes the power generated by conservative
///   forces.
/// - DoCalcNonConservativePower(): computes the power dissipated by
///   non-conservative forces.
///
/// The implementation of DoAddForceContribution() is the **minimum
/// requirement** to have a functional force element.
///
/// The implementation of energy budget methods is optional, though an attempt
/// to call their NVIs will result on a runtime exception.
///
/// Scalar conversion is enabled by providing an implementation to DoToDouble(),
/// DoToAutoDiffXd() and DoToSymbolic().
///
/// @tparam_default_scalar
template <typename T>
class ForceElement
    : public MultibodyElement<ForceElement, T, ForceElementIndex> {
 public:
  DRAKE_NO_COPY_NO_MOVE_NO_ASSIGN(ForceElement)

  /// Default constructor for a generic force element.
  explicit ForceElement(ModelInstanceIndex model_instance)
      : MultibodyElement<ForceElement, T, ForceElementIndex>(model_instance) {}

  /// Computes the force contribution for `this` force element and **adds** into
  /// `forces`.
  ///
  /// @param[in] context
  ///   The context containing the state of the model.
  /// @param[out] forces
  ///   A pointer to a valid, non nullptr, multibody forces object.
  ///   On output `this` force element adds its contribution into `forces`.
  ///   This method will abort if the `forces` pointer is null or if the
  ///   forces object is not compatible with `this` element's parent model, see
  ///   MultibodyForces::CheckInvariants().
  void AddForceContribution(const systems::Context<T>& context,
                            MultibodyForces<T>* forces) const {
    DRAKE_DEMAND(forces != nullptr);
    DRAKE_DEMAND(forces->CheckHasRightSizeForModel(this->get_parent_tree()));
    DoAddForceContribution(context, &*forces);
  }

  /// @name Methods to track the energy budget.
  /// The methods in this group are used to track the transfer of energy within
  /// a multibody model.
  //@{

  /// Calculates the potential energy currently stored given the configuration
  /// provided in `context`. Non-conservative force elements will return zero.
  /// @param[in] context
  ///   The context containing the state of the %MultibodyTree model.
  ///
  /// @returns For conservative force models, the potential energy stored by
  /// `this` force element. For non-conservative force models, zero.
  ///
  /// @see CalcConservativePower()
  T CalcPotentialEnergy(const systems::Context<T>& context) const {
    return DoCalcPotentialEnergy(context);
  }

  /// Calculates and returns the power generated by conservative force elements
  /// or zero if `this` force element is non-conservative. This quantity is
  /// defined to be positive when the potential energy is decreasing. In other
  /// words, if `PE` is the potential energy as defined by
  /// CalcPotentialEnergy(), then the conservative power, `Pc`, is
  /// `Pc = -d(PE)/dt`.
  ///
  /// @see CalcPotentialEnergy(), CalcNonConservativePower()
  T CalcConservativePower(const systems::Context<T>& context) const {
    return DoCalcConservativePower(context);
  }

  /// Calculates the rate at which mechanical energy is being generated
  /// (positive) or dissipated (negative) *other than* by conversion between
  /// potential and kinetic energy. Integrating this quantity yields work W, and
  /// the total energy `E = PE + KE - W` should be conserved by any
  /// physically-correct model, to within integration accuracy of W.
  /// @see CalcConservativePower()
  T CalcNonConservativePower(const systems::Context<T>& context) const {
    return DoCalcNonConservativePower(context);
  }

  // End of group on energy budget tracking.
  //@}

  /// @cond
  // The set of methods within this @cond are here for backwards compatibility
  // with previous API and will soon be deprecated. Do not use them in your code
  // nor attempt to override virtual methods in this block.
  // For all purposes, you can (and should) ignore these methods.

  // TODO(amcastro-tri): deprecate once all force elements in Drake are
  // converted to use new API.
  void CalcAndAddForceContribution(
      const systems::Context<T>& context,
      const internal::PositionKinematicsCache<T>& pc,
      const internal::VelocityKinematicsCache<T>& vc,
      MultibodyForces<T>* forces) const {
    DRAKE_DEMAND(forces != nullptr);
    DRAKE_DEMAND(forces->CheckHasRightSizeForModel(this->get_parent_tree()));
    DoCalcAndAddForceContribution(context, pc, vc, forces);
  }

  // TODO(amcastro-tri): deprecate once all force elements in Drake are
  // converted to use new API.
  virtual T CalcPotentialEnergy(
      const systems::Context<T>& context,
      const internal::PositionKinematicsCache<T>&) const {
    return DoCalcPotentialEnergy(context);
  }

  // TODO(amcastro-tri): deprecate once all force elements in Drake are
  // converted to use new API.
  virtual T CalcConservativePower(
      const systems::Context<T>& context,
      const internal::PositionKinematicsCache<T>&,
      const internal::VelocityKinematicsCache<T>&) const {
    return DoCalcConservativePower(context);
  }

  // TODO(amcastro-tri): deprecate once all force elements in Drake are
  // converted to use new API.
  virtual T CalcNonConservativePower(
      const systems::Context<T>& context,
      const internal::PositionKinematicsCache<T>&,
      const internal::VelocityKinematicsCache<T>&) const {
    return DoCalcNonConservativePower(context);
  }
  /// @endcond

  /// @cond
  // For internal use only.
  // NVI to DoCloneToScalar() templated on the scalar type of the new clone to
  // be created. This method is intended to be called by
  // MultibodyTree::CloneToScalar().
  template <typename ToScalar>
  std::unique_ptr<ForceElement<ToScalar>> CloneToScalar(
      const internal::MultibodyTree<ToScalar>& cloned_tree) const {
    return DoCloneToScalar(cloned_tree);
  }
  /// @endcond

 protected:
  /// Implementation of Non Virtual Interface AddForceContribution(). Therefore
  /// `forces` is already a valid non-nullptr object for this element.
  /// Custom force elements must implement this method as the minimum
  /// requirement to have a functional force element method.
  /// These models usually come in one of two flavors:
  /// 1. Body forces, E.g. fluid drag or linear springs. In this case, the
  ///    override will compute a SpatialForce to be applied on a given body and
  ///    will add its contribution with the method Body::AddInForceInWorld().
  /// 2. Joint forces, E.g. joint viscous damping or compliant joint limits. In
  ///    this case the override will most likely compute a torque or force that
  ///    can properly be added into `forces` via Joint::AddInOneForce().
  /// @note The default implemention for this method throws an exception. Custom
  /// force elements created by inheritance must implement this method.
  // TODO(amcastro-tri): Make this method a pure virtual once
  // DoCalcAndAddForceContribution() and its NVI are removed after their
  // deprecation period, see #13350.
  virtual void DoAddForceContribution(const systems::Context<T>& context,
                                      MultibodyForces<T>* forces) const {
    unused(context);
    unused(forces);
    throw std::runtime_error(
        "DoAddForceContribution() not implemtend. You must provide an "
        "implementation to have a function custom force element.");
  }

  /// @name Virtual methods for tracking the energy budget.
  /// The methods in this group are used to track the transfer of energy within
  /// a multibody model. Subclasses must provide an implementation if the
  /// tracking of energy budgets is desired (strongly recommended, whenever
  /// possible). Conservative force elements must implement
  /// DoCalcPotentialEnergy() in order to track the potential energy stored in
  /// force elements. In addition, conservative force elements must implement
  /// the rate of change of this potential energy in DoCalcConservativePower().
  /// Non-conservative force elements need to implement the rate of change,
  /// power, at which they either generate or dissipate energy in the system in
  /// DoCalcNonConservativePower(). Note that a force element may have both
  /// conservative and non-conservative contributions, such as a spring-damper
  /// element for instance.
  ///
  /// The default implementation for these methods throws an exception.
  //@{

  /// Overrides must implement the potential energy stored in `this` force
  /// element. Refer to its Non Virtual Interface CalcPotentialEnergy() for
  /// details.
  virtual T DoCalcPotentialEnergy(const systems::Context<T>&) const {
    throw std::logic_error("DoCalcPotentialEnergy() not implemented.");
  }

  /// Overrides must implement the work performed by conservative forces. Refer
  /// to its Non Virtual Interface CalcConservativePower() for details and
  /// specifically sign conventions.
  virtual T DoCalcConservativePower(const systems::Context<T>&) const {
    throw std::logic_error("DoCalcConservativePower() not implemented.");
  }

  /// Overrides must implement the work performed by non-conservative forces.
  /// Refer to its Non Virtual Interface CalcNonConservativePower() for details
  /// and specifically sign conventions.
  virtual T DoCalcNonConservativePower(const systems::Context<T>&) const {
    throw std::logic_error("DoCalcNonConservativePower() not implemented.");
  }
  //@}

  /** @name Scalar conversion
   Specific force element subclasses must implement these to support scalar
   conversion to other types. Consider the following example for a
   `SpringElement<T>` used to model an elastic spring between two bodies:
   @code
     template <typename T>
     class SpringElement : public ForceElement<T> {
      public:
       // Class's constructor.
       SpringElement(
         const Body<T>& body1, const Body<T>& body2, double stiffness) :
         SpringElement(body1.index(), body2.index(), stiffness) {}

      private:
       // Make SpringElement templated on every other scalar type a friend of
       // SpringElement<T> so that scalar conversion methods can access
       // private members of SpringElement<T>.
       template <typename>
       friend class SpringElement;

       // Scalar type agnostic constructor.
       SpringElement(
         BodyIndex body1_index, BodyIndex body2_index, double stiffness) :
         body1_index_(body1_index),
         body2_index_(body2_index),
         stiffness_(stiffness) {}

       // Scalar conversion to AutoDiffXd.
       std::unique_ptr<ForceElement<AutoDiffXd>> DoToAutoDiffXd() const {
         // N.B. We can't use std::make_unique here since this constructor is
         // private to std::make_unique.
         std::unique_ptr<SpringElement<AutoDiffXd>> spring_ad(
           new SpringElement<AutoDiffXd>(
               body1_index_, body2_index_, stiffness_));
         return spring_ad;
       }

       // Similarly with DoToDouble() and DoToSymbolic() methods...

       BodyIndex body1_index_;
       BodyIndex body2_index_;
       double stiffness_;
     };
   @endcode
  */
  /// @{

  /// Scalar converts `this` %ForceElement (templated on T) to a force element
  /// templated on `double`.
  virtual std::unique_ptr<ForceElement<double>> DoToDouble() const {
    throw std::logic_error("This element does not implement DoToDouble().");
  }

  /// Scalar converts `this` %ForceElement (templated on T) to a force element
  /// templated on AutoDiffXd.
  virtual std::unique_ptr<ForceElement<AutoDiffXd>> DoToAutoDiffXd() const {
    throw std::logic_error("This element does not implement DoToAutoDiffXd().");
  }

  /// Scalar converts `this` %ForceElement (templated on T) to a force element
  /// templated on symbolic::Expression.
  virtual std::unique_ptr<ForceElement<symbolic::Expression>> DoToSymbolic()
      const {
    throw std::logic_error("This element does not implement DoToSymbolic().");
  }
  /// @}

  /// @cond
  // The set of methods within this @cond are here for backwards compatibility
  // with previous API and will soon be deprecated. Do not use them in your code
  // nor attempt to override virtual methods in this block.
  // For all purposes, you can (and should) ignore these methods.

  // TODO(amcastro-tri): deprecate once all force elements in Drake are
  // converted to use new API, see #13350.
  virtual void DoCalcAndAddForceContribution(
      const systems::Context<T>& context,
      const internal::PositionKinematicsCache<T>&,
      const internal::VelocityKinematicsCache<T>&,
      MultibodyForces<T>* forces) const {
    DoAddForceContribution(context, &*forces);
  }

  virtual std::unique_ptr<ForceElement<double>> DoCloneToScalar(
      const internal::MultibodyTree<double>&) const {
    return DoToDouble();
  }

  virtual std::unique_ptr<ForceElement<AutoDiffXd>> DoCloneToScalar(
      const internal::MultibodyTree<AutoDiffXd>&) const {
    return DoToAutoDiffXd();
  }

  virtual std::unique_ptr<ForceElement<symbolic::Expression>> DoCloneToScalar(
      const internal::MultibodyTree<symbolic::Expression>&) const {
    return DoToSymbolic();
  }
  /// @endcond

 private:
  // Implementation for MultibodyElement::DoSetTopology().
  // At MultibodyTree::Finalize() time, each force element retrieves its
  // topology from the parent MultibodyTree.
  void DoSetTopology(const internal::MultibodyTreeTopology&) final {}
};

}  // namespace multibody
}  // namespace drake
