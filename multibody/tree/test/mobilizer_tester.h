#pragma once

#include <limits>
#include <memory>
#include <utility>

#include <gtest/gtest.h>

#include "drake/multibody/tree/mobilizer.h"
#include "drake/multibody/tree/multibody_tree.h"
#include "drake/multibody/tree/multibody_tree_system.h"
#include "drake/multibody/tree/rigid_body.h"
#include "drake/systems/framework/context.h"

namespace drake {
namespace multibody {
namespace internal {

// Helper fixture to setup a simple MBT model containing a single body
// connected to World by a Joint. When we finalize, the Joint will be
// implemented with a corresponding Mobilizer.
class MobilizerTester : public ::testing::Test {
 public:
  // Creates a simple model consisting of a single body with a
  // Joint connecting it to World, with the sole purpose of verifying
  // the mobilizer methods.
  MobilizerTester() {
    // Spatial inertia for adding a body. The actual value is not important for
    // these tests since they are all kinematic.
    const auto M_B = SpatialInertia<double>::NaN();

    // Create an empty model.
    owned_tree_ = std::make_unique<MultibodyTree<double>>();
    tree_ = owned_tree_.get();

    // Add a body so we can add a mobilizer to it.
    body_ = &owned_tree_->AddRigidBody("body", M_B);
  }

  // Adds a Joint, then finalizes to get a model using a Mobilizer and
  // returns a reference to that Mobilizer.
  template <template <typename> class JointType,
            template <typename> class MobilizerType>
  const MobilizerType<double>& AddJointAndFinalize(
      std::unique_ptr<JointType<double>> joint) {
    // Add a joint between the world and the body:
    const JointType<double>& joint_ref =
        owned_tree_->AddJoint(std::move(joint));

    // We are done adding modeling elements. Transfer tree to system,
    // finalize, and get a Context.
    system_ =
        std::make_unique<MultibodyTreeSystem<double>>(std::move(owned_tree_));
    context_ = system_->CreateDefaultContext();

    const Mobilizer<double>& mobilizer = joint_ref.GetMobilizerInUse();
    const auto* typed_mobilizer =
        dynamic_cast<const MobilizerType<double>*>(&mobilizer);
    DRAKE_DEMAND(typed_mobilizer != nullptr);
    return *typed_mobilizer;
  }

  const MultibodyTree<double>& tree() const { return *tree_; }
  MultibodyTree<double>& mutable_tree() { return *tree_; }

 protected:
  std::unique_ptr<MultibodyTreeSystem<double>> system_;
  std::unique_ptr<systems::Context<double>> context_;
  const RigidBody<double>* body_{nullptr};

 private:
  // This unique_ptr is only valid between construction and the call to
  // AddJointAndFinalize(). After AddJointAndFinalize() it is an
  // invalid nullptr.
  std::unique_ptr<MultibodyTree<double>> owned_tree_;
  MultibodyTree<double>* tree_{nullptr};
};

// Test that the mobilizer-specific pre- and post-multiply by X_FM works
// correctly. Must be given an X_FM generated by the same mobilizer so that
// it has the expected structure.
template <typename T, class ConcreteMobilizer>
void TestPrePostMultiplyByX_FM(const math::RigidTransform<T>& X_FM,
                               const ConcreteMobilizer& mobilizer) {
  const double kTol = 4 * std::numeric_limits<double>::epsilon();
  // A and B here are frames with arbitrary poses with respect to F and M.
  const math::RigidTransformd X_AF(math::RollPitchYawd(1, 2, 3),
                                   Eigen::Vector3d(4, 5, 6));
  const math::RigidTransformd X_MB = X_AF;  // arbitrary
  const math::RigidTransformd X_AM =
      mobilizer.post_multiply_by_X_FM(X_AF, X_FM);
  const math::RigidTransformd X_FB = mobilizer.pre_multiply_by_X_FM(X_FM, X_MB);
  EXPECT_TRUE(X_AM.IsNearlyEqualTo(X_AF * X_FM, kTol));
  EXPECT_TRUE(X_FB.IsNearlyEqualTo(X_FM * X_MB, kTol));
}

// Test that the mobilizer-specific apply_R_FM() works correctly. Must be given
// an X_FM generated by the same mobilizer so that it has the expected
// structure.
template <typename T, class ConcreteMobilizer>
void TestApplyR_FM(const math::RigidTransform<T>& X_FM,
                   const ConcreteMobilizer& mobilizer) {
  const double kTol = 4 * std::numeric_limits<double>::epsilon();

  const math::RotationMatrixd& R_FM = X_FM.rotation();
  const Eigen::Vector3d v_M(1, 2, 3);
  const Eigen::Vector3d expected_v_F = R_FM * v_M;
  const Eigen::Vector3d v_F = mobilizer.apply_R_FM(R_FM, v_M);
  EXPECT_TRUE(
      CompareMatrices(v_F, expected_v_F, kTol, MatrixCompareType::relative));
}

}  // namespace internal
}  // namespace multibody
}  // namespace drake
