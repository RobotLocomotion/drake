from collections.abc import Sequence
import logging
import numpy as np
import os
import re


from pydrake.common import (
    configure_logging,
)
from pydrake.geometry import (
    ReadObjToTriangleSurfaceMesh,
)
from pydrake.multibody.tree import (
    CalcSpatialInertia,
    SpatialInertia_,
)

_logger = logging.getLogger("drake")

_PACKAGE_TEMPLATE = """
<?xml version="1.0"?>
<package format="2">
  <name>{name}</name>
  <version>0.0.0</version>
  <description>
    Package generated by mesh_to_model from mesh file: {mesh_name}.
  </description>
  <maintainer email="nobody@example.com">Nobody</maintainer>
  <license>unknown</license>
</package>
"""
_VISUAL_TEMPLATE = """
      <visual name='visual'>
        <geometry>
          <pose>{geometry_position} 0 0 0</pose>
          <mesh>
            <uri>{mesh_uri}</uri>
            <scale>{mesh_scale}</scale>
          </mesh>
        </geometry>
      </visual>"""
# TODO(SeanCurtis-TRI): Provide a configurable property to disable hydroelastic
# representation.
_COLLISION_TEMPLATE = """
      <collision name='collision'>
        <geometry>
          <pose>{geometry_position} 0 0 0</pose>
          <mesh>
            <uri>{mesh_uri}</uri>
            <scale>{mesh_scale}</scale>
          </mesh>
        </geometry>
        <drake:proximity_properties>
          <!-- Friction and rigid declaration are minimum requirements for
           making a rigid hydroelastic representation. -->
          <drake:mu_dynamic>0.5</drake:mu_dynamic>
          <drake:mu_static>0.5</drake:mu_static>
          <drake:rigid_hydroelastic/>
        </drake:proximity_properties>
      </visual>"""
_SDF_TEMPLATE = """<?xml version='1.0'?>
<sdf version='1.7'>
  <model name='{name}'>
    <link name='{name}'>
      <inertial>
        <pose>{inertial_pose}</pose>
        <mass>{mass}</mass>
        <inertia>
          <ixx>{ixx}</ixx>
          <ixy>{ixy}</ixy>
          <ixz>{ixz}</ixz>
          <iyy>{iyy}</iyy>
          <iyz>{iyz}</iyz>
          <izz>{izz}</izz>
        </inertia>
      </inertial>{visual}{collision}
    </link>
  </model>
</sdf>
"""


class MeshMassSpec:
    """Controls how the mass is to be computed: density or absolute mass."""
    def __init__(self, density: float = None, mass: float = None):
        """
        Defines how the mass is specified -- via density *or* mass. At least
        one value must be defined. If mass is provided, it will be used.
        """
        if density is None and mass is None:
            raise ValueError("Neither mass nor density were defined.")
        self.density = density
        self.mass = mass


class MeshFramePose:
    """
    Controls the relative positions of geometry and body frames.

    There are three options:

        - Body origin at geometry origin.
        - Body origin at geometry center of mass.
        - Body origin at arbitrary point (measured and expressed in geometry
          frame).
    """
    def __init__(self, at_com: bool = False,
                 p_GoBo: Sequence[tuple[float, float, float]] = None):
        if at_com and p_GoBo is not None:
            raise ValueError(
                "Specify either at_com = True or p_GoBo, not both.")
        self.at_com = at_com
        self.p_GoBo = None if p_GoBo is None else np.array(p_GoBo)


class MeshModelMaker:
    """Converts a mesh file into a model, documenting the work as it goes."""
    def __init__(self):
        self.scale = 1.0
        self.model_name = None
        self.mass_spec = MeshMassSpec(density=1000)
        self.frame_pose = MeshFramePose()
        self.no_collision = False
        self.no_visual = False
        self.encoded_package = 'none'

    def make_model(self, mesh_path: str, model_path: str):
        """
        Creates a model from the mesh given at mesh_path and writes the
        corresponding model to the file at model_path based on the maker's
        configurations.

        # TODO: Incomplete documentation!

        """
        _logger.info(f"Creating a model from: {mesh_path}")

        # Figure out the mesh URI and model names.
        mesh_uri = MeshModelMaker._make_mesh_uri(self.encoded_package,
                                                 mesh_path)
        if mesh_uri is None:
            # No package prefix was determined; explanation already output to
            # log, so, we can simply return.
            return

        if self.scale <= 0:
            _logger.error(f"Scale value must be positive, given {self.scale}.")
            return

        mesh_G = ReadObjToTriangleSurfaceMesh(filename=mesh_path,
                                              scale=self.scale)
        p_GoMin, p_GoMax = mesh_G.CalcBoundingBox()
        size = p_GoMax - p_GoMin
        _logger.info("Mesh-model summary:")
        _logger.info(f"    Bounding box (in geomery frame): {size[0]} x "
                     f"{size[1]} x {size[2]} meters")

        # TODO(SeanCurtis-TRI): Confirm that the mesh is watertight.

        if self.mass_spec.mass is not None:
            # If mass is defined, it wins.
            # Neither the unit inertia nor the center of mass depend on the
            # density. So, we can compute those quantities for an arbitrary
            # density and then reconfigure the SpatialInertia with the desired
            # mass.
            M_GGo_G = CalcSpatialInertia(mesh=mesh_G, density=1.0)
            M_GGo_G = SpatialInertia_[float](mass=self.mass_spec.mass,
                                             p_PScm_E=M_GGo_G.get_com(),
                                             G_SP_E=M_GGo_G.get_unit_inertia())
        else:
            M_GGo_G = CalcSpatialInertia(mesh=mesh_G,
                                         density=self.mass_spec.density)

        p_GoGcm = M_GGo_G.get_com()
        M_GGcm_G = M_GGo_G.Shift(p_GoGcm)
        mass = M_GGo_G.get_mass()

        _logger.info(f"    Mass: {mass} kg")

        if self.frame_pose.p_GoBo is None:
            if self.frame_pose.at_com:
                p_BoGo = -p_GoGcm
                p_BoBcm = (0.0, 0.0, 0.0)
            else:
                # Default case.
                p_BoGo = (0.0, 0.0, 0.0)
                p_BoBcm = p_GoGcm
        else:
            p_BoGo = -self.frame_pose.p_GoBo
            p_BoBcm = p_GoGcm - self.frame_pose.p_GoBo

        _logger.info(f"    p_GoGcm: [{p_GoGcm[0]}, {p_GoGcm[1]}, "
                     f"{p_GoGcm[2]}]")
        _logger.info(f"    p_BoBcm: [{p_BoBcm[0]}, {p_BoBcm[1]}, "
                     f"{p_BoBcm[2]}]")

        # In SDF files, the inertia tensor is always reported around the center
        # of mass.
        I_GGcm_G = M_GGcm_G.CalcRotationalInertia()
        moments = I_GGcm_G.get_moments()
        products = I_GGcm_G.get_products()

        # Possible model name.
        mesh_file_name = os.path.basename(mesh_path)
        mesh_stem = os.path.splitext(mesh_file_name)[0]

        # TODO(SeanCurtis-TRI) Do we care about the nature of the precision
        # being printed on positions and inertia values? Currently, everything
        # is just being hit with {:g}.

        subs = dict()
        # model_name is None *or* model_name == "" prefers mesh_stem.
        subs["name"] = self.model_name or mesh_stem
        # With zero rotation, this is simply the position of com in B.
        p_BoBcm_str = " ".join([f"{x:g}" for x in p_BoBcm])
        subs["inertial_pose"] = f"{p_BoBcm_str} 0 0 0"
        subs["mass"] = mass
        subs["ixx"] = f"{moments[0]:g}"
        subs["iyy"] = f"{moments[1]:g}"
        subs["izz"] = f"{moments[2]:g}"
        subs["ixy"] = f"{products[0]:g}"
        subs["ixz"] = f"{products[1]:g}"
        subs["iyz"] = f"{products[2]:g}"
        subs["mesh_uri"] = mesh_uri
        subs["mesh_scale"] = "{s:g} {s:g} {s:g}".format(s=self.scale)
        subs["geometry_position"] = " ".join([f"{x:g}" for x in p_BoGo])
        subs["visual"] = \
            "" if self.no_visual else _VISUAL_TEMPLATE.format(**subs)
        # TODO(SeanCurtis-TRI): Determine if we can apply
        # <drake:declare_convex/> based on mesh analysis.
        subs["collision"] = \
            "" if self.no_collision else _COLLISION_TEMPLATE.format(**subs)

        with open(model_path, "w") as f:
            f.write(_SDF_TEMPLATE.format(**subs))

    @staticmethod
    def _make_mesh_uri(package_spec: str, mesh_path: str):
        """
        Given an encoded package protocol and path to the mesh, creates the
        uri to be used. May create a package.xml file in the same directory as
        the mesh file (depending on the value of package_spec).

        If package_spec contains the path to a package.xml file, that file must
        be located in an ancestor directory of the mesh file.

        Args:
            package_spec: Can be one of "none", "auto", or a path to a
                package.xml file.
            mesh_path: The path to the mesh file being processed. Used if
                package_spec is not "none". A package.xml file in that
                directory will be used or created.

        Returns:
            A string representing the uri to use the SDFormat file to reference
            the mesh.
        """
        mesh_name = os.path.basename(mesh_path)

        if package_spec == "none":
            return mesh_name

        package_path = None
        if package_spec.endswith("package.xml"):
            # The mesh must lie in the tree rooted at the package.
            abs_package = os.path.abspath(package_spec)
            abs_package_dir = os.path.split(abs_package)[0]
            abs_mesh = os.path.abspath(mesh_path)
            mesh_rel_path = os.path.relpath(abs_mesh, start=abs_package_dir)
            if mesh_rel_path.startswith('..'):
                _logger.error(
                    "When specifying the package, the mesh must be located in "
                    f"the file tree of the package.\n  package: {abs_package}"
                    f"\n  mesh: {abs_mesh}")
                return None
            package_name = MeshModelMaker._read_package_name(package_spec)
            package_path = os.path.join(package_name, mesh_rel_path)

        if package_spec == "auto":
            mesh_dir = os.path.dirname(os.path.abspath(mesh_path))
            candidate_package_path = os.path.join(mesh_dir, "package.xml")
            if os.path.exists(candidate_package_path):
                package_name = MeshModelMaker._read_package_name(
                    candidate_package_path)
            else:
                # The name of the *package* is the name of the mesh file's
                # directory.
                package_name = os.path.split(mesh_dir)[-1]
                subs = {"name": package_name,
                        "mesh_name": mesh_path.split()[-1]}
                with open(candidate_package_path, "w") as f:
                    f.write(_PACKAGE_TEMPLATE.format(**subs))
            package_path = os.path.join(package_name, mesh_name)

        if package_path is not None:
            return f"package://{package_path}"

        _logger.error(f"Unrecognized package specification: '{package_spec}'.")
        return None

    @staticmethod
    def _read_package_name(package_path: str):
        """
        Reads the ROS package manifest file at the given path, returning the
        value of the name tag.
        """
        with open(package_path) as f:
            text = "".join(f.readlines())
        match = re.search("<name>(.+?)</name>", text)
        return match.group(1)
